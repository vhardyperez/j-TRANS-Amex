// MQUtility.cpp: implementation of the MQUtility class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MQUtility.h"
#include "FDumpHex.h"
#include <SQLAPI.h> // main SQLAPI++ header
//#include "LogTrans.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

MQUtility::MQUtility()
{
	bit_map1	= "1000000000000000000000000000000000000000000000000000000000000000";
	bit_map2	= "0000000000000000000000000000000000000000000000000000000000000000";
	bit_map_iso  = bit_map1+bit_map2;
	msg_type						= "";
	header							= "";
	tpdu_header						= "";
	converted_iso_posterm			= "";
	card_number						= "";
	retornoasciicomplete			= "";
	retornohexadecimalcomplete      = "";
	isomsg8583						= "";
	complete_iso8583_msg			= "";
	isomsg8583complete              = "";
	bit_map_ascii                   = "";
	complete_0800_iso8583_msg		= "";
	bit_map							= "B23CC48128E190180000000000000128";
	message_type					= "";
	processing_code					= "";			/*003  L6  */
	transaction_amount				= "";			/*004  L12 */ 
	transaction_amount_itbis		= "";
	transmition_date_time			= "";
	convertion_rate					= "";
	system_trace					= "";
	time_local_transaction			= "";
	date_local_transaction			= "";
	expiration_date					= "";
	capture_date					= "";
	merchant_type					= "";
	acq_country_code				= "";
	date_settlement					= "";
	function_code					= "";
	pos_entry_mode					= "";
	for_athd						= "";
	pos_condition_code				= "";
	acquiring_institution_id_code	= "";
	track_2							= "";
	retrieval_reference_number		= "";
	card_acceptor_terminal_id		= "";
	card_acceptor_id_code			= "";
	card_acceptor_name_location		= "";
	track1							= "";
	additional_data					= "";
	pos_retailer_data				= "";
	currency_code_transaction		= "";
	pin_data						= "";
	pos_terminal_data				= "";
	pos_issuer_data					= "";
	geographic_data					= "";
	field_63						= "";
	CVV2							= "";								
	original_data_elements			= "",
	pos_terminal_address_branch		= "";
	echo_data						= "";
	network_managment_info_code		= "";
	pos_invoice_data				= "";
	pos_settlement_data				= "";
	card_identifier					= "";
	ebt_bit_127						= "";
	switch_key						= "";
	F1,  F2 ,  F3,  F4,  F5,  F6,  F7,  F8,  F9,  F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20	,			
	F21, F22 , F23, F24, F25, F26, F27, F28, F29, F30, F31, F32, F33, F34, F35, F36, F37, F38, F39, F40	,			
	F41, F42 , F43, F44, F45, F46, F47, F48, F49, F50, F51, F52, F53, F54, F55, F56, F57, F58, F59, F60	,
	F61, F62 , F63, F64, F65, F66, F67, F68, F69, F70, F71, F72, F73, F74, F75, F76, F77, F78, F79, F80 ,	
	F81, F82 , F83, F84, F85, F86, F87, F88, F89, F90, F91, F92, F93, F94, F95, F96, F97, F98, F99, F100 ,	
	F101,F102 ,F103,F104,F105,F106,F107,F108,F109,F110,F111,F112,F113,F114,F115,F116,F117,F118,F119,F120 ,
	F121,F122 ,F123,F124,F125,F126,F127,F128 = "";

	
	processing_code_03					= "";
	transaction_amount_04				= "";
	transmition_date_time_07			= "";
	system_trace_011					= "";
	convertion_rate_010					= "";
	time_local_transaction_012			= "";
	date_local_transaction_013			= "";		
	expiration_date_014					= "";					
	date_settlement_015					= "";
	capture_date_017					= "";
	merchant_type_018					= "";
	pos_entry_mode_022					= "";
	for_athd_024						= "";
	pos_condition_code_025				= "";
	acquiring_institution_id_code_032	= "";
	track_2_035							= "";
	retrieval_reference_number_037		= "";
	responde_id_response_038            = "";
	responde_code_039					= "";
	card_acceptor_terminal_id_041		= "";	
	card_acceptor_id_code_042			= "";		
	card_acceptor_name_location_043		= "";
	track_1_045							= "";
	addditional_data_048				= "";
	currency_code_transaction_049       = "";
	pin_data_052						= "";
	additional_data_054					= "";
	pos_terminal_data_060				= "";
	card_issuer_response_data_061		= "";
	additional_data_063					= "";
	receiving_institution_id_code_0100	= "";
	account_information_102				= "";
	pos_terminal_address_branch_120		= "";
	authorization_indicators_0121		= "";
	pos_invoice_data_0123				= "";
	batch_record2_0124					= "";
	pos_settlement_data_125				= "";
	preauthorization_data_0126			= "";
	
	response_0210_generic_from_iso		= "";
	lllvar								= "";
	llvar								= "";
	bit_map_first_part					= "";
	bit_map_second_part					= "";

	strcpy(recv_queue,"");
	strcpy(InClient,"");
	strcpy(IPAddr,"");
	strcpy(APPName,"");
	strcpy(send_queue,"");
	strcpy(send_queue_alterno,"");
	strcpy(recv_queue,"");
	strcpy(sql_queue,"");
	strcpy(queue_mgr,"");
	strcpy(header_ini,"");
	strcpy(application,"");
	strcpy(send_queue_eps,"");
	strcpy(send_queue_amex,"");
	debugSB =0 ;
	strcpy(send_queue_string,"");
	strcpy(send_queue_alterno_string,"");
	strcpy(recv_queue_string,"");	
	strcpy(sql_queue_string,"");	
	strcpy(queue_mgr_string,"");	
	strcpy(header_string,"")	;	
	strcpy(application_string,"");
	strcpy(send_queue_eps_string,"");
	strcpy(send_queue_amex_string,"");


}

RWCString MQUtility::Get_Msg_From_SendQueueNew( RWCString key_message,  char *send_queue,char *queue_mgr)
{
	  /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */
   MQGMO   gmo = {MQGMO_DEFAULT};   /* get message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   //MQBYTE   buffer[1024];            /* message buffer                */
   MQLONG   buflen;                 /* buffer length                 */
   MQLONG   messlen;                /* message length received       */
   char     QMName[50];             /* queue manager name            */
   char     buffer[1024];            /* message buffer                */
  

   /******************************************************************/
   /*                                                                */
   /*   Create object descriptor for subject queue                   */
   /*                                                                */
   /******************************************************************/
   strcpy(od.ObjectName, send_queue);
   QMName[0] = 0;   /* default */
   //if (argc > 2)
     strcpy(QMName, queue_mgr);

   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Open the named message queue for input; exclusive or shared  */
   /*   use of the queue is controlled by the queue definition here  */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_INPUT_AS_Q_DEF   /* open queue for input         */
         + MQOO_FAIL_IF_QUIESCING;   /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* completion code              */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for input\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Get messages from the message queue                          */
   /*   Loop until there is a failure                                */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;       /* use MQOPEN result for initial test  */
   
   /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQGET          */ 
   /******************************************************************/
   /*gmo.Version = MQGMO_VERSION_2;*/ /* Avoid need to reset Message */
   /*gmo.MatchOptions = MQMO_NONE; */ /* ID and Correlation ID after */
                                      /* every MQGET                 */
   gmo.Options = MQGMO_WAIT       /* wait for new messages           */
               + MQGMO_CONVERT;   /* convert if necessary            */
   gmo.WaitInterval = 30000;      /* 15 second limit for waiting     */
   //gmo.MsgId("BTRAN3");
    // strcpy(md.MsgId,"BTRAN3");

   //while (CompCode != MQCC_FAILED)
   //{
     buflen = sizeof(buffer) - 1; /* buffer size available for GET   */

     /****************************************************************/
     /* The following two statements are not required if the MQGMO   */
     /* version is set to MQGMO_VERSION_2 and and gmo.MatchOptions   */
     /* is set to MQGMO_NONE                                         */
     /****************************************************************/
     /*                                                              */
     /*   In order to read the messages in sequence, MsgId and       */
     /*   CorrelID must have the default value.  MQGET sets them     */
     /*   to the values in for message it returns, so re-initialise  */
     /*   them before every call                                     */
     /*                                                              */
     /****************************************************************/
    // memcpy(md.MsgId, MQMI_NONE, sizeof(md.MsgId));
    // cout << "Valor de key_message > " << key_message << endl;
	 memcpy(md.MsgId,key_message,18);
	 
	 //memcpy(md.CorrelId, MQCI_NONE, sizeof(md.CorrelId));


     /****************************************************************/
     /*                                                              */
     /*   MQGET sets Encoding and CodedCharSetId to the values in    */
     /*   the message returned, so these fields should be reset to   */
     /*   the default values before every call, as MQGMO_CONVERT is  */
     /*   specified.                                                 */
     /*                                                              */
     /****************************************************************/

     md.Encoding       = MQENC_NATIVE;
     md.CodedCharSetId = MQCCSI_Q_MGR;

     MQGET(Hcon,                /* connection handle                 */
           Hobj,                /* object handle                     */
           &md,                 /* message descriptor                */
           &gmo,                /* get message options               */
           buflen,              /* buffer length                     */
           buffer,              /* message buffer                    */
           &messlen,            /* message length                    */
           &CompCode,           /* completion code                   */
           &Reason);            /* reason code                       */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       if (Reason == MQRC_NO_MSG_AVAILABLE)
       {                         /* special report for normal end    */
         printf("no more messages\n");
       }
       else                      /* general report for other reasons */
       {
         printf("MQGET ended with reason code %ld\n", Reason);

         /*   treat truncated message as a failure for this sample   */
         if (Reason == MQRC_TRUNCATED_MSG_FAILED)
         {
           CompCode = MQCC_FAILED;
         }
       }
     }

     /****************************************************************/
     /*   Display each message received                              */
     /****************************************************************/
     if (CompCode != MQCC_FAILED)
     {
       buffer[messlen] = '\0';            /* add terminator          */
       //printf("message <%s>\n", buffer);
     }
   //}

   /******************************************************************/
   /*                                                                */
   /*   Close the source queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                   /* no close options            */
     MQCLOSE(Hcon,                    /* connection handle           */
             &Hobj,                   /* object handle               */
             C_options,
             &CompCode,               /* completion code             */
             &Reason);                /* reason code                 */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED )
   {
     MQDISC(&Hcon,                     /* connection handle          */
            &CompCode,                 /* completion code            */
            &Reason);                  /* reason code                */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSGET0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSGET0 end\n");


   RWCString output_string = buffer;
   /*
   int len = strlen(buffer);
	for(int i = 0; i < len ; i++)
	{

	}
	*/
	return output_string;
}


RWCString MQUtility::GetMsgFromSendQueuePagos( RWCString key_message,  char *send_queue,char *queue_mgr)
{
	  /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */
   MQGMO   gmo = {MQGMO_DEFAULT};   /* get message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   //MQBYTE   buffer[1024];            /* message buffer                */
   MQLONG   buflen;                 /* buffer length                 */
   MQLONG   messlen;                /* message length received       */
   char     QMName[50];             /* queue manager name            */
   char     buffer[1024];            /* message buffer                */
  
   strcpy(buffer, "");
   /******************************************************************/
   /*                                                                */
   /*   Create object descriptor for subject queue                   */
   /*                                                                */
   /******************************************************************/
   strcpy(od.ObjectName, send_queue);
   QMName[0] = 0;   /* default */
   //if (argc > 2)
     strcpy(QMName, queue_mgr);

   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Open the named message queue for input; exclusive or shared  */
   /*   use of the queue is controlled by the queue definition here  */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_INPUT_AS_Q_DEF   /* open queue for input         */
         + MQOO_FAIL_IF_QUIESCING;   /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* completion code              */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for input\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Get messages from the message queue                          */
   /*   Loop until there is a failure                                */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;       /* use MQOPEN result for initial test  */
   
   /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQGET          */ 
   /******************************************************************/
   /*gmo.Version = MQGMO_VERSION_2;*/ /* Avoid need to reset Message */
   /*gmo.MatchOptions = MQMO_NONE; */ /* ID and Correlation ID after */
                                      /* every MQGET                 */
   gmo.Options = MQGMO_WAIT       /* wait for new messages           */
               + MQGMO_CONVERT;   /* convert if necessary            */
   gmo.WaitInterval = 22000;      /* 15 second limit for waiting     */
   //gmo.MsgId("BTRAN3");
    // strcpy(md.MsgId,"BTRAN3");

   //while (CompCode != MQCC_FAILED)
   //{
     buflen = sizeof(buffer) - 1; /* buffer size available for GET   */

     /****************************************************************/
     /* The following two statements are not required if the MQGMO   */
     /* version is set to MQGMO_VERSION_2 and and gmo.MatchOptions   */
     /* is set to MQGMO_NONE                                         */
     /****************************************************************/
     /*                                                              */
     /*   In order to read the messages in sequence, MsgId and       */
     /*   CorrelID must have the default value.  MQGET sets them     */
     /*   to the values in for message it returns, so re-initialise  */
     /*   them before every call                                     */
     /*                                                              */
     /****************************************************************/
    // memcpy(md.MsgId, MQMI_NONE, sizeof(md.MsgId));
    // cout << "Valor de key_message > " << key_message << endl;
	 memcpy(md.MsgId,key_message,24);
	 
	 //memcpy(md.CorrelId, MQCI_NONE, sizeof(md.CorrelId));


     /****************************************************************/
     /*                                                              */
     /*   MQGET sets Encoding and CodedCharSetId to the values in    */
     /*   the message returned, so these fields should be reset to   */
     /*   the default values before every call, as MQGMO_CONVERT is  */
     /*   specified.                                                 */
     /*                                                              */
     /****************************************************************/

     md.Encoding       = MQENC_NATIVE;
     md.CodedCharSetId = MQCCSI_Q_MGR;

     MQGET(Hcon,                /* connection handle                 */
           Hobj,                /* object handle                     */
           &md,                 /* message descriptor                */
           &gmo,                /* get message options               */
           buflen,              /* buffer length                     */
           buffer,              /* message buffer                    */
           &messlen,            /* message length                    */
           &CompCode,           /* completion code                   */
           &Reason);            /* reason code                       */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       if (Reason == MQRC_NO_MSG_AVAILABLE)
       {                         /* special report for normal end    */
         printf("no more messages\n");
       }
       else                      /* general report for other reasons */
       {
         printf("MQGET ended with reason code %ld\n", Reason);

         /*   treat truncated message as a failure for this sample   */
         if (Reason == MQRC_TRUNCATED_MSG_FAILED)
         {
           CompCode = MQCC_FAILED;
         }
       }
     }

     /****************************************************************/
     /*   Display each message received                              */
     /****************************************************************/
     if (CompCode != MQCC_FAILED)
     {
       buffer[messlen] = '\0';            /* add terminator          */
       //printf("message <%s>\n", buffer);
     }
   //}

   /******************************************************************/
   /*                                                                */
   /*   Close the source queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                   /* no close options            */
     MQCLOSE(Hcon,                    /* connection handle           */
             &Hobj,                   /* object handle               */
             C_options,
             &CompCode,               /* completion code             */
             &Reason);                /* reason code                 */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED )
   {
     MQDISC(&Hcon,                     /* connection handle          */
            &CompCode,                 /* completion code            */
            &Reason);                  /* reason code                */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSGET0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSGET0 end\n");


   RWCString output_string = buffer;
   /*
   int len = strlen(buffer);
	for(int i = 0; i < len ; i++)
	{

	}
	*/
	return output_string;
}





RWCString MQUtility::GetMsgFromSendQueueCallCenterVen( RWCString key_message,  char *send_queue,char *queue_mgr)
{
	  /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */
   MQGMO   gmo = {MQGMO_DEFAULT};   /* get message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   //MQBYTE   buffer[1024];            /* message buffer                */
   MQLONG   buflen;                 /* buffer length                 */
   MQLONG   messlen;                /* message length received       */
   char     QMName[50];             /* queue manager name            */
   char     buffer[1024];            /* message buffer                */
  
	strcpy(buffer, "");
   /******************************************************************/
   /*                                                                */
   /*   Create object descriptor for subject queue                   */
   /*                                                                */
   /******************************************************************/
   strcpy(od.ObjectName, send_queue);
   QMName[0] = 0;   /* default */
   //if (argc > 2)
     strcpy(QMName, queue_mgr);

   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Open the named message queue for input; exclusive or shared  */
   /*   use of the queue is controlled by the queue definition here  */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_INPUT_AS_Q_DEF   /* open queue for input         */
         + MQOO_FAIL_IF_QUIESCING;   /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* completion code              */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for input\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Get messages from the message queue                          */
   /*   Loop until there is a failure                                */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;       /* use MQOPEN result for initial test  */
   
   /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQGET          */ 
   /******************************************************************/
   /*gmo.Version = MQGMO_VERSION_2;*/ /* Avoid need to reset Message */
   /*gmo.MatchOptions = MQMO_NONE; */ /* ID and Correlation ID after */
                                      /* every MQGET                 */
   gmo.Options = MQGMO_WAIT       /* wait for new messages           */
               + MQGMO_CONVERT;   /* convert if necessary            */
   gmo.WaitInterval = 25000;      /* 15 second limit for waiting     */
   //gmo.MsgId("BTRAN3");
    // strcpy(md.MsgId,"BTRAN3");

   //while (CompCode != MQCC_FAILED)
   //{
     buflen = sizeof(buffer) - 1; /* buffer size available for GET   */

     /****************************************************************/
     /* The following two statements are not required if the MQGMO   */
     /* version is set to MQGMO_VERSION_2 and and gmo.MatchOptions   */
     /* is set to MQGMO_NONE                                         */
     /****************************************************************/
     /*                                                              */
     /*   In order to read the messages in sequence, MsgId and       */
     /*   CorrelID must have the default value.  MQGET sets them     */
     /*   to the values in for message it returns, so re-initialise  */
     /*   them before every call                                     */
     /*                                                              */
     /****************************************************************/
    // memcpy(md.MsgId, MQMI_NONE, sizeof(md.MsgId));
    // cout << "Valor de key_message > " << key_message << endl;
	 memcpy(md.MsgId,key_message,24);
	 
	 //memcpy(md.CorrelId, MQCI_NONE, sizeof(md.CorrelId));


     /****************************************************************/
     /*                                                              */
     /*   MQGET sets Encoding and CodedCharSetId to the values in    */
     /*   the message returned, so these fields should be reset to   */
     /*   the default values before every call, as MQGMO_CONVERT is  */
     /*   specified.                                                 */
     /*                                                              */
     /****************************************************************/

     md.Encoding       = MQENC_NATIVE;
     md.CodedCharSetId = MQCCSI_Q_MGR;

     MQGET(Hcon,                /* connection handle                 */
           Hobj,                /* object handle                     */
           &md,                 /* message descriptor                */
           &gmo,                /* get message options               */
           buflen,              /* buffer length                     */
           buffer,              /* message buffer                    */
           &messlen,            /* message length                    */
           &CompCode,           /* completion code                   */
           &Reason);            /* reason code                       */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       if (Reason == MQRC_NO_MSG_AVAILABLE)
       {                         /* special report for normal end    */
         printf("no more messages\n");
       }
       else                      /* general report for other reasons */
       {
         printf("MQGET ended with reason code %ld\n", Reason);

         /*   treat truncated message as a failure for this sample   */
         if (Reason == MQRC_TRUNCATED_MSG_FAILED)
         {
           CompCode = MQCC_FAILED;
         }
       }
     }

     /****************************************************************/
     /*   Display each message received                              */
     /****************************************************************/
     if (CompCode != MQCC_FAILED)
     {
       buffer[messlen] = '\0';            /* add terminator          */
       //printf("message <%s>\n", buffer);
     }
   //}

   /******************************************************************/
   /*                                                                */
   /*   Close the source queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                   /* no close options            */
     MQCLOSE(Hcon,                    /* connection handle           */
             &Hobj,                   /* object handle               */
             C_options,
             &CompCode,               /* completion code             */
             &Reason);                /* reason code                 */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED )
   {
     MQDISC(&Hcon,                     /* connection handle          */
            &CompCode,                 /* completion code            */
            &Reason);                  /* reason code                */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSGET0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSGET0 end\n");


   RWCString output_string = buffer;
   /*
   int len = strlen(buffer);
	for(int i = 0; i < len ; i++)
	{

	}
	*/
	return output_string;
}

RWCString MQUtility::GetMsgFromSendQueueHeader( RWCString key_message,  char *send_queue,char *queue_mgr)
{
	  /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */
   MQGMO   gmo = {MQGMO_DEFAULT};   /* get message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   //MQBYTE   buffer[1024];            /* message buffer                */
   MQLONG   buflen;                 /* buffer length                 */
   MQLONG   messlen;                /* message length received       */
   char     QMName[50];             /* queue manager name            */
   char     buffer[1024];            /* message buffer                */
   strcpy(buffer, "");

   /******************************************************************/
   /*                                                                */
   /*   Create object descriptor for subject queue                   */
   /*                                                                */
   /******************************************************************/
   strcpy(od.ObjectName, send_queue);
   QMName[0] = 0;   /* default */
   //if (argc > 2)
     strcpy(QMName, queue_mgr);

   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Open the named message queue for input; exclusive or shared  */
   /*   use of the queue is controlled by the queue definition here  */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_INPUT_AS_Q_DEF   /* open queue for input         */
         + MQOO_FAIL_IF_QUIESCING;   /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* completion code              */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for input\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Get messages from the message queue                          */
   /*   Loop until there is a failure                                */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;       /* use MQOPEN result for initial test  */
   
   /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQGET          */ 
   /******************************************************************/
   /*gmo.Version = MQGMO_VERSION_2;*/ /* Avoid need to reset Message */
   /*gmo.MatchOptions = MQMO_NONE; */ /* ID and Correlation ID after */
                                      /* every MQGET                 */
   gmo.Options = MQGMO_WAIT       /* wait for new messages           */
               + MQGMO_CONVERT;   /* convert if necessary            */
   gmo.WaitInterval = 25000;      /* 15 second limit for waiting     */
   //gmo.MsgId("BTRAN3");
    // strcpy(md.MsgId,"BTRAN3");

   //while (CompCode != MQCC_FAILED)
   //{
     buflen = sizeof(buffer) - 1; /* buffer size available for GET   */

     /****************************************************************/
     /* The following two statements are not required if the MQGMO   */
     /* version is set to MQGMO_VERSION_2 and and gmo.MatchOptions   */
     /* is set to MQGMO_NONE                                         */
     /****************************************************************/
     /*                                                              */
     /*   In order to read the messages in sequence, MsgId and       */
     /*   CorrelID must have the default value.  MQGET sets them     */
     /*   to the values in for message it returns, so re-initialise  */
     /*   them before every call                                     */
     /*                                                              */
     /****************************************************************/
    // memcpy(md.MsgId, MQMI_NONE, sizeof(md.MsgId));
    // cout << "Valor de key_message > :" << key_message << ":" << endl;
	 memcpy(md.MsgId,key_message,24);
	 
	 //memcpy(md.CorrelId, MQCI_NONE, sizeof(md.CorrelId));


     /****************************************************************/
     /*                                                              */
     /*   MQGET sets Encoding and CodedCharSetId to the values in    */
     /*   the message returned, so these fields should be reset to   */
     /*   the default values before every call, as MQGMO_CONVERT is  */
     /*   specified.                                                 */
     /*                                                              */
     /****************************************************************/

     md.Encoding       = MQENC_NATIVE;
     md.CodedCharSetId = MQCCSI_Q_MGR;

     MQGET(Hcon,                /* connection handle                 */
           Hobj,                /* object handle                     */
           &md,                 /* message descriptor                */
           &gmo,                /* get message options               */
           buflen,              /* buffer length                     */
           buffer,              /* message buffer                    */
           &messlen,            /* message length                    */
           &CompCode,           /* completion code                   */
           &Reason);            /* reason code                       */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       if (Reason == MQRC_NO_MSG_AVAILABLE)
       {                         /* special report for normal end    */
         printf("no more messages\n");
       }
       else                      /* general report for other reasons */
       {
         printf("MQGET ended with reason code %ld\n", Reason);

         /*   treat truncated message as a failure for this sample   */
         if (Reason == MQRC_TRUNCATED_MSG_FAILED)
         {
           CompCode = MQCC_FAILED;
         }
       }
     }

     /****************************************************************/
     /*   Display each message received                              */
     /****************************************************************/
     if (CompCode != MQCC_FAILED)
     {
       buffer[messlen] = '\0';            /* add terminator          */
       //printf("message <%s>\n", buffer);
     }
   //}

   /******************************************************************/
   /*                                                                */
   /*   Close the source queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                   /* no close options            */
     MQCLOSE(Hcon,                    /* connection handle           */
             &Hobj,                   /* object handle               */
             C_options,
             &CompCode,               /* completion code             */
             &Reason);                /* reason code                 */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED )
   {
     MQDISC(&Hcon,                     /* connection handle          */
            &CompCode,                 /* completion code            */
            &Reason);                  /* reason code                */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSGET0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSGET0 end\n");


   RWCString output_string = buffer;
   /*
   int len = strlen(buffer);
	for(int i = 0; i < len ; i++)
	{

	}
	*/
	return output_string;
}


RWCString MQUtility::GetMsgFromRecvQueueHeaderUsingTimeOutParameters(  char *send_queue,char *queue_mgr, int time_out)
{
	  /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */
   MQGMO   gmo = {MQGMO_DEFAULT};   /* get message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   //MQBYTE   buffer[1024];            /* message buffer                */
   MQLONG   buflen;                 /* buffer length                 */
   MQLONG   messlen;                /* message length received       */
   char     QMName[50];             /* queue manager name            */
   char     buffer[1024] = {""};            /* message buffer                */
  

   /******************************************************************/
   /*                                                                */
   /*   Create object descriptor for subject queue                   */
   /*                                                                */
   /******************************************************************/
   strcpy(od.ObjectName, send_queue);
   QMName[0] = 0;   /* default */
   //if (argc > 2)
     strcpy(QMName, queue_mgr);

   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Open the named message queue for input; exclusive or shared  */
   /*   use of the queue is controlled by the queue definition here  */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_INPUT_AS_Q_DEF   /* open queue for input         */
         + MQOO_FAIL_IF_QUIESCING;   /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* completion code              */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for input\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Get messages from the message queue                          */
   /*   Loop until there is a failure                                */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;       /* use MQOPEN result for initial test  */
   
   /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQGET          */ 
   /******************************************************************/
   /*gmo.Version = MQGMO_VERSION_2;*/ /* Avoid need to reset Message */
   /*gmo.MatchOptions = MQMO_NONE; */ /* ID and Correlation ID after */
                                      /* every MQGET                 */
   gmo.Options = MQGMO_WAIT       /* wait for new messages           */
               + MQGMO_CONVERT;   /* convert if necessary            */
   gmo.WaitInterval = time_out;      /* 15 second limit for waiting     */
   //gmo.MsgId("BTRAN3");
    // strcpy(md.MsgId,"BTRAN3");

   //while (CompCode != MQCC_FAILED)
   //{
     buflen = sizeof(buffer) - 1; /* buffer size available for GET   */

     /****************************************************************/
     /* The following two statements are not required if the MQGMO   */
     /* version is set to MQGMO_VERSION_2 and and gmo.MatchOptions   */
     /* is set to MQGMO_NONE                                         */
     /****************************************************************/
     /*                                                              */
     /*   In order to read the messages in sequence, MsgId and       */
     /*   CorrelID must have the default value.  MQGET sets them     */
     /*   to the values in for message it returns, so re-initialise  */
     /*   them before every call                                     */
     /*                                                              */
     /****************************************************************/
    // memcpy(md.MsgId, MQMI_NONE, sizeof(md.MsgId));
    // cout << "Valor de key_message > :" << key_message << ":" << endl;
	// memcpy(md.MsgId,key_message,24);
	 
	 //memcpy(md.CorrelId, MQCI_NONE, sizeof(md.CorrelId));


     /****************************************************************/
     /*                                                              */
     /*   MQGET sets Encoding and CodedCharSetId to the values in    */
     /*   the message returned, so these fields should be reset to   */
     /*   the default values before every call, as MQGMO_CONVERT is  */
     /*   specified.                                                 */
     /*                                                              */
     /****************************************************************/

     md.Encoding       = MQENC_NATIVE;
     md.CodedCharSetId = MQCCSI_Q_MGR;

     MQGET(Hcon,                /* connection handle                 */
           Hobj,                /* object handle                     */
           &md,                 /* message descriptor                */
           &gmo,                /* get message options               */
           buflen,              /* buffer length                     */
           buffer,              /* message buffer                    */
           &messlen,            /* message length                    */
           &CompCode,           /* completion code                   */
           &Reason);            /* reason code                       */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       if (Reason == MQRC_NO_MSG_AVAILABLE)
       {                         /* special report for normal end    */
         //printf("no more messages\n");
       }
       else                      /* general report for other reasons */
       {
         printf("MQGET ended with reason code %ld\n", Reason);

         /*   treat truncated message as a failure for this sample   */
         if (Reason == MQRC_TRUNCATED_MSG_FAILED)
         {
           CompCode = MQCC_FAILED;
         }
       }
     }

     /****************************************************************/
     /*   Display each message received                              */
     /****************************************************************/
     if (CompCode != MQCC_FAILED)
     {
       buffer[messlen] = '\0';            /* add terminator          */
       //printf("message <%s>\n", buffer);
     }
   //}

   /******************************************************************/
   /*                                                                */
   /*   Close the source queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                   /* no close options            */
     MQCLOSE(Hcon,                    /* connection handle           */
             &Hobj,                   /* object handle               */
             C_options,
             &CompCode,               /* completion code             */
             &Reason);                /* reason code                 */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED )
   {
     MQDISC(&Hcon,                     /* connection handle          */
            &CompCode,                 /* completion code            */
            &Reason);                  /* reason code                */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSGET0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSGET0 end\n");


   RWCString output_string = buffer;
   /*
   int len = strlen(buffer);
	for(int i = 0; i < len ; i++)
	{

	}
	*/
	return output_string;
}



RWCString MQUtility::GetMsgFromRecvQueueHeader(  char *send_queue,char *queue_mgr)
{
	  /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */
   MQGMO   gmo = {MQGMO_DEFAULT};   /* get message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   //MQBYTE   buffer[1024];            /* message buffer                */
   MQLONG   buflen;                 /* buffer length                 */
   MQLONG   messlen;                /* message length received       */
   char     QMName[50];             /* queue manager name            */
   char     buffer[1024] = {""};            /* message buffer                */
  

   /******************************************************************/
   /*                                                                */
   /*   Create object descriptor for subject queue                   */
   /*                                                                */
   /******************************************************************/
   strcpy(od.ObjectName, send_queue);
   QMName[0] = 0;   /* default */
   //if (argc > 2)
     strcpy(QMName, queue_mgr);

   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Open the named message queue for input; exclusive or shared  */
   /*   use of the queue is controlled by the queue definition here  */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_INPUT_AS_Q_DEF   /* open queue for input         */
         + MQOO_FAIL_IF_QUIESCING;   /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* completion code              */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for input\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Get messages from the message queue                          */
   /*   Loop until there is a failure                                */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;       /* use MQOPEN result for initial test  */
   
   /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQGET          */ 
   /******************************************************************/
   /*gmo.Version = MQGMO_VERSION_2;*/ /* Avoid need to reset Message */
   /*gmo.MatchOptions = MQMO_NONE; */ /* ID and Correlation ID after */
                                      /* every MQGET                 */
   gmo.Options = MQGMO_WAIT       /* wait for new messages           */
               + MQGMO_CONVERT;   /* convert if necessary            */
   gmo.WaitInterval = 22000;      /* 15 second limit for waiting     */
   //gmo.MsgId("BTRAN3");
    // strcpy(md.MsgId,"BTRAN3");

   //while (CompCode != MQCC_FAILED)
   //{
     buflen = sizeof(buffer) - 1; /* buffer size available for GET   */

     /****************************************************************/
     /* The following two statements are not required if the MQGMO   */
     /* version is set to MQGMO_VERSION_2 and and gmo.MatchOptions   */
     /* is set to MQGMO_NONE                                         */
     /****************************************************************/
     /*                                                              */
     /*   In order to read the messages in sequence, MsgId and       */
     /*   CorrelID must have the default value.  MQGET sets them     */
     /*   to the values in for message it returns, so re-initialise  */
     /*   them before every call                                     */
     /*                                                              */
     /****************************************************************/
    // memcpy(md.MsgId, MQMI_NONE, sizeof(md.MsgId));
    // cout << "Valor de key_message > :" << key_message << ":" << endl;
	// memcpy(md.MsgId,key_message,24);
	 
	 //memcpy(md.CorrelId, MQCI_NONE, sizeof(md.CorrelId));


     /****************************************************************/
     /*                                                              */
     /*   MQGET sets Encoding and CodedCharSetId to the values in    */
     /*   the message returned, so these fields should be reset to   */
     /*   the default values before every call, as MQGMO_CONVERT is  */
     /*   specified.                                                 */
     /*                                                              */
     /****************************************************************/

     md.Encoding       = MQENC_NATIVE;
     md.CodedCharSetId = MQCCSI_Q_MGR;

     MQGET(Hcon,                /* connection handle                 */
           Hobj,                /* object handle                     */
           &md,                 /* message descriptor                */
           &gmo,                /* get message options               */
           buflen,              /* buffer length                     */
           buffer,              /* message buffer                    */
           &messlen,            /* message length                    */
           &CompCode,           /* completion code                   */
           &Reason);            /* reason code                       */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       if (Reason == MQRC_NO_MSG_AVAILABLE)
       {                         /* special report for normal end    */
         //printf("no more messages\n");
       }
       else                      /* general report for other reasons */
       {
         printf("MQGET ended with reason code %ld\n", Reason);

         /*   treat truncated message as a failure for this sample   */
         if (Reason == MQRC_TRUNCATED_MSG_FAILED)
         {
           CompCode = MQCC_FAILED;
         }
       }
     }

     /****************************************************************/
     /*   Display each message received                              */
     /****************************************************************/
     if (CompCode != MQCC_FAILED)
     {
       buffer[messlen] = '\0';            /* add terminator          */
       //printf("message <%s>\n", buffer);
     }
   //}

   /******************************************************************/
   /*                                                                */
   /*   Close the source queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                   /* no close options            */
     MQCLOSE(Hcon,                    /* connection handle           */
             &Hobj,                   /* object handle               */
             C_options,
             &CompCode,               /* completion code             */
             &Reason);                /* reason code                 */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED )
   {
     MQDISC(&Hcon,                     /* connection handle          */
            &CompCode,                 /* completion code            */
            &Reason);                  /* reason code                */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSGET0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSGET0 end\n");


   RWCString output_string = buffer;
   /*
   int len = strlen(buffer);
	for(int i = 0; i < len ; i++)
	{

	}
	*/
	return output_string;
}




RWCString MQUtility::SendMessageToQueueNew(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */

   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=500; /* cambiar msg descr */ 
	 // cout << "Valor de system_trace_11+retrieval_037 > " << system_trace_11+retrieval_037
//		  << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037,18);
	  //memcpy(md.MsgId,llave,llave.length());
	  // strcpy(md.MsgId,llave);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformation() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformation());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.Get_Msg_From_SendQueueNew(system_trace_11+retrieval_037,recv_queue_string,queue_mgr_string);
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	return msg_return.Retorno_210_B24(retorno_0210,"0210",1);



}


RWCString MQUtility::SendMessageToQueuePosVSD(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */

   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=500; /* cambiar msg descr */ 
	 // cout << "Valor de system_trace_11+retrieval_037 > " << system_trace_11+retrieval_037
//		  << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037,18);
	  //memcpy(md.MsgId,llave,llave.length());
	  // strcpy(md.MsgId,llave);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPosVirtual() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPosVirtual());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.Get_Msg_From_SendQueueNew(system_trace_11+retrieval_037,recv_queue_string,queue_mgr_string);
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	return msg_return.Retorno_210_B24(retorno_0210,"0210",1);



}


RWCString MQUtility::SendMessageToQueuePosVen(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=500; /* cambiar msg descr */ 
	 // cout << "Valor de system_trace_11+retrieval_037 > " << system_trace_11+retrieval_037
//		  << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037,18);
	  //memcpy(md.MsgId,llave,llave.length());
	  // strcpy(md.MsgId,llave);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPosVirtualVen() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPosVirtualVen());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.Get_Msg_From_SendQueueNew(system_trace_11+retrieval_037,recv_queue_string,queue_mgr_string);
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	return msg_return.Retorno_210_B24(retorno_0210,"0210",1);



}



RWCString MQUtility::SendMessageToQueueAth(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
	strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=500; /* cambiar msg descr */ 
	 // cout << "Valor de system_trace_11+retrieval_037 > " << system_trace_11+retrieval_037
//		  << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037,18);
	  //memcpy(md.MsgId,llave,llave.length());
	  // strcpy(md.MsgId,llave);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationAth() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationAth());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
//	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	cout << "Valor de recv_queue_string > " << recv_queue_string << endl;
	
	RWCString retorno_0210 = set_tcp_header1.Get_Msg_From_SendQueueNew(system_trace_11+retrieval_037,recv_queue_string,queue_mgr_string);
	strcpy(recv_0210, retorno_0210);



	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);

	if (retorno_0210.length() > 50)
		retorno_0210 = msg_return.Retorno_Msg_Generic_PostermB24("00"+retorno_0210,"0210",1,"base24");
	else
		retorno_0210 = "0";

	cout << "Valor de retorno_0210 > " << retorno_0210 << endl;
	
	return retorno_0210;

}


RWCString MQUtility::SendMessageToQueueNewVisa(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
	strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=500; /* cambiar msg descr */ 
//	  cout << "Valor de system_trace_11+retrieval_037 > " << system_trace_11+retrieval_037
//		  << endl;
	  //RWCString last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037,18);
	  //memcpy(md.MsgId,llave,llave.length());
	  // strcpy(md.MsgId,llave);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationVisa() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationVisa());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	
	RWCString retorno_0210 = set_tcp_header1.Get_Msg_From_SendQueueNew(system_trace_11+retrieval_037,recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;



}


RWCString MQUtility::SendMessageToQueueNewPagos(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagos());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;



}


RWCString MQUtility::SendMessageToQueueNewPagosPlata(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=150; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_alterno_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(incoming,"MONITOR",queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(recv_0210,"MONITOR",queue_mgr_string);
	
	
	return retorno_0210;



}

RWCString MQUtility::SendMessageToQueueNewPagosPlata2(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=150; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

//	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_alterno_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata2());
	RWCString token;
	RWCString send_queue,send_queue_alterno,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		
		if (count == 1)
		{
			send_queue_alterno = token;
		}
		
		if (count == 2)
		{
		
			recv_queue = token; 
		}
		if (count == 3)
		{
		
			sql_queue = token; 
		}

		if (count == 4)
		{
		
			queue_mgr = token; 
		}
		if (count == 5)
		{
		
			header = token; 
		}
		if (count == 6)
		{
		
			application = token; 
		}
		count++;
	}
	/*
	cout << "Valor de send_queue >         " << send_queue << endl;
	cout << "Valor de send_queue_alterno > " << send_queue_alterno << endl;
	cout << "Valor de recv_queue >         " << recv_queue << endl;
	cout << "Valor de sql_queue >          " << sql_queue << endl;
	cout << "Valor de queue_mgr >          " << queue_mgr << endl;
	cout << "Valor de header >             " << header << endl;
	cout << "Valor de application >        " << application << endl;

    cout << "Valor de recv_queue >         " << recv_queue  << endl;
*/
	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_alterno_string,send_queue_alterno);

	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);

/*
	cout << "Valor de send_queue_string >         " << send_queue_string << endl;
	cout << "Valor de send_queue_alterno_string > " << send_queue_alterno_string << endl;
	cout << "Valor de recv_queue_string >         " << recv_queue_string << endl;
	cout << "Valor de sql_queue_string >          " << sql_queue_string << endl;
	cout << "Valor de queue_mgr_string >          " << queue_mgr_string << endl;
	cout << "Valor de header_string >             " << header_string << endl;
	cout << "Valor de application_string >        " << application_string << endl;
*/
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};

//	cout << "Antes dentro#1********" << endl;

	cout << "Valor de sql_queue_string >          " << sql_queue_string << endl;
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(incoming,"MONITOR",queue_mgr_string);
//   cout << "Antes dentro********" << endl;
	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(recv_0210,"MONITOR",queue_mgr_string);
	
	
	return retorno_0210;



}


RWCString MQUtility::SendMessageToQueueNewPagosLotes(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=150; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagosLotes() ;
	               

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosLotes());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(incoming,"MONITOR",queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(recv_0210,"MONITOR",queue_mgr_string);
	
	
	return retorno_0210;



}

RWCString MQUtility::SendMessageToQueueNewPagosPlataTebca(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=250; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(incoming,"MONITOR",queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

    SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	set_tcp_header1.SendMessageToQueueWithTimeout(recv_0210,"MONITOR",queue_mgr_string);

	
	
	return retorno_0210;



}

RWCString MQUtility::SendMessageToQueueNewOrange(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformation() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformation());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	cout << "valor de retorno_0210 > " << retorno_0210 << endl;
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	return msg_return.Retorno_210_B24(retorno_0210,"0210",1);



	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}

RWCString MQUtility::SendMessageToQueueRetornoMsgBtransVarDelimiter1C(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformation() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformation());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	cout << "valor de retorno_0210 > " << retorno_0210 << endl;
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	
	return msg_return.Retorno_210_B24_1C(retorno_0210,"0210",1);



	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}



RWCString MQUtility::SendMessageToQueueNewVbv(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

  	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationVbv() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationVbv());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	cout << "valor de retorno_0210 > " << retorno_0210 << endl;


	if( retorno_0210.length() == 0)
	{
		retorno_0210 = "12345";
	}
	else
	{
		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
		retorno_0210 = "00"+retorno_0210;
	
	 
		retorno_0210 = msg_return.SetBtransFormatFromB24FormaVbv(retorno_0210,"0210",0,"base24");
	}

	return retorno_0210;

	/////////////////////////////////////////////////////////////////////////////////////////


}



RWCString MQUtility::SendMessageToQueueNewAVS(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	cout << endl;
	cout << "Valor de llave :" << response_to_get_011_037 << endl;
	cout << endl;
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationAVS() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationAVS());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
	RWCString test_varios_msg = "";



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	cout << "valor de retorno_0210 > " << retorno_0210 << endl;
	

	if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(12,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",1,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",1,"base24");

	
		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}


	return test_varios_msg;






}



RWCString MQUtility::SendMessageToQueueNewAVSAndVBV(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	cout << endl;
	cout << "Valor de llave :" << response_to_get_011_037 << endl;
	cout << endl;
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

  
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationAVS() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationAVS());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
	RWCString test_varios_msg = "";



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	cout << "valor de retorno_0210 > " << retorno_0210 << endl;
	

	if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(12,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",1,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format(retorno_0210,"0210",1,"base24");

	
		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}


	return test_varios_msg;






}

RWCString MQUtility::SendMessageToQueueNewAVS1C(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	cout << endl;
	cout << "Valor de llave :" << response_to_get_011_037 << endl;
	cout << endl;
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationAVS() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationAVS());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
	RWCString test_varios_msg = "";



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	cout << "valor de retorno_0210 > " << retorno_0210 << endl;
	

	if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(12,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format1C("00"+retorno_0210,"0210",1,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format1C("00"+retorno_0210,"0210",1,"base24");

		//cout << "Valor de retorno_btrans_format " << test_varios_msg << endl;

		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}




//	strcpy(recv_0210, retorno_0210);

//	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
///	retorno_0210 = "00"+retorno_0210;
	return test_varios_msg;



	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}

RWCString MQUtility::SendMessageToQueueNewVBV1C(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	cout << endl;
	cout << "Valor de llave :" << response_to_get_011_037 << endl;
	cout << endl;
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationAVS() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationAVS());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
	RWCString test_varios_msg = "";



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	cout << "valor de retorno_0210 > " << retorno_0210 << endl;
	

	if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(12,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format1C(retorno_0210,"0210",1,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format1C(retorno_0210,"0210",1,"base24");


		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}



	return test_varios_msg;



	/////////////////////////////////////////////////////////////////////////////////////////



}


RWCString MQUtility::SendMessageToQueueNewATHDebito(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	//cout << endl;
	//cout << "Valor de mensaje para procesar de debito >:" << incoming << endl;
//	cout << endl;

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	
	
	//cout << endl;
	//cout << "Valor de varios campos >:" << response_to_get_011_037 << endl;
	//cout << endl;
	
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationATHDebito() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationATHDebito());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
    RWCString test_varios_msg = "";

  
	//cout << "valor de  recv_queue_string " <<  recv_queue_string << endl;
	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	//cout << "Valor de retorno_iso " << retorno_0210 << endl;

    if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(14,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format(retorno_0210,"0210",1,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",1,"base24");

	//	cout << "Valor de retorno_btrans_format " << test_varios_msg << endl;

		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}
	
	//retorno_0210 = "00"+retorno_0210;
	//return msg_return.Retorno_210_B24_ATH(retorno_0210,"0210",1);

	return test_varios_msg;

	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}



RWCString MQUtility::SendMessageToQueueNewATHDebito(RWCString incoming, char *send_queue_input, char *recv_queue, char *sql_queue, char *queue_mgr_input, int debugSB)
{

	//cout << endl;
	//cout << "Valor de mensaje para procesar de debito >:" << incoming << endl;
//	cout << endl;

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	
	
	//cout << endl;
	//cout << "Valor de varios campos >:" << response_to_get_011_037 << endl;
	//cout << endl;
	
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

 /*  
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationATHDebito() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationATHDebito());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);

*/

 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
    RWCString test_varios_msg = "";

  
	//cout << "valor de  recv_queue_string " <<  recv_queue_string << endl;
	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue,queue_mgr);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue,queue_mgr);

	//cout << "Valor de retorno_iso " << retorno_0210 << endl;

    if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(14,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format(retorno_0210,"0210",debugSB,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",debugSB,"base24");

	//	cout << "Valor de retorno_btrans_format " << test_varios_msg << endl;

		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue,queue_mgr);
	}
	
	//retorno_0210 = "00"+retorno_0210;
	//return msg_return.Retorno_210_B24_ATH(retorno_0210,"0210",1);

	return test_varios_msg;

	/////////////////////////////////////////////////////////////////////////////////////////


}


RWCString MQUtility::SendMessageToQueueNewATHDebito(RWCString incoming ,char *send_queue_input, char *recv_queue_string,char *sql_queue_string , char *queue_mgr_input)
{

	//cout << endl;
	//cout << "Valor de mensaje para procesar de debito >:" << incoming << endl;
//	cout << endl;

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	
	
	//cout << endl;
	//cout << "Valor de varios campos >:" << response_to_get_011_037 << endl;
	//cout << endl;
	
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");
/*
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationATHDebito() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationATHDebito());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/


 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
    RWCString test_varios_msg = "";

  
	//cout << "valor de  recv_queue_string " <<  recv_queue_string << endl;
	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);

	//cout << "Valor de retorno_iso " << retorno_0210 << endl;

    if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(14,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format(retorno_0210,"0210",1,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",1,"base24");

	//	cout << "Valor de retorno_btrans_format " << test_varios_msg << endl;

		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}
	
	//retorno_0210 = "00"+retorno_0210;
	//return msg_return.Retorno_210_B24_ATH(retorno_0210,"0210",1);

	return test_varios_msg;

	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}

RWCString MQUtility::SendMessageToQueueNewVbv430(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	//cout << endl;
	//cout << "Valor de mensaje para procesar de debito >:" << incoming << endl;
//	cout << endl;

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	
	
	//cout << endl;
	//cout << "Valor de varios campos >:" << response_to_get_011_037 << endl;
	//cout << endl;
	
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationVbv() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationVbv());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
    RWCString test_varios_msg = "";

  
	//cout << "valor de  recv_queue_string " <<  recv_queue_string << endl;
	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);


    if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(14,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format(retorno_0210,"0210",1,"base24");
		}
		else
		test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",1,"base24");


		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}
	

	return test_varios_msg;

	/////////////////////////////////////////////////////////////////////////////////////////




}



void MQUtility::LogTrans(RWCString incoming)
{

	struct _timeb tstruct;
  
	RWTime a;
	RWCString	fname = "LogTrans.log";
	RWCString	m_fname = fname;
	ofstream fp;

	// Decimal Conversion
	// Variable declaration
	 _ftime( &tstruct );
	int test_time = tstruct.millitm;
	//RWCString re_test = "";
	char buffer_mil[20] = {""};
						
	_itoa( test_time, buffer_mil, 10 );
					;
		//Converting long to string

		// File Creation and Information Insertion
		char buf[16],nbuf[64];
		time_t ltime;
		time(&ltime);
		struct tm *today = localtime(&ltime);
		strftime(buf,sizeof(buf),"%m%d%Y",today);
		sprintf(nbuf,"%s_%s",buf,m_fname);
		RWCString newname = nbuf;

		fp.open(newname, ios::app);
//		fp << counter << "," << pan << "," << respan[0] << "," << buffer1 << "," << buffer3 << "," << sprocess << "," << time_one << "," << time_two << endl;
		fp << a << ":" <<buffer_mil << " " << incoming << endl;

		fp.close();	
return;
}



RWCString MQUtility::SendMessageToQueueNewATHVicana(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{
	RWCString response_to_get_011_037;
	RWCString response_to_get_pan ="";
	RWCString response_to_get_track2 = "";
	RWCString response_to_get_field11 = "";
	RWCString response_to_get_field37 = "";
	RWCString track2_35,field_35_01,field_35_02;
	
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
//	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");

	response_to_get_pan		= retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",2);
	response_to_get_track2	= retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",35);
	response_to_get_field11 = retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",11);
	response_to_get_field37 = retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",37);

//	cout << "valor de response_to_get_pan     " << response_to_get_pan << endl;
//	cout << "valor de response_to_get_track2  " << response_to_get_track2 << endl;
//	cout << "valor de response_to_get_field11 " << response_to_get_field11 << endl;
//	cout << "valor de response_to_get_field37 " << response_to_get_field37 << endl;
	
	//	RWCString response_to_get_011_037;
//	MQUtility retorno_field_125;
//	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
//	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0220", 0 , "base24");
	
/*	
	cout << endl;
	cout << "Valor de varios campos >:" << response_to_get_011_037 << endl;
	cout << endl;	
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/
	RWCTokenizer next1(response_to_get_track2);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	 // last_six = field_35_01;

	   if(response_to_get_track2.length() == 0)
		  last_six = response_to_get_pan;
		else
	  last_six = field_35_01;

//	  cout << "Valor de last_six " << last_six << endl;

	   memcpy(md.MsgId,response_to_get_field11+response_to_get_field37+last_six(last_six.length()-6,6),24);

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationATHVicana() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationATHVicana());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
    RWCString test_varios_msg = "";

  
	//cout << "valor de  recv_queue_string " <<  recv_queue_string << endl;
	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	//RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
	//	  recv_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(response_to_get_field11+response_to_get_field37+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	

//	cout << "Valor de retorno_iso " << retorno_0210 << endl;
//	LogTrans(retorno_0210);

    if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(14,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format(retorno_0210,"0210",0,"base24");
		}
		else
	
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",0,"base24");

	
		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}
	
	//retorno_0210 = "00"+retorno_0210;
	//return msg_return.Retorno_210_B24_ATH(retorno_0210,"0210",1);

	return test_varios_msg;

	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}


RWCString MQUtility::SendMessageToQueueNewATHVicana230(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{
	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se forma key para buscar mensahe formado por 11 y 37**//		
	response_to_get_011_037 = retorno_field_125.GetIso8583FieldB24(incoming,"0220",0,"base24",11,37,0);
	

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
	  md.Expiry=200; /* cambiar msg descr */ 
	  memcpy(md.MsgId,response_to_get_011_037,24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationATHVicana() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationATHVicana());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
    RWCString test_varios_msg = "";

  
	//cout << "valor de  recv_queue_string " <<  recv_queue_string << endl;
	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

    RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(response_to_get_011_037,recv_queue_string,queue_mgr_string);   

	//response_to_get_011_037
	//cout << "Valor de retorno_iso " << retorno_0210 << endl;
//	LogTrans(retorno_0210);

    if ( retorno_0210.length() > 100) 
	{
		if(retorno_0210(14,4) == "0430")
		{
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format(retorno_0210,"0210",0,"base24");
		}
		else
	
			test_varios_msg = set_tcp_header1.SetBtransFormatFromB24Format("00"+retorno_0210,"0210",0,"base24");

		//cout << "Valor de retorno_btrans_format " << test_varios_msg << endl;

		strcpy(recv_0210, retorno_0210);

		SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	}
	
	//retorno_0210 = "00"+retorno_0210;
	//return msg_return.Retorno_210_B24_ATH(retorno_0210,"0210",1);

	return test_varios_msg;

	/////////////////////////////////////////////////////////////////////////////////////////



}

void MQUtility::SendMessageToQueueNewATHDebito0430(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

   /*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationATHDebito() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationATHDebito());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	//recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);



 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	return msg_return.Retorno_210_B24_ATH(retorno_0210,"0210",1);

*/

	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}



RWCString MQUtility::SendMessageToQueueNewVisaThreeMsgId(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/
   
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationVisa() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationVisa());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	

 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	return retorno_0210 ;


	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}



RWCString MQUtility::SendMessageToQueueNewPosVirtualSD(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;
/*
	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
*/
 /*  
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformation() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformation());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);

*/

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};

	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPosVirtual());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);

 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};



	//////////////////////////////////////////////////////////////////////////////////////////

	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	return msg_return.Retorno_210_B24(retorno_0210,"0210",1);



	/////////////////////////////////////////////////////////////////////////////////////////


/*
	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	//SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
	return retorno_0210;

*/

}




void MQUtility::SendMessageToQueueNewPagosPlataOnly(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	
	//cout << "valor de incoming dentro > :" << incoming << endl;
	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125("00"+incoming, "0210", 0 , "base24");

	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl;
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}


	strcpy(send_queue_input,recv_queue_rw);
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
*/

//	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

//	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
//		  recv_queue_string,queue_mgr_string);
	
//	strcpy(recv_0210, retorno_0210);

//	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
//	return retorno_0210;



}

void MQUtility::SendMessageToQueueNewPagosPlataOnlyPagos(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	//strcpy(send_queue_input,recv_queue_rw);
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
*/

//	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

//	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
//		  recv_queue_string,queue_mgr_string);
	
//	strcpy(recv_0210, retorno_0210);

//	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
//	return retorno_0210;



}

void MQUtility::SendMessageToQueueNewPagosPlataOnlyPagos0420(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	//strcpy(send_queue_input,recv_queue_rw);
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString msg_0420 = incoming(2,incoming.length()-2);
   
   strcpy(buffer,msg_0420);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
*/

//	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

//	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
//		  recv_queue_string,queue_mgr_string);
	
//	strcpy(recv_0210, retorno_0210);

//	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
//	return retorno_0210;



}



void MQUtility::SendMessageToQueueNewVbv0420(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	//strcpy(send_queue_input,recv_queue_rw);
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString msg_0420 = incoming(2,incoming.length()-2);

   strcpy(buffer,msg_0420);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}


void MQUtility::SendMessageToQueueNewAvs0420(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	//strcpy(send_queue_input,recv_queue_rw);
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString msg_0420 = incoming;

   //cout << "Valor de msg_0420 " << msg_0420 << endl;
   strcpy(buffer,msg_0420);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}


void MQUtility::SendMessageToQueueNewPagosPlataOnlyPagos0420NoTimeoutAvs(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

    cout << "Valor de incoming > " << incoming << endl;
	
	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	//strcpy(send_queue_input,recv_queue_rw);
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString msg_0420 = incoming;

   strcpy(buffer,msg_0420);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	 // md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
*/

//	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

//	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
//		  recv_queue_string,queue_mgr_string);
	
//	strcpy(recv_0210, retorno_0210);

//	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
//	return retorno_0210;



}



void MQUtility::SendMessageToQueueNewPagosPlataOnlyPagos0420NoTimeout(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

    cout << "Valor de incoming > " << incoming << endl;
	
	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	//strcpy(send_queue_input,recv_queue_rw);
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString msg_0420 = incoming(2,incoming.length()-2);

   strcpy(buffer,msg_0420);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	 // md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

/*
   	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformationPagos() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPagosPlata());
	RWCString token;
	RWCString send_queue,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
		
			recv_queue = token; 
		}
		if (count == 2)
		{
		
			sql_queue = token; 
		}

		if (count == 3)
		{
		
			queue_mgr = token; 
		}
		if (count == 4)
		{
		
			header = token; 
		}
		if (count == 5)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};
*/

//	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

//	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
//		  recv_queue_string,queue_mgr_string);
	
//	strcpy(recv_0210, retorno_0210);

//	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	
//	return retorno_0210;



}



RWCString MQUtility::SendMessageToQueueNewCallCenterVen(RWCString incoming, char *send_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	
	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
/*
       cout << "Valor de field_35_01 > " << field_35_01 << endl;
	   cout << "Valor de field_35_01.len > " << field_35_01.length() << endl;
	   cout << "Valor de llave > " << system_trace_11+retrieval_037+field_35_01 << endl;
	   RWCString llave = system_trace_11+retrieval_037+field_35_01;
	   cout << "Valor de llave.len > " << llave.length() << endl;
	   */
	  //char  MsgId[48];
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");


   	MQUtility input_to_queue;
	input_to_queue.GetTheIniFileInformationPosVirtualVen() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformationPosVirtualVen());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	

	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	




 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueueCallCenterVen(system_trace_11+retrieval_037+last_six(last_six.length()-6,6),
		  recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;
	return msg_return.Retorno_210_B24(retorno_0210,"0210",1);
	//return retorno_0210;



}



void MQUtility::SendMessageToQueueHeaderVisa(RWCString incoming, char *recv_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//	
	//cout << "valor de incoming > " << incoming << endl;
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
//	cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	/*
	RWCString system_trace_11,retrieval_037,recv_queue_rw;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			retrieval_037= token2;
		}
		if (count_token == 2)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/

	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}


	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}

    //cout << "Valor de recv_queue_rw > " << recv_queue_rw << endl;

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString  buffer2 = incoming(2,incoming.length()-2);
   //strc
   strcpy(buffer,buffer2);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, recv_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );

       
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=450; /* cambiar msg descr */ 
	  //RWCString last_six = field_35_01;
	  memcpy(md.MsgId,system_trace_11+retrieval_037,18);

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}

RWCString MQUtility::Retorno_Msg_Generic_Field125(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				if((j+1) == 125)
					retorno_125 = msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 53)
					{
						msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						if(debug == 1)

							ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
						response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						response_0210_generic_from_iso +=delimiter;
					}
					else
					{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				}
			
			}
		}
		
	}

  	return retorno_125;

}


void MQUtility::Proccess_Message_Postilion( RWCString incoming_msg, char *sql_queue, char *queue_mgr)
{

	MQUtility get_firts_char_bitmap;
	MQUtility send_generic_200;
		

	strcpy(recv_queue,send_generic_200.Retorno_Msg_Generic_Field125(incoming_msg, "0210", 1 , "base24"));

	send_generic_200.SendMessageToQueueHeaderPagos(incoming_msg,recv_queue,queue_mgr);



}

void MQUtility::Proccess_Message_ATH( RWCString incoming_msg, char *sql_queue,char *recv_queue, char *queue_mgr)
{

	MQUtility get_firts_char_bitmap;
	MQUtility send_generic_200;
		

	//strcpy(recv_queue,send_generic_200.Retorno_Msg_Generic_Field125(incoming_msg, "0210", 1 , "base24"));

	send_generic_200.SendMessageToQueueHeaderPagos(incoming_msg,recv_queue,queue_mgr);

	//send_generic_200.SendMessageToQueueSql(incoming_msg(2,incoming_msg.length()-2),
	//	sql_queue,queue_mgr);


}


void MQUtility::Proccess_Message_ATH230( RWCString incoming_msg, char *sql_queue,char *recv_queue, char *queue_mgr)
{

	MQUtility get_firts_char_bitmap;
	MQUtility send_generic_200;
		

	//strcpy(recv_queue,send_generic_200.Retorno_Msg_Generic_Field125(incoming_msg, "0210", 1 , "base24"));

	send_generic_200.SendMessageToQueueHeader230(incoming_msg,recv_queue,queue_mgr);

	//send_generic_200.SendMessageToQueueSql(incoming_msg(2,incoming_msg.length()-2),
	//	sql_queue,queue_mgr);


}


void MQUtility::Proccess_Message_PostilionTwoMsId( RWCString incoming_msg, char *sql_queue, char *queue_mgr)
{

	MQUtility get_firts_char_bitmap;
	MQUtility send_generic_200;
		

	strcpy(recv_queue,send_generic_200.Retorno_Msg_Generic_Field125(incoming_msg, "0210", 1 , "base24"));

	send_generic_200.SendMessageToQueueHeader(incoming_msg,recv_queue,queue_mgr);

	//send_generic_200.SendMessageToQueueSql(incoming_msg(2,incoming_msg.length()-2),
	//	sql_queue,queue_mgr);


}


void MQUtility::SendMessageToQueueHeader(RWCString incoming, char *recv_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	/*
	RWCString system_trace_11,retrieval_037,recv_queue_rw;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			retrieval_037= token2;
		}
		if (count_token == 2)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/

	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}


	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}

    //cout << "Valor de recv_queue_rw > " << recv_queue_rw << endl;

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString  buffer2 = incoming(2,incoming.length()-2);
   //strc
   strcpy(buffer,buffer2);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, recv_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );

       
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=300; /* cambiar msg descr */ 
	  //RWCString last_six = field_35_01;
	  memcpy(md.MsgId,system_trace_11+retrieval_037,18);

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}

void MQUtility::SendMessageToQueueHeaderNewThreeParameters(RWCString incoming, char *recv_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	/*
	RWCString system_trace_11,retrieval_037,recv_queue_rw;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			retrieval_037= token2;
		}
		if (count_token == 2)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/

	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}


	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}

    //cout << "Valor de recv_queue_rw > " << recv_queue_rw << endl;

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString  buffer2 = incoming(2,incoming.length()-2);
   //strc
   strcpy(buffer,buffer2);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, recv_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );

       
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=300; /* cambiar msg descr */ 
	  //RWCString last_six = field_35_01;
	 // memcpy(md.MsgId,system_trace_11+retrieval_037,18);

	   last_six = field_35_01;
	  //cout << "Valor de last_six > " << last_six(last_six.length()-6,6) << endl;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);
	

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}


void MQUtility::SendMessageToQueueHeaderWithModuleName(RWCString incoming, char *recv_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
//	cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	/*
	RWCString system_trace_11,retrieval_037,recv_queue_rw;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			retrieval_037= token2;
		}
		if (count_token == 2)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/

	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}


	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}

    //cout << "Valor de recv_queue_rw > " << recv_queue_rw << endl;

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString  buffer2 = incoming(2,incoming.length()-2);
   //strc
   strcpy(buffer,buffer2);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, recv_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );

       
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=400; /* cambiar msg descr */ 
	  //RWCString last_six = field_35_01;
	  memcpy(md.MsgId,recv_queue_rw,12);

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}


void MQUtility::SendMessageToQueueHeaderPagos(RWCString incoming, char *recv_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");
	int count_token=0;
	//cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	/*
	RWCString system_trace_11,retrieval_037,recv_queue_rw;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			retrieval_037= token2;
		}
		if (count_token == 2)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/

	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}


	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}

    //cout << "Valor de recv_queue_rw > " << recv_queue_rw << endl;

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString  buffer2 = incoming(2,incoming.length()-2);
   //strc
   strcpy(buffer,buffer2);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, recv_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );

       
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  RWCString last_six = field_35_01;
	  memcpy(md.MsgId,system_trace_11+retrieval_037+last_six(last_six.length()-6,6),24);

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}

RWCString MQUtility::GetIso8583FieldB24ForKioscos(RWCString incoming , char *msg_type, 
										          int debug, RWCString application,int input_field)
{


	RWCString  hex_bit = "";
	RWCString  field90 = "";
	RWCString  output_field = "";
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;   iso_field_length[19] = 3;	
	iso_field_length[22] = 3;   iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 32; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 8;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]=msg_for_processing(next_field,var_field);
			
				if((j+1) == 54)
				iso_field_value[54]=msg_for_processing(next_field,var_field);
			


				if((j+1) == 59)
					iso_field_value[59]=msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]=msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					iso_field_value[63]=msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]=msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);

				if((j+1) == 127)
					iso_field_value[127]= msg_for_processing(next_field,var_field);
			
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]= msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					iso_field_value[35]= msg_for_processing(next_field,var_field);

	
				
				
				}
				
		
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
		
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(input_field == 11)
					{
						if(j+1 == 11)
						{

							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

							iso_field_value[11]=  msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							//output_field = iso_field_value[input_field];
				
						}
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						//expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
	
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 30)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[30]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					//	iso_field_value[input_field] = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//output_field = iso_field_value[input_field];
				
					}

					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					//	iso_field_value[input_field] = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						iso_field_value[38]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//output_field = iso_field_value[input_field];
				
					}

					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{

					
						iso_field_value[52]=RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8); 
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8));
						
					}
					if(input_field == 90)
					{
						if(j+1 == 90)
						{

							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
							iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							///output_field = iso_field_value[input_field];
						}
					}
				}
			
			}
		}
		
	}


	if (strcmp(msg_type,"0200") == 0)
	
		response_0210_generic_from_iso = "0200,";


	if (strcmp(msg_type,"0420") == 0)
	
		response_0210_generic_from_iso = "0420,";

	
	return 	iso_field_value[input_field];

}


RWCString MQUtility::SendMessageToQueueapitalGWithParameters(RWCString incoming, char *send_queue_input, char *queue_mgr_input ,char *recv_queue_input, char *sql_queue_input)
{


	RWCString response_to_get_011_037;
	RWCString response_to_get_pan ="";
	RWCString response_to_get_track2 = "";
	RWCString response_to_get_field11 = "";
	RWCString response_to_get_field37 = "";
	RWCString track2_35,field_35_01,field_35_02;
	
	MQUtility retorno_field_125;
	RWCString last_six = "";
	//**Se toma el campo 125 y se copia al recv_queue**//		
//	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0210", 0 , "base24");

	response_to_get_pan		= retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",2);
	response_to_get_track2	= retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",35);
	response_to_get_field11 = retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",11);
	response_to_get_field37 = retorno_field_125.GetIso8583FieldB24ForKioscos(incoming,"0200",0,"base24",37);
	
//	cout << " Valor de response_to_get_pan     " << response_to_get_pan << endl;
//	cout << " Valor de response_to_get_track2  " << response_to_get_track2 << endl;

//	cout << " Valor de response_to_get_field11 " << response_to_get_field11 << endl;
//	cout << " Valor de response_to_get_field37 " << response_to_get_field37 << endl;


	//**Se toma el campo 125 y se copia al recv_queue**//
	/*
	response_to_get_011_037 = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");
	int count_token=0;
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/
	
	RWCTokenizer next1(response_to_get_track2);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}


   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[2024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */

   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, send_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
	  md.Expiry=150; /* cambiar msg descr */ 
	  if(response_to_get_track2.length() == 0)
		  last_six = response_to_get_pan;
		else
	  last_six = field_35_01;

		
	   memcpy(md.MsgId,response_to_get_field11+response_to_get_field37+last_six(last_six.length()-6,6),24);
		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[2024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_input,queue_mgr_input);

	RWCString retorno_0210 = set_tcp_header1.GetMsgFromSendQueuePagos(response_to_get_field11+response_to_get_field37+last_six(last_six.length()-6,6),
		  recv_queue_input,queue_mgr_input);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_input,queue_mgr_input);
	
	
	return retorno_0210;



}


void MQUtility::SendMessageToQueueHeader230(RWCString incoming, char *recv_queue_input, char *queue_mgr_input)
{

	RWCString response_to_get_011_037;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	response_to_get_011_037 = retorno_field_125.GetIso8583FieldB24(incoming,"0230",0,"base24",11,37,0);
	int count_token=0;
//	cout << "Valor de response_to_get_011_037 > " << response_to_get_011_037 << endl; 
	/*
	RWCTokenizer next2(response_to_get_011_037);
	RWCString token2;
	*/


	  /*
	RWCString system_trace_11,retrieval_037,recv_queue_rw;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			retrieval_037= token2;
		}
		if (count_token == 2)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}
	*/
/*
	RWCString system_trace_11,track2_35,retrieval_037,recv_queue_rw,field_35_01,field_35_02;
	while(!(token2=next2(",")).isNull())
	{
		if (count_token == 0)
		{
			system_trace_11 = token2;
		}
		if (count_token == 1)
		{
			track2_35 = token2;
		}
		if (count_token == 2)
		{
			retrieval_037= token2;
		}
		if (count_token == 3)
		{
			recv_queue_rw = token2;
		}

		count_token++;
	}


	RWCTokenizer next1(track2_35);
	RWCString token1;
	int counter_token=0;				
	//This extract the BIN from the Message//
	while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
	{	
		if (counter_token == 0)
		{
			field_35_01 = token1; 
		}			
		if (counter_token == 1)
		{
			field_35_02 = token1; 
		}			
		counter_token++;
	}
*/
    //cout << "Valor de recv_queue_rw > " << recv_queue_rw << endl;

   /*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];            /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");
   RWCString  buffer2 = incoming(2,incoming.length()-2);
   //strc
   strcpy(buffer,buffer2);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr_input);
  
   
   
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, recv_queue_input, (size_t)MQ_Q_NAME_LENGTH);
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );

       
	   /* jnivar star */
	      //strcpy(md.ReplyToQ,"QL_DIST"); /* cambiar msg descr */ 
	  md.Expiry=200; /* cambiar msg descr */ 
	  //RWCString last_six = field_35_01;
	  memcpy(md.MsgId,response_to_get_011_037,24);

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;
 

   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");



}

int MQUtility::SendMessageToQueueSql(RWCString incoming, char *sql_queue, char *queue_mgr)
{

/*   Declare MQI structures needed                                */
   MQOD     od = {MQOD_DEFAULT};    /* Object Descriptor             */
 

   MQMD     md = {MQMD_DEFAULT};    /* Message Descriptor            */

 
   MQPMO   pmo = {MQPMO_DEFAULT};   /* put message options           */
      /** note, sample uses defaults where it can **/

   MQHCONN  Hcon;                   /* connection handle             */
   MQHOBJ   Hobj;                   /* object handle                 */
   MQLONG   O_options;              /* MQOPEN options                */
   MQLONG   C_options;              /* MQCLOSE options               */
   MQLONG   CompCode;               /* completion code               */
   MQLONG   OpenCode;               /* MQOPEN completion code        */
   MQLONG   Reason;                 /* reason code                   */
   MQLONG   CReason;                /* reason code for MQCONN        */
   MQLONG   messlen;                /* message length                */
   char     buffer[1024];           /* message buffer                */
   char     QMName[50];             /* queue manager name            */
   strcpy(buffer, "");

   strcpy(buffer,incoming);
   /******************************************************************/
   /*                                                                */
   /*   Connect to queue manager                                     */
   /*                                                                */
   /******************************************************************/
   QMName[0] = 0;    /* default */
   strcpy(QMName, queue_mgr);
  
   
   //printf("Manager code %s\n", QMName);
  
   MQCONN(QMName,                  /* queue manager                  */
          &Hcon,                   /* connection handle              */
          &CompCode,               /* completion code                */
          &CReason);               /* reason code                    */

   /* report reason and stop if it failed     */
   if (CompCode == MQCC_FAILED)
   {
     printf("MQCONN ended with reason code %ld\n", CReason);
     exit( (int)CReason );
   }

   /******************************************************************/
   /*                                                                */
   /*   Use parameter as the name of the target queue                */
   /*                                                                */
   /******************************************************************/
   //strncpy(od.ObjectName, argv[1], (size_t)MQ_Q_NAME_LENGTH);
  strncpy(od.ObjectName, sql_queue, (size_t)MQ_Q_NAME_LENGTH);
  
  
  // printf("target queue is %s\n", od.ObjectName);

   /******************************************************************/
   /*                                                                */
   /*   Open the target message queue for output                     */
   /*                                                                */
   /******************************************************************/
   O_options = MQOO_OUTPUT           /* open queue for output        */
           + MQOO_FAIL_IF_QUIESCING; /* but not if MQM stopping      */
   MQOPEN(Hcon,                      /* connection handle            */
          &od,                       /* object descriptor for queue  */
          O_options,                 /* open options                 */
          &Hobj,                     /* object handle                */
          &OpenCode,                 /* MQOPEN completion code       */
          &Reason);                  /* reason code                  */

   /* report reason, if any; stop if failed      */
   if (Reason != MQRC_NONE)
   {
     printf("MQOPEN ended with reason code %ld\n", Reason);
   }

   if (OpenCode == MQCC_FAILED)
   {
     printf("unable to open queue for output\n");
   }

 
 
   
   
   
   /******************************************************************/
   /*                                                                */
   /*   Read lines from the file and put them to the message queue   */
   /*   Loop until null line or end of file, or there is a failure   */
   /*                                                                */
   /******************************************************************/
   CompCode = OpenCode;        /* use MQOPEN result for initial test */
  // fp = stdin;

   memcpy(md.Format,           /* character string format            */
          MQFMT_STRING, (size_t)MQ_FORMAT_LENGTH);
  
   
  /******************************************************************/
   /* Use these options when connecting to Queue Managers that also  */
   /* support them, see the Application Programming Reference for    */
   /* details.                                                       */
   /* These options cause the MsgId and CorrelId to be replaced, so  */
   /* that there is no need to reset them before each MQPUT          */ 
   /******************************************************************/
   /* pmo.Options |= MQPMO_NEW_MSG_ID;                               */
   /* pmo.Options |= MQPMO_NEW_CORREL_ID;                            */
 
  
       messlen = strlen(buffer);       /* length without null        */
 
     /****************************************************************/
     /*                                                              */
     /*   Put each buffer to the message queue                       */
     /*                                                              */
     /****************************************************************/
     if (messlen > 0)
     {
       /**************************************************************/
       /* The following two statements are not required if the       */
       /* MQPMO_NEW_MSG_ID and MQPMO_NEW _CORREL_ID options are used */
       /**************************************************************/
       memcpy(md.MsgId,           /* reset MsgId to get a new one    */
              MQMI_NONE, sizeof(md.MsgId) );
//       md.Expiry=500; /* cambiar msg descr */ 
 		  

	   /* jnivar end */
	   memcpy(md.CorrelId,        /* reset CorrelId to get a new one */
              MQCI_NONE, sizeof(md.CorrelId) );

       MQPUT(Hcon,                /* connection handle               */
             Hobj,                /* object handle                   */
             &md,                 /* message descriptor              */
             &pmo,                /* default options (datagram)      */
             messlen,             /* message length                  */
             buffer,              /* message buffer                  */
             &CompCode,           /* completion code                 */
             &Reason);            /* reason code                     */

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     

       /* report reason, if any */
       if (Reason != MQRC_NONE)
       {
         printf("MQPUT ended with reason code %ld\n", Reason);
       }
     
	 
	 
	 
	 }
     else   /* satisfy end condition when empty line is read */
       CompCode = MQCC_FAILED;


   /******************************************************************/
   /*                                                                */
   /*   Close the target queue (if it was opened)                    */
   /*                                                                */
   /******************************************************************/
   if (OpenCode != MQCC_FAILED)
   {
     C_options = 0;                  /* no close options             */
     MQCLOSE(Hcon,                   /* connection handle            */
             &Hobj,                  /* object handle                */
             C_options,
             &CompCode,              /* completion code              */
             &Reason);               /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQCLOSE ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /*   Disconnect from MQM if not already connected                 */
   /*                                                                */
   /******************************************************************/
   if (CReason != MQRC_ALREADY_CONNECTED)
   {
     MQDISC(&Hcon,                   /* connection handle            */
            &CompCode,               /* completion code              */
            &Reason);                /* reason code                  */

     /* report reason, if any     */
     if (Reason != MQRC_NONE)
     {
       printf("MQDISC ended with reason code %ld\n", Reason);
     }
   }

   /******************************************************************/
   /*                                                                */
   /* END OF AMQSPUT0                                                */
   /*                                                                */
   /******************************************************************/
   //printf("Sample AMQSPUT0 end\n");

 	
	
	
	
	return 1;
}


RWCString  MQUtility::GetTheIniFileInformation()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\SERVER_BSOURCES_WEB_THREAD.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}

RWCString  MQUtility::GetTheIniFileInformationAVS()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\AVS\\SERVER_BSOURCES_AVS.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}

RWCString  MQUtility::GetTheIniFileInformationATHDebito()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\ATH\\SERVER_BSOURCES_ATH_DEBITO.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}

RWCString  MQUtility::GetTheIniFileInformationVbv()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\VBV\\SERVER_BSOURCES_VBV.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}

RWCString  MQUtility::GetTheIniFileInformationATHVicana()
{
	const static char* appName = "SERVER_INPUT_VICANA";
	const static char* appAddr = "\\BtransGeneric\\INI\\VICANA\\SERVER_INPUT_VICANA.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}


RWCString  MQUtility::GetTheIniFileInformationVisa()
{
	const static char* appName = "VISAF_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\SERVER_VISAF_THREAD.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}


RWCString  MQUtility::GetTheIniFileInformationPosVirtual()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\SERVER_BSOURCES_CALL_CENTER_SD.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}


RWCString  MQUtility::GetTheIniFileInformationPosVirtualVen()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\SERVER_BSOURCES_CALL_CENTER_VEN.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}

RWCString  MQUtility::GetTheIniFileInformationAth()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\SERVER_BSOURCES_ATH_THREAD.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}

	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_eps+comma+send_queue_amex+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}

RWCString  MQUtility::GetTheIniFileInformationPagos()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\SERVER_BSOURCES_PAGOS_THREAD.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}
/*
	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}
*/
	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}

RWCString  MQUtility::GetTheIniFileInformationPagosPlata()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\PLATA\\SERVER_BSOURCES_PAGOS_THREAD_PLATA.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}
/*
	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}
*/
	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}


RWCString  MQUtility::GetTheIniFileInformationPagosPlata2()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\PLATA\\SERVER_BSOURCES_PAGOS_THREAD_PLATA.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_alterno","",send_queue_alterno,sizeof(send_queue_alterno),appAddr);
	if (strcmp(send_queue_alterno,"") == 0)
	{
		cout<< send_queue_alterno<<endl;
		cout << "Problem Opening Initialization File to get send_queue_alterno"<< endl;
	}
	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+send_queue_alterno+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}



RWCString  MQUtility::GetTheIniFileInformationPagosLotes()
{
	const static char* appName = "BSOURCES_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\PLATA\\SERVER_BSOURCES_PAGOS_THREAD_LOTES.INI";
	


	GetPrivateProfileString(appName,"send_queue","",send_queue,sizeof(send_queue),appAddr);
	if (strcmp(send_queue,"") == 0)
	{
		cout<< send_queue<<endl;
		cout << "Problem Opening Initialization File to get send_queue"<< endl;
	}
/*
	GetPrivateProfileString(appName,"send_queue_eps","",send_queue_eps,sizeof(send_queue_eps),appAddr);
	if (strcmp(send_queue_eps,"") == 0)
	{
		cout<< send_queue_eps<<endl;
		cout << "Problem Opening Initialization File to get send_queue_eps"<< endl;
	}

	GetPrivateProfileString(appName,"send_queue_amex","",send_queue_amex,sizeof(send_queue_amex),appAddr);
	if (strcmp(send_queue_amex,"") == 0)
	{
		cout<< send_queue_amex<<endl;
		cout << "Problem Opening Initialization File to get send_queue_amex"<< endl;
	}
*/
	
	GetPrivateProfileString(appName,"recv_queue","",recv_queue,sizeof(recv_queue),appAddr);
	if (strcmp(recv_queue,"") == 0)
	{
		cout<< recv_queue<<endl;
		cout << "Problem Opening Initialization File to get recv_queue"<< endl;
	}

	GetPrivateProfileString(appName,"sql_queue","",sql_queue,sizeof(sql_queue),appAddr);
	if (strcmp(sql_queue,"") == 0)
	{
		cout<< sql_queue<<endl;
		cout << "Problem Opening Initialization File to get sql_queue"<< endl;
	}

	GetPrivateProfileString(appName,"header","",header_ini,sizeof(header_ini),appAddr);
	if (strcmp(header_ini,"") == 0)
	{
		cout<< header_ini<<endl;
		cout << "Problem Opening Initialization File to get header_ini"<< endl;
	}
	
	GetPrivateProfileString(appName,"application","",application,sizeof(application),appAddr);
	if (strcmp(application,"") == 0)
	{
		cout<< application<<endl;
		cout << "Problem Opening Initialization File to get application"<< endl;
	}

	GetPrivateProfileString(appName,"queue_mgr","",queue_mgr,sizeof(queue_mgr),appAddr);
	if (strcmp(queue_mgr,"") == 0)
	{
		cout<< queue_mgr<<endl;
		cout << "Problem Opening Initialization File to get queue_mgr"<< endl;
	}


	RWCString comma = ",";

	return send_queue+comma+recv_queue+comma
		   +sql_queue+comma+queue_mgr+comma+header_ini+comma+application;
	
	

}


RWCString MQUtility::setMapIsoPosTermFromGeneric( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
	
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}
		
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 15 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 19 ) 
				 || (atoi(field_number) == 22 )|| (atoi(field_number) == 23 ) || (atoi(field_number) == 24 )|| (atoi(field_number) == 25 ) 
				 || (atoi(field_number) == 26 )|| (atoi(field_number) == 28 )|| (atoi(field_number) == 30 ) || (atoi(field_number) == 40 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				/*
				if((atoi(field_number) < 0) || (!atoi(field_number) <= 125))
				{
					flag_true = 1;
						break;
				}
				*/
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
			
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
      }
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}

RWCString MQUtility::setMapIsoPosTermFromDelimiter1C( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
	RWCString char1c = '\x1C';
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(char1c)).isNull())
	{	
	
		F1 = token; 
	
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}
		
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 19 ) 
				 || (atoi(field_number) == 22 )|| (atoi(field_number) == 24 )|| (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				/*
				if((atoi(field_number) < 0) || (!atoi(field_number) <= 125))
				{
					flag_true = 1;
						break;
				}
				*/
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
			
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
      }
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::SetMapIsoDiscoverFromGeneric( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				/*
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 19 ) 
				 || (atoi(field_number) == 22 )|| (atoi(field_number) == 24 )|| (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}
				*/

				/*
				if((atoi(field_number) < 0) || (!atoi(field_number) <= 125))
				{
					flag_true = 1;
						break;
				}
				*/
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				flag_true = 1;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}





RWCString MQUtility::SetMapIsoDiscoverFrom1C( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	RWCString char1C = '\x1C';
		
	while(!(token=next(char1C)).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(char1C)).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				/*
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 19 ) 
				 || (atoi(field_number) == 22 )|| (atoi(field_number) == 24 )|| (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}
				*/

				/*
				if((atoi(field_number) < 0) || (!atoi(field_number) <= 125))
				{
					flag_true = 1;
						break;
				}
				*/
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				flag_true = 1;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}

/*
RWCString MQUtility::SetIso8583B24FromBtransFormat( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
	
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}
*/
RWCString MQUtility::SetMapIso8583B24FromGenericVar0420( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::SetMapIso8583B24FromGenericVar04201C( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::SetMapIso8583B24FromGenericVar0420ATHDebito( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}



RWCString MQUtility::SetIso8583B24FromBtransFormat( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) ||  (atoi(field_number) == 19 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ) || (atoi(field_number) == 26 ) || (atoi(field_number) == 50 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}

RWCString MQUtility::SetIso8583B24FromBtransFormat1993( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	RWCString delimiter = '\x1C';
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(delimiter)).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(delimiter)).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All1Version1993("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
		
				/*
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) ||  (atoi(field_number) == 19 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}
*/
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All1Version1993("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All1Version1993(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All1Version1993(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All1Version1993(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}



RWCString MQUtility::SetIso8583B24FromBtransFormatVBV( RWCString incoming, char *application, char *header_msg ,int debug)
{

	////cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) ||  (atoi(field_number) == 19 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 63))
			{
				
				

			RWTValVector<RWCString> iso_field_value(30,"");

			RWCString field63_RW=iso_field [atoi(field_number)];
	
			RWCString token;
			RWCTokenizer next(field63_RW);
			int count2 = 1;
				
			while(!(token=next("!")).isNull())
			{
		
				iso_field_value[count2] = token;

				count2++;
			}


			RWCString new_field_63 = "";
			int j;
			for(j = 0; j < 29; j++)
			{

				if(iso_field_value[j].length() != 0)
				{

					if( (iso_field_value[j](0,2) == "CE") && (iso_field_value[j].length() == 49))
						iso_field_value[j]=iso_field_value[j](0,8)+RetornoHexadecimalComplete(iso_field_value[j](8,40),20);
		

					if( (iso_field_value[j](1,2) == "CE") && (iso_field_value[j].length() == 50))
						iso_field_value[j]=iso_field_value[j](0,9)+RetornoHexadecimalComplete(iso_field_value[j](9,40),20);
		

					new_field_63+=iso_field_value[j]+" !";
				}

			}
		    
			testiso200.setIsoMsg8583All("00063", new_field_63(0,new_field_63.length()-1));
	
	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 63))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::SetIso8583B24FromBtransFormatVBV1C( RWCString incoming, char *application, char *header_msg ,int debug)
{

	////cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				

				/*
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) ||  (atoi(field_number) == 19 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField1C(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField1C(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}
				*/
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 63))
			{
				
				

				RWTValVector<RWCString> iso_field_value(30,"");

				RWCString field63_RW=iso_field [atoi(field_number)];
	
				RWCString token;
				RWCTokenizer next(field63_RW);
				int count2 = 1;
				
				while(!(token=next("!")).isNull())
				{
		
					iso_field_value[count2] = token;

					count2++;
				}


				RWCString new_field_63 = "";
				int j;
				for(j = 0; j < 29; j++)
				{

					if(iso_field_value[j].length() != 0)
					{

						if( (iso_field_value[j](0,2) == "CE") && (iso_field_value[j].length() == 49))
							iso_field_value[j]=iso_field_value[j](0,8)+RetornoHexadecimalComplete(iso_field_value[j](8,40),20);
		

						if( (iso_field_value[j](1,2) == "CE") && (iso_field_value[j].length() == 50))
							iso_field_value[j]=iso_field_value[j](0,9)+RetornoHexadecimalComplete(iso_field_value[j](9,40),20);
		

						new_field_63+=iso_field_value[j]+" !";
					}

				}
		    
				testiso200.setIsoMsg8583All("00063", new_field_63(0,new_field_63.length()-1));
	
	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 63))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}




RWCString MQUtility::SetIso8583B24FromBtransFormatReplica( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoFieldReplica(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoFieldReplica(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::SetIso8583VicanaFromBtransFormat( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		//testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ) || (atoi(field_number) == 26 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}

RWCString MQUtility::Set0810Iso8583B24FromBtransFormat( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", "0810");

			//so_field [1] = valor_field;
			iso_field [1] = "0810";
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		


			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 13))
			{
				
				testiso200.setIsoMsg8583All("00039", "00");
			}

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::Set0800Iso8583B24FromBtransFormat( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			//iso_field [1] = "0810";
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		



			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}

RWCString MQUtility::Set0800Iso8583B24FromBtransFormat1C( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			//iso_field [1] = "0810";
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		



			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				/*
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
				
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 */
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}

RWCString MQUtility::setMapIsoPosTermFromGenericWKP( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}										
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
				cout << "Valor de iso_field [atoi(field_number)] " << iso_field [atoi(field_number)] << endl;

				 
			/*	
				RWCString output_descrypt;
				RWCString output_encrypt;
				RWCString key				  = "1123456789abcdef";
	            RWCString output_for_descrypt = output_descrypt;


				char ath_key[20]			  = {""};
				char output_to_encrypt[20]	  = {""};
				char output_to_decrypt[20]	  = {""};

		 		strcpy(output_to_decrypt,iso_field [atoi(field_number)]);

				FDumpHex des_descrypt;
				FDumpHex des_encrypt;


				output_descrypt=des_descrypt.DES_Hex_Decrypt("0123456789abcdef", output_to_decrypt) ;
				cout << "Valor de output_descrypt > " << output_descrypt << endl;
				cout << "Valor de output_descrypt.length() > " << output_descrypt.length() << endl;

	        
	         
				strcpy(ath_key ,key); 
				strcpy(output_to_encrypt,output_descrypt);

				output_encrypt=des_encrypt.DES_Hex_Encrypt(ath_key, output_to_encrypt) ;
	
				cout << "Valor de output_encrypt > " << output_encrypt << endl;
				cout << "Valor de output_encrypt.length() > " << output_encrypt.length() << endl;
				iso_field [atoi(field_number)]=output_encrypt;
		 
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		*/
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}



int MQUtility::VerifyGenericVar( RWCString incoming, char *application, char *header_msg ,int debug)
{


/*
	int counter_token_begin = 0;
	RWCTokenizer next_begin(valor_rw);
	RWCString token3;
	//This evaluted if thera are more than one Message//
	while(!(token3=next_begin(	RWCString(start_of_text))).isNull())
	{	
		counter_token_begin++;
	}
*/	
	
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 1;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
	//cout << "valor de incoming dentro " << incoming << endl;	
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	if( counter_token > 30)
	{
		cout << "Valor de counter_token "<< counter_token << endl;
		//token2 = "";
		flag_true = 0;
	}
	else
	{
		
		
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
		    //cout << "Antes de field_number " << F1 << endl;
			
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}

			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);

			//cout << "Valor de field_number " << field_number << endl;
		
			//field_number
			//////////////////////////////////////////////////////////////////////
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129) && (field_number.length() == 5))
			{
			//	cout << "Valor de field_number dentro " << field_number << endl;
			//	cout << "valor de atoi(field_number) " << atoi(field_number) << endl;

				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) ||  (atoi(field_number) == 19 ) ||  (atoi(field_number) == 22 )
				 || (atoi(field_number) == 24 )|| (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
			if (strcmp(application,"base24") == 0)
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
}
	
	return flag_true;
}


int MQUtility::VerifyGenericVar1C( RWCString incoming, char *application, char *header_msg ,int debug)
{


/*
	int counter_token_begin = 0;
	RWCTokenizer next_begin(valor_rw);
	RWCString token3;
	//This evaluted if thera are more than one Message//
	while(!(token3=next_begin(	RWCString(start_of_text))).isNull())
	{	
		counter_token_begin++;
	}
*/	
	
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 1;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
	//cout << "valor de incoming dentro " << incoming << endl;	
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}
	if( counter_token > 29)
	{
		cout << "Valor de counter_token "<< counter_token << endl;
		//token2 = "";
		flag_true = 0;
	}
	else
	{
		
		
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
				
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}

			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
			if (strcmp(application,"base24") == 0)
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
}
	
	return flag_true;
}


int MQUtility::VerifyGenericVar0420( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 1;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}

												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;
					}

				}
				else
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
			if (strcmp(application,"base24") == 0)
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		

	
	return flag_true;
}



int MQUtility::VerifyGenericVar04201C( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 1;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}
									
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;
					}

				}
				else
				{
					if( VerifyIsoFieldAVS0420(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
			if (strcmp(application,"base24") == 0)
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		

	
	return flag_true;
}

int MQUtility::VerifyGenericVar0420ATH( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 1;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			if (F1.length() < 5)
			{
				flag_true = 0;
				break;

		
			}
									
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoFieldAVS0420ATHDebito(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;
					}

				}
				else
				{
					if( VerifyIsoFieldAVS0420ATHDebito(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 0;
						break;

					}

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
			if (strcmp(application,"base24") == 0)
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
		}
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		

	
	return flag_true;
}


RWCString MQUtility::setGenericFromGenericVar( RWCString incoming)
{

	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCString delimiter = ",";
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
		
	MQUtility testiso200;
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
		
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
			
									
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						msg_reponse_with_tcp_header +=valor_field;
						msg_reponse_with_tcp_header +=delimiter;
					}
					else
						break;

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						msg_reponse_with_tcp_header +=valor_field;
						msg_reponse_with_tcp_header +=delimiter;
					}
					else
						break;

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

	
		
		}
			
			
	}
		
	
	return "0210"+delimiter+msg_reponse_with_tcp_header;
}
/*
BOOL MQUtility::VerifyGenericFieldFromGenericVar( RWCString incoming)
{

	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCString delimiter = ",";
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
		
	MQUtility testiso200;
	
	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
		
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 22 )
				 || (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						msg_reponse_with_tcp_header +=valor_field;
						msg_reponse_with_tcp_header +=delimiter;
					}
					else
					{
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						msg_reponse_with_tcp_header +=valor_field;
						msg_reponse_with_tcp_header +=delimiter;
					}
					else
						break;

				}

				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

	
		
		}
			
			
	}
		
	
	return flag_salida;
}
*/


BOOL MQUtility::VerifyIsoFieldAVS0420( RWCString input_msg, int input_field) 
{
	
	char incoming_field[256] = {""};
	RWCString msg_reponse_with_tcp_header = "";
	int count = 0;
	BOOL flag_salida = TRUE;
	RWCString token;
	token = input_msg;
	while(1)
	{	
		if (input_field == 3)
		{
			processing_code= token; 
			int processing_code_length = processing_code.length();
			if( processing_code_length != 6)
			{
				
				MessageErrorLength(RWCString("processing_code F3"),
					processing_code_length,6);
				flag_salida = FALSE;
				break;
			}
			
			strcpy(incoming_field,processing_code);
		
			if ( (VerifyNumericField(incoming_field, 6,
					RWCString("processing_code F3"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}
		
		if (input_field == 4)
		{
			transaction_amount = token; 

			int transaction_amount_length = transaction_amount.length();
			if( transaction_amount_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount F4"),
				transaction_amount.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount F4"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}


		if (input_field == 7)
		{
			transmition_date_time = token; 
			int transmition_date_time_length = transmition_date_time.length();
			if( transmition_date_time_length != 10)
			{
				MessageErrorLength(RWCString("transmition_date_time F7"),
					transmition_date_time_length,10);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,transmition_date_time);
		
			if ( (VerifyNumericField(incoming_field,10 ,
					RWCString("transmition_date_time F7"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			
		}

		if (input_field == 11)
		{
		
			system_trace = token; 
			int system_trace_length = system_trace.length();
			if( system_trace_length != 6)
			{
				MessageErrorLength(RWCString("system_trace F11"),
					system_trace_length,6);
				flag_salida = FALSE;
				break;
			}
		
			strcpy(incoming_field,system_trace);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("system_trace F11"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}				 
					
		if (input_field == 12) 
		{				
					
			time_local_transaction = token;
			int time_local_transaction_length = time_local_transaction.length();
			if( time_local_transaction_length != 6)
			{
				MessageErrorLength(RWCString("time_local_transaction F12"),
					time_local_transaction_length,6);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,time_local_transaction);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("time_local_transaction F12"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		
		}
	
		if (input_field == 13)
		{
				
			date_local_transaction = token; 
			int date_local_transaction_length = date_local_transaction.length();
			if( date_local_transaction_length != 4)
			{
				MessageErrorLength(RWCString("date_local_transaction F13"),
				date_local_transaction_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,date_local_transaction);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("date_local_transaction F13"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 

		
		if (input_field == 14)
		{
				
			expiration_date = token; 
			int expiration_date_length = expiration_date.length();
			if( expiration_date_length != 4)
			{
				MessageErrorLength(RWCString("expiration_date F14"),
				expiration_date_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,expiration_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("expiration_date F14"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 
		if (input_field == 17)
		{
				
			capture_date = token; 
			int capture_date_length = capture_date.length();
			if( capture_date_length != 4)
			{
				MessageErrorLength(RWCString("capture_date F17"),
				capture_date_length,4);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,capture_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("capture_date F17"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}				 
	
		if (input_field == 18)
		{
				
			merchant_type = token; 
			int merchant_type_length = merchant_type.length();
			if( merchant_type_length != 4)
			{
				MessageErrorLength(RWCString("merchant_type F18"),
				merchant_type_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,merchant_type);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("merchant_type F18"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 22)
		{
				
			pos_entry_mode = token; 
			int pos_entry_mode_length = pos_entry_mode.length();
			if( pos_entry_mode_length != 3)
			{
				MessageErrorLength(RWCString("pos_entry_mode F22"),
				pos_entry_mode_length,3);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_entry_mode);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("pos_entry_mode F22"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		

		if (input_field == 25)
		{
			pos_condition_code = token; 
			int pos_condition_code_length = pos_condition_code.length();
			if( pos_condition_code_length != 2)
			{
				MessageErrorLength(RWCString("pos_condition_code F25"),
				pos_condition_code_length,2);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_condition_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("pos_condition_code F25"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}		

		if (input_field == 32)
		{
			
			//Este campo es variable y debe ser de 9 y delante del campo debe ir un 09
			//RWCString length_fiel_032 = "09"
			acquiring_institution_id_code = token; 
			
			int acquiring_institution_id_code_length = acquiring_institution_id_code.length();
			//if( acquiring_institution_id_code_length != 9)
			if( (acquiring_institution_id_code_length < 9) || (acquiring_institution_id_code_length > 15))
			{
				MessageErrorLength(RWCString("acquiring_institution_id_code F32"),
				acquiring_institution_id_code_length,9);
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 35)
		{
			
			//Este campo es variable y debe ser de 37 y delante del campo debe ir un 37
			track_2 = token; 
			int track_2_length = track_2.length();
			if( (track_2_length > 37) || (track_2_length < 30))
			{
				MessageErrorLength(RWCString("track_2 F35"),
				track_2_length,37);
				flag_salida = FALSE;
				break;
			}


			RWCString track_primera_parte;
			RWCString track_segunda_parte;
			RWCTokenizer next1(track_2);
			int counter_token = 0;
			RWCString token1;
					
			/*This extract the BIN from the Message*/
			while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
			{	
				if (counter_token == 0)
				{
					track_primera_parte = token1; 
				}			
				if (counter_token == 1)
				{
					track_segunda_parte = token1; 
				}			
				counter_token++;
			}
			strcpy(incoming_field,track_primera_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_primera F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,track_segunda_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_segunda F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}	

		if (input_field == 37)
		{
			retrieval_reference_number = token; 
			int retrieval_reference_number_length = retrieval_reference_number.length();
			if( retrieval_reference_number_length != 12)
			{
				MessageErrorLength(RWCString("retrieval_reference_number F37"),
				retrieval_reference_number_length,12);
				flag_salida = FALSE;
				break;
			}
		}	

		if (input_field == 41)
		{
			card_acceptor_terminal_id = token; 
			int card_acceptor_terminal_id_length = card_acceptor_terminal_id.length();
			if( card_acceptor_terminal_id_length != 16)
			{
				MessageErrorLength(RWCString("card_acceptor_terminal_id F41"),
				card_acceptor_terminal_id_length,16);
				flag_salida = FALSE;
				break;
			}
		}			

	
		if (input_field == 42)
		{
			card_acceptor_id_code = token; 
			int card_acceptor_id_code_length = card_acceptor_id_code.length();
			if( card_acceptor_id_code_length != 15)
			{
				MessageErrorLength(RWCString("card_acceptor_id_code F42"),
				card_acceptor_id_code_length,15);
				flag_salida = FALSE;
				break;
			}
		}
	
		if (input_field == 43)
		{
			card_acceptor_name_location = token; 
			int card_acceptor_name_location_length = card_acceptor_name_location.length();
			if( card_acceptor_name_location_length != 40)
			{
				MessageErrorLength(RWCString("card_acceptor_name_location F43"),
				card_acceptor_name_location_length,40);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 48)
		{
			pos_retailer_data = token; 
		/*
			int pos_retailer_data_length = pos_retailer_data.length();
			if( pos_retailer_data_length != 27)
			{
				MessageErrorLength(RWCString("pos_retailer_data F48"),
				pos_retailer_data_length,27);
				flag_salida = FALSE;
				break;
			}
			*/
		}				
		if (input_field == 49)
		{
			currency_code_transaction = token; 
			int currency_code_transaction_length = currency_code_transaction.length();
			if( currency_code_transaction_length != 3)
			{
				MessageErrorLength(RWCString("currency_code_transaction F49"),
				currency_code_transaction_length,3);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 52)
		{
			pin_data = token; 
			int pin_data_length = pin_data.length();
			if( pin_data_length != 16)
			{
				MessageErrorLength(RWCString("pin_data F52"),
				pin_data_length,16);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pin_data);
			if ( (VerifyHexField(incoming_field,16 ,
					RWCString("pin_data F52"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}			
	
		if (input_field == 60)
		{
			pos_terminal_data = token; 
			int pos_terminal_data_length = pos_terminal_data.length();
			if( pos_terminal_data_length != 16)
			{
				MessageErrorLength(RWCString("pos_terminal_data F60"),
				pos_terminal_data_length,16);
				flag_salida = FALSE;
				break;
			}
		
		}			
	
		if (input_field == 61)
		{
			pos_issuer_data = token; 
			int pos_issuer_data_length = pos_issuer_data.length();
			if( pos_issuer_data_length != 19)
			{
				MessageErrorLength(RWCString("pos_issuer_data F61"),
				pos_issuer_data_length,19);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (input_field == 63)
		{
			CVV2 = token; 
		
			/*
			if(CVV2(0,1) != "&")
			{
				cout << "< ************Invalid CVV2 ******************* > " << endl;
				flag_salida = FALSE;
				break;
			}
			*/
		}
		
		
		if (input_field == 120)
		{
			pos_terminal_address_branch = token; 
			int pos_terminal_address_branch_length = pos_terminal_address_branch.length();
			if( pos_terminal_address_branch_length != 29)
			{
				MessageErrorLength(RWCString("pos_terminal_address_branch F120"),
				pos_terminal_address_branch_length,29);
				flag_salida = FALSE;
				break;
			}
		
		}			


		if (input_field == 123)
		{
			pos_invoice_data = token; 
			int pos_invoice_data_length = pos_invoice_data.length();
			if( (pos_invoice_data_length < 15) || (pos_invoice_data_length > 20))
			{
				MessageErrorLength(RWCString("pos_invoice_data F123"),
				pos_invoice_data_length,20);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (input_field == 125)
		{
			pos_settlement_data = token; 
			int pos_settlement_data_length = pos_settlement_data.length();
			if( (pos_settlement_data_length < 9) || (pos_settlement_data_length > 12))
			{
				MessageErrorLength(RWCString("pos_settlement_data F125"),
				pos_settlement_data_length,pos_settlement_data_length);
				flag_salida = FALSE;
				break;
			}
		
		}			

		break;
	}
	//cout << "Valor flag_salida > " << flag_salida << endl;
	return	flag_salida ;
		
}

BOOL MQUtility::VerifyIsoFieldAVS0420ATHDebito( RWCString input_msg, int input_field) 
{
	
	char incoming_field[256] = {""};
	RWCString msg_reponse_with_tcp_header = "";
	int count = 0;
	BOOL flag_salida = TRUE;
	RWCString token;
	token = input_msg;
	while(1)
	{	
		if (input_field == 3)
		{
			processing_code= token; 
			int processing_code_length = processing_code.length();
			if( processing_code_length != 6)
			{
				
				MessageErrorLength(RWCString("processing_code F3"),
					processing_code_length,6);
				flag_salida = FALSE;
				break;
			}
			
			strcpy(incoming_field,processing_code);
		
			if ( (VerifyNumericField(incoming_field, 6,
					RWCString("processing_code F3"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}
		
		if (input_field == 4)
		{
			transaction_amount = token; 

			int transaction_amount_length = transaction_amount.length();
			if( transaction_amount_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount F4"),
				transaction_amount.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount F4"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}


		if (input_field == 7)
		{
			transmition_date_time = token; 
			int transmition_date_time_length = transmition_date_time.length();
			if( transmition_date_time_length != 10)
			{
				MessageErrorLength(RWCString("transmition_date_time F7"),
					transmition_date_time_length,10);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,transmition_date_time);
		
			if ( (VerifyNumericField(incoming_field,10 ,
					RWCString("transmition_date_time F7"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			
		}

		if (input_field == 11)
		{
		
			system_trace = token; 
			int system_trace_length = system_trace.length();
			if( system_trace_length != 6)
			{
				MessageErrorLength(RWCString("system_trace F11"),
					system_trace_length,6);
				flag_salida = FALSE;
				break;
			}
		
			strcpy(incoming_field,system_trace);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("system_trace F11"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}				 
					
		if (input_field == 12) 
		{				
					
			time_local_transaction = token;
			int time_local_transaction_length = time_local_transaction.length();
			if( time_local_transaction_length != 6)
			{
				MessageErrorLength(RWCString("time_local_transaction F12"),
					time_local_transaction_length,6);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,time_local_transaction);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("time_local_transaction F12"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		
		}
	
		if (input_field == 13)
		{
				
			date_local_transaction = token; 
			int date_local_transaction_length = date_local_transaction.length();
			if( date_local_transaction_length != 4)
			{
				MessageErrorLength(RWCString("date_local_transaction F13"),
				date_local_transaction_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,date_local_transaction);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("date_local_transaction F13"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 

		
		if (input_field == 14)
		{
				
			expiration_date = token; 
			int expiration_date_length = expiration_date.length();
			if( expiration_date_length != 4)
			{
				MessageErrorLength(RWCString("expiration_date F14"),
				expiration_date_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,expiration_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("expiration_date F14"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}	
		
		if (input_field == 15)
		{
				
			date_settlement_015 = token; 
			int date_settlement_015_length = date_settlement_015.length();
			if( date_settlement_015_length != 4)
			{
				MessageErrorLength(RWCString("date_settlement_015 F15"),
				date_settlement_015_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,date_settlement_015);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("date_settlement_015 F15"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 
		
		if (input_field == 17)
		{
				
			capture_date = token; 
			int capture_date_length = capture_date.length();
			if( capture_date_length != 4)
			{
				MessageErrorLength(RWCString("capture_date F17"),
				capture_date_length,4);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,capture_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("capture_date F17"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}				 
	
		if (input_field == 18)
		{
				
			merchant_type = token; 
			int merchant_type_length = merchant_type.length();
			if( merchant_type_length != 4)
			{
				MessageErrorLength(RWCString("merchant_type F18"),
				merchant_type_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,merchant_type);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("merchant_type F18"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 22)
		{
				
			pos_entry_mode = token; 
			int pos_entry_mode_length = pos_entry_mode.length();
			if( pos_entry_mode_length != 3)
			{
				MessageErrorLength(RWCString("pos_entry_mode F22"),
				pos_entry_mode_length,3);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_entry_mode);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("pos_entry_mode F22"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		

		if (input_field == 25)
		{
			pos_condition_code = token; 
			int pos_condition_code_length = pos_condition_code.length();
			if( pos_condition_code_length != 2)
			{
				MessageErrorLength(RWCString("pos_condition_code F25"),
				pos_condition_code_length,2);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_condition_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("pos_condition_code F25"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}		

		if (input_field == 32)
		{
			
			//Este campo es variable y debe ser de 9 y delante del campo debe ir un 09
			//RWCString length_fiel_032 = "09"
			acquiring_institution_id_code = token; 
			
			int acquiring_institution_id_code_length = acquiring_institution_id_code.length();
			//if( acquiring_institution_id_code_length != 9)
			if( (acquiring_institution_id_code_length < 9) || (acquiring_institution_id_code_length > 15))
			{
				MessageErrorLength(RWCString("acquiring_institution_id_code F32"),
				acquiring_institution_id_code_length,9);
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 35)
		{
			
			//Este campo es variable y debe ser de 37 y delante del campo debe ir un 37
			track_2 = token; 
			int track_2_length = track_2.length();
			if( (track_2_length > 37) || (track_2_length < 30))
			{
				MessageErrorLength(RWCString("track_2 F35"),
				track_2_length,37);
				flag_salida = FALSE;
				break;
			}


			RWCString track_primera_parte;
			RWCString track_segunda_parte;
			RWCTokenizer next1(track_2);
			int counter_token = 0;
			RWCString token1;
					
			/*This extract the BIN from the Message*/
			while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
			{	
				if (counter_token == 0)
				{
					track_primera_parte = token1; 
				}			
				if (counter_token == 1)
				{
					track_segunda_parte = token1; 
				}			
				counter_token++;
			}
			strcpy(incoming_field,track_primera_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_primera F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,track_segunda_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_segunda F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}	

		if (input_field == 37)
		{
			retrieval_reference_number = token; 
			int retrieval_reference_number_length = retrieval_reference_number.length();
			if( retrieval_reference_number_length != 12)
			{
				MessageErrorLength(RWCString("retrieval_reference_number F37"),
				retrieval_reference_number_length,12);
				flag_salida = FALSE;
				break;
			}
		}	


		if (input_field == 39)
		{
			responde_code_039 = token; 
			int responde_code_039_length = responde_code_039.length();
			if( responde_code_039_length != 2)
			{
				MessageErrorLength(RWCString("responde_code F39"),
				responde_code_039_length,2);
				flag_salida = FALSE;
				break;
			}
		}	


		if (input_field == 41)
		{
			card_acceptor_terminal_id = token; 
			int card_acceptor_terminal_id_length = card_acceptor_terminal_id.length();
			if( card_acceptor_terminal_id_length != 16)
			{
				MessageErrorLength(RWCString("card_acceptor_terminal_id F41"),
				card_acceptor_terminal_id_length,16);
				flag_salida = FALSE;
				break;
			}
		}			

	/*
		if (input_field == 42)
		{
			card_acceptor_id_code = token; 
			int card_acceptor_id_code_length = card_acceptor_id_code.length();
			if( card_acceptor_id_code_length != 15)
			{
				MessageErrorLength(RWCString("card_acceptor_id_code F42"),
				card_acceptor_id_code_length,15);
				flag_salida = FALSE;
				break;
			}
		}
	*/
		if (input_field == 43)
		{
			card_acceptor_name_location = token; 
			int card_acceptor_name_location_length = card_acceptor_name_location.length();
			if( card_acceptor_name_location_length != 40)
			{
				MessageErrorLength(RWCString("card_acceptor_name_location F43"),
				card_acceptor_name_location_length,40);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 48)
		{
			pos_retailer_data = token; 
	
			int pos_retailer_data_length = pos_retailer_data.length();
			if( pos_retailer_data_length != 27)
			{
				MessageErrorLength(RWCString("pos_retailer_data F48"),
				pos_retailer_data_length,27);
				flag_salida = FALSE;
				break;
			}
			
		}
	
		if (input_field == 49)
		{
			currency_code_transaction = token; 
			int currency_code_transaction_length = currency_code_transaction.length();
			if( currency_code_transaction_length != 3)
			{
				MessageErrorLength(RWCString("currency_code_transaction F49"),
				currency_code_transaction_length,3);
				flag_salida = FALSE;
				break;
			}
		}			
/*
		if (input_field == 52)
		{
			pin_data = token; 
			int pin_data_length = pin_data.length();
			if( pin_data_length != 16)
			{
				MessageErrorLength(RWCString("pin_data F52"),
				pin_data_length,16);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pin_data);
			if ( (VerifyHexField(incoming_field,16 ,
					RWCString("pin_data F52"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}			
*/	
		if (input_field == 60)
		{
			pos_terminal_data = token; 
			int pos_terminal_data_length = pos_terminal_data.length();
			if( pos_terminal_data_length != 16)
			{
				MessageErrorLength(RWCString("pos_terminal_data F60"),
				pos_terminal_data_length,16);
				flag_salida = FALSE;
				break;
			}
		
		}			
	
		if (input_field == 61)
		{
			pos_issuer_data = token; 
			int pos_issuer_data_length = pos_issuer_data.length();
			if( pos_issuer_data_length != 19)
			{
				MessageErrorLength(RWCString("pos_issuer_data F61"),
				pos_issuer_data_length,19);
				flag_salida = FALSE;
				break;
			}
		
		}			
/*
		if (input_field == 63)
		{
			CVV2 = token; 
		
			
			if(CVV2(0,1) != "&")
			{
				cout << "< ************Invalid CVV2 ******************* > " << endl;
				flag_salida = FALSE;
				break;
			}
		
		}
		
		
		if (input_field == 120)
		{
			pos_terminal_address_branch = token; 
			int pos_terminal_address_branch_length = pos_terminal_address_branch.length();
			if( pos_terminal_address_branch_length != 29)
			{
				MessageErrorLength(RWCString("pos_terminal_address_branch F120"),
				pos_terminal_address_branch_length,29);
				flag_salida = FALSE;
				break;
			}
		
		}			

*/
		if (input_field == 90)
		{
			
			
			
			original_data_elements = token; 
			int original_data_elements_length = original_data_elements.length();
			if( original_data_elements_length != 42)
			{
				MessageErrorLength(RWCString("original_data_elements F90"),
				original_data_elements_length,42);
				flag_salida = FALSE;
				break;
			}
		
		}		

		if (input_field == 123)
		{
			pos_invoice_data = token; 
			int pos_invoice_data_length = pos_invoice_data.length();
			if( (pos_invoice_data_length < 15) || (pos_invoice_data_length > 20))
			{
				MessageErrorLength(RWCString("pos_invoice_data F123"),
				pos_invoice_data_length,20);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (input_field == 125)
		{
			pos_settlement_data = token; 
			int pos_settlement_data_length = pos_settlement_data.length();
			if( (pos_settlement_data_length < 9) || (pos_settlement_data_length > 12))
			{
				MessageErrorLength(RWCString("pos_settlement_data F125"),
				pos_settlement_data_length,pos_settlement_data_length);
				flag_salida = FALSE;
				break;
			}
		
		}			

		break;
	}
	//cout << "Valor flag_salida > " << flag_salida << endl;
	return	flag_salida ;
		
}




BOOL MQUtility::VerifyIsoField( RWCString input_msg, int input_field) 
{
	
	char incoming_field[256] = {""};
	RWCString msg_reponse_with_tcp_header = "";
	int count = 0;
	BOOL flag_salida = TRUE;
	RWCString token;
	token = input_msg;
	while(1)
	{	
		if (input_field == 3)
		{
			processing_code= token; 
			int processing_code_length = processing_code.length();
			if( processing_code_length != 6)
			{
				
				MessageErrorLength(RWCString("processing_code F3"),
					processing_code_length,6);
				flag_salida = FALSE;
				break;
			}
			
			strcpy(incoming_field,processing_code);
		
			if ( (VerifyNumericField(incoming_field, 6,
					RWCString("processing_code F3"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}
		
		if (input_field == 4)
		{
			transaction_amount = token; 

			int transaction_amount_length = transaction_amount.length();
			if( transaction_amount_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount F4"),
				transaction_amount.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount F4"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}

		if (input_field == 5)
		{
			transaction_amount_itbis = token; 

			int transaction_amount_itbis_length = transaction_amount_itbis.length();
			if( transaction_amount_itbis_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount_itbis F5"),
				transaction_amount_itbis.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount_itbis);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount_itbis F5"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}


		if (input_field == 7)
		{
			transmition_date_time = token; 
			int transmition_date_time_length = transmition_date_time.length();
			if( transmition_date_time_length != 10)
			{
				MessageErrorLength(RWCString("transmition_date_time F7"),
					transmition_date_time_length,10);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,transmition_date_time);
		
			if ( (VerifyNumericField(incoming_field,10 ,
					RWCString("transmition_date_time F7"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			
		}

		if (input_field == 11)
		{
		
			system_trace = token; 
		
			int system_trace_length = system_trace.length();
			if( system_trace_length != 6)
			{
				MessageErrorLength(RWCString("system_trace F11"),
					system_trace_length,6);
				flag_salida = FALSE;
				break;
			}
		
			strcpy(incoming_field,system_trace);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("system_trace F11"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		
		}				 
					
		if (input_field == 12) 
		{				
					
			time_local_transaction = token;
			int time_local_transaction_length = time_local_transaction.length();
			if( time_local_transaction_length != 6)
			{
				MessageErrorLength(RWCString("time_local_transaction F12"),
					time_local_transaction_length,6);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,time_local_transaction);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("time_local_transaction F12"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		
		}
	
		if (input_field == 13)
		{
				
			date_local_transaction = token; 
			int date_local_transaction_length = date_local_transaction.length();
			if( date_local_transaction_length != 4)
			{
				MessageErrorLength(RWCString("date_local_transaction F13"),
				date_local_transaction_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,date_local_transaction);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("date_local_transaction F13"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 

		
		if (input_field == 14)
		{
				
			expiration_date = token; 
			int expiration_date_length = expiration_date.length();
			if( expiration_date_length != 4)
			{
				MessageErrorLength(RWCString("expiration_date F14"),
				expiration_date_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,expiration_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("expiration_date F14"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 
		if (input_field == 17)
		{
				
			capture_date = token; 
			int capture_date_length = capture_date.length();
			if( capture_date_length != 4)
			{
				MessageErrorLength(RWCString("capture_date F17"),
				capture_date_length,4);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,capture_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("capture_date F17"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}				 
	
		if (input_field == 18)
		{
				
			merchant_type = token; 
			int merchant_type_length = merchant_type.length();
			if( merchant_type_length != 4)
			{
				MessageErrorLength(RWCString("merchant_type F18"),
				merchant_type_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,merchant_type);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("merchant_type F18"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		

		if (input_field == 19)
		{
				
			acq_country_code = token; 
			int acq_country_code_length = acq_country_code.length();
			if( acq_country_code_length != 3)
			{
				MessageErrorLength(RWCString("acq_country_code F19"),
				acq_country_code_length,3);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,acq_country_code);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("acq_country_code F19"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 22)
		{
				
			pos_entry_mode = token; 
			int pos_entry_mode_length = pos_entry_mode.length();
			if( pos_entry_mode_length != 3)
			{
				MessageErrorLength(RWCString("pos_entry_mode F22"),
				pos_entry_mode_length,3);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_entry_mode);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("pos_entry_mode F22"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}	
		if (input_field == 24)
		{
				
			function_code = token; 
		
			int function_code_length = function_code.length();
			if( function_code_length != 3)
			{
				MessageErrorLength(RWCString("function_code F24"),
				function_code_length,3);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,function_code);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("function_code F24"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		}		

		if (input_field == 25)
		{
			pos_condition_code = token; 
			int pos_condition_code_length = pos_condition_code.length();
			if( pos_condition_code_length != 2)
			{
				MessageErrorLength(RWCString("pos_condition_code F25"),
				pos_condition_code_length,2);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_condition_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("pos_condition_code F25"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}		

		if (input_field == 32)
		{
			
			//Este campo es variable y debe ser de 9 y delante del campo debe ir un 09
			//RWCString length_fiel_032 = "09"
			acquiring_institution_id_code = token; 
			/*
			int acquiring_institution_id_code_length = acquiring_institution_id_code.length();
			//if( acquiring_institution_id_code_length != 9)
			if( (acquiring_institution_id_code_length < 9) || (acquiring_institution_id_code_length > 15))
			{
				MessageErrorLength(RWCString("acquiring_institution_id_code F32"),
				acquiring_institution_id_code_length,9);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,acquiring_institution_id_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("acquiring_institution_id_code F32"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		*/
		}		
		



		if (input_field == 32)
		{
			
			//Este campo es variable y debe ser de 9 y delante del campo debe ir un 09
			//RWCString length_fiel_032 = "09"
			original_amounts_F30 = token; 
			/*
			int acquiring_institution_id_code_length = acquiring_institution_id_code.length();
			//if( acquiring_institution_id_code_length != 9)
			if( (acquiring_institution_id_code_length < 9) || (acquiring_institution_id_code_length > 15))
			{
				MessageErrorLength(RWCString("acquiring_institution_id_code F32"),
				acquiring_institution_id_code_length,9);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,acquiring_institution_id_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("acquiring_institution_id_code F32"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		*/
		}		
		if (input_field == 35)
		{
			
			//Este campo es variable y debe ser de 37 y delante del campo debe ir un 37
			track_2 = token; 

			/*
			int track_2_length = track_2.length();
			if( (track_2_length > 37) || (track_2_length < 20))
			{
				MessageErrorLength(RWCString("track_2 F35"),
				track_2_length,37);
				flag_salida = FALSE;
				break;
			}


			RWCString track_primera_parte;
			RWCString track_segunda_parte;
			RWCTokenizer next1(track_2);
			int counter_token = 0;
			RWCString token1;
					
			/This extract the BIN from the Message/
			while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
			{	
				if (counter_token == 0)
				{
					track_primera_parte = token1; 
				}			
				if (counter_token == 1)
				{
					track_segunda_parte = token1; 
				}			
				counter_token++;
			}
			strcpy(incoming_field,track_primera_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_primera F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,track_segunda_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_segunda F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

*/
		}	

		if (input_field == 37)
		{
			retrieval_reference_number = token; 
			int retrieval_reference_number_length = retrieval_reference_number.length();
			if( retrieval_reference_number_length != 12)
			{
				MessageErrorLength(RWCString("retrieval_reference_number F37"),
				retrieval_reference_number_length,12);
				flag_salida = FALSE;
				break;
			}
		}	

		if (input_field == 41)
		{
			card_acceptor_terminal_id = token; 
			
			int card_acceptor_terminal_id_length = card_acceptor_terminal_id.length();

			if( (card_acceptor_terminal_id_length < 8) || (card_acceptor_terminal_id_length > 16) )
		
			//if( card_acceptor_terminal_id_length != 16)
			{
				MessageErrorLength(RWCString("card_acceptor_terminal_id F41"),
				card_acceptor_terminal_id_length,16);
				flag_salida = FALSE;
				break;
			}
			
		}			

	
		if (input_field == 42)
		{
			card_acceptor_id_code = token; 
			
			int card_acceptor_id_code_length = card_acceptor_id_code.length();
			if( card_acceptor_id_code_length != 15)
			{
				MessageErrorLength(RWCString("card_acceptor_id_code F42"),
				card_acceptor_id_code_length,15);
				flag_salida = FALSE;
				break;
			}
			
		}
	
		if (input_field == 43)
		{
			card_acceptor_name_location = token; 
			int card_acceptor_name_location_length = card_acceptor_name_location.length();
			if( card_acceptor_name_location_length != 40)
			{
				MessageErrorLength(RWCString("card_acceptor_name_location F43"),
				card_acceptor_name_location_length,40);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 48)
		{
			pos_retailer_data = token; 
		
			int pos_retailer_data_length = pos_retailer_data.length();
			if( pos_retailer_data_length != 27)
			{
				MessageErrorLength(RWCString("pos_retailer_data F48"),
				pos_retailer_data_length,27);
				flag_salida = FALSE;
				break;
			}
			
		}				
		if (input_field == 49)
		{
			currency_code_transaction = token; 
			int currency_code_transaction_length = currency_code_transaction.length();
			if( currency_code_transaction_length != 3)
			{
				MessageErrorLength(RWCString("currency_code_transaction F49"),
				currency_code_transaction_length,3);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 52)
		{
			pin_data = token; 
			int pin_data_length = pin_data.length();
			if( pin_data_length != 16)
			{
				MessageErrorLength(RWCString("pin_data F52"),
				pin_data_length,16);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pin_data);
			if ( (VerifyHexField(incoming_field,16 ,
					RWCString("pin_data F52"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}			

		if (input_field == 54)
		{
			additional_data_054 = token; 
			int additional_data_054_length = additional_data_054.length();
			if( additional_data_054_length != 12)
			{
				MessageErrorLength(RWCString("additional_data_054 F54"),
				additional_data_054_length,12);
				flag_salida = FALSE;
				break;
			}
		
		
		}			

		if (input_field == 60)
		{
			pos_terminal_data = token; 
			int pos_terminal_data_length = pos_terminal_data.length();
			if( pos_terminal_data_length != 16)
			{
				MessageErrorLength(RWCString("pos_terminal_data F60"),
				pos_terminal_data_length,16);
				flag_salida = FALSE;
				break;
			}
		
		
		
		}			
	
		if (input_field == 61)
		{
			pos_issuer_data = token; 
			/*
			int pos_issuer_data_length = pos_issuer_data.length();
			if( pos_issuer_data_length != 19)
			{
				MessageErrorLength(RWCString("pos_issuer_data F61"),
				pos_issuer_data_length,19);
				flag_salida = FALSE;
				break;
			}
			*/
			int pos_issuer_data_length = pos_issuer_data.length();
			if( (pos_issuer_data_length < 5) || (pos_issuer_data_length > 50) )
			{
				MessageErrorLength(RWCString("pos_issuer_data F61"),
				pos_issuer_data_length,12);
				flag_salida = FALSE;
				break;
			}
		
		}			
		if (input_field == 62)
		{
			geographic_data = token;
			int geographic_data_length = geographic_data.length();
			if( (geographic_data_length < 5) || (geographic_data_length > 50) )
			{
				MessageErrorLength(RWCString("geographic_data F62"),
				geographic_data_length,12);
				flag_salida = FALSE;
				break;
			}
		}
		if (input_field == 63)
		{
			CVV2 = token; 
		/*
			int CVV2_length = CVV2.length();
			if( (CVV2_length < 12) || (CVV2_length > 59) )
			{
				MessageErrorLength(RWCString("CVV2 F63"),
				CVV2_length,12);
				flag_salida = FALSE;
				break;
			}
			*/
		}
		
		if (input_field == 102)
		{
			account_information_102 = token; 
		
			/*
			if(CVV2(0,1) != "&")
			{
				cout << "< ************Invalid CVV2 ******************* > " << endl;
				flag_salida = FALSE;
				break;
			}
			*/
		}
		if (input_field == 120)
		{
			pos_terminal_address_branch = token; 
		/*
			int pos_terminal_address_branch_length = pos_terminal_address_branch.length();
			if( pos_terminal_address_branch_length != 29)
			{
				MessageErrorLength(RWCString("pos_terminal_address_branch F120"),
				pos_terminal_address_branch_length,29);
				flag_salida = FALSE;
				break;
			}

  */
		
		}			


		if (input_field == 123)
		{
			pos_invoice_data = token; 
			
			int pos_invoice_data_length = pos_invoice_data.length();
			if( (pos_invoice_data_length < 20) || pos_invoice_data_length > 168 ) 
			{
				MessageErrorLength(RWCString("pos_invoice_data F123"),
				pos_invoice_data_length,20);
				flag_salida = FALSE;
				break;
			}
			
		
		}			

		if (input_field == 124)
		{
			batch_record2_0124 = token; 
			int batch_record2_0124_length = batch_record2_0124.length();
			if( batch_record2_0124_length != 9)
			{
				MessageErrorLength(RWCString("batch_record2_0124 F124"),
				batch_record2_0124_length,9);
				flag_salida = FALSE;
				break;
			}
		
		}		
		if (input_field == 125)
		{
			pos_settlement_data = token; 
			int pos_settlement_data_length = pos_settlement_data.length();
			if( (pos_settlement_data_length < 3) || pos_settlement_data_length > 20 ) 
		//	if( (pos_settlement_data_length != 12))
			{
				MessageErrorLength(RWCString("pos_settlement_data F125"),
				pos_settlement_data_length,pos_settlement_data_length);
				flag_salida = FALSE;
				break;
			}
		
		}		
		if (input_field == 126)
		{
			
			card_identifier = token; 
		
		}	
		
		if (input_field == 127)
		{
			
			ebt_bit_127 = token; 
		
		}

		break;
	}
	//cout << "Valor flag_salida > " << flag_salida << endl;
	return	flag_salida ;
		
}


RWCString MQUtility::setMapIsoPosTermFromGeneric1C( RWCString incoming, char *application, char *header_msg ,int debug)
{

//	cout << "valor de incoming dentro " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	int flag_true = 0;
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}
	//cout << "Valor de counter_token 
	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
	
		if( count == 0)
		{
			if(debug == 1)
				cout << endl;
	
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}
		
		else
		{
												
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				
				if( (atoi(field_number) == 3 ) || (atoi(field_number) == 4 )  || (atoi(field_number) == 5 )
				 || (atoi(field_number) == 7 ) || (atoi(field_number) == 11 ) || (atoi(field_number) == 12 )
				 || (atoi(field_number) == 13) || (atoi(field_number) == 14 ) || (atoi(field_number) == 17 )
				 || (atoi(field_number) == 17) || (atoi(field_number) == 18 ) || (atoi(field_number) == 19 ) 
				 || (atoi(field_number) == 22 )|| (atoi(field_number) == 24 )|| (atoi(field_number) == 25 ))
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;
					}

				}
				else
				{
					if( VerifyIsoField(valor_field,atoi(field_number)) == TRUE)
					{
						
					}
					else
					{
						flag_true = 1;
						break;

					}

				}

				/*
				if((atoi(field_number) < 0) || (!atoi(field_number) <= 125))
				{
					flag_true = 1;
						break;
				}
				*/
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
			{
				testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
			}
			
			if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		

			if ((strcmp(application,"base24") == 0) && (atoi(field_number) == 52))
			{
			
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
	

	
			}
			if ((strcmp(application,"base24") == 0) && (atoi(field_number) != 52))
		
			{
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
		
			}

		
		
		
      }
			
		if(debug == 1)
			cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
	}
		
	if(flag_true == 0)
		msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	else
		msg_reponse_with_tcp_header = "1";

	
	return msg_reponse_with_tcp_header;
}




BOOL MQUtility::VerifyIsoFieldReplica( RWCString input_msg, int input_field) 
{
	
	char incoming_field[256] = {""};
	RWCString msg_reponse_with_tcp_header = "";
	int count = 0;
	BOOL flag_salida = TRUE;
	RWCString token;
	token = input_msg;
	while(1)
	{	
		if (input_field == 3)
		{
			processing_code= token; 
			int processing_code_length = processing_code.length();
			if( processing_code_length != 6)
			{
				
				MessageErrorLength(RWCString("processing_code F3"),
					processing_code_length,6);
				flag_salida = FALSE;
				break;
			}
			
			strcpy(incoming_field,processing_code);
		
			if ( (VerifyNumericField(incoming_field, 6,
					RWCString("processing_code F3"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}
		
		if (input_field == 4)
		{
			transaction_amount = token; 

			int transaction_amount_length = transaction_amount.length();
			if( transaction_amount_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount F4"),
				transaction_amount.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount F4"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}

		if (input_field == 5)
		{
			transaction_amount_itbis = token; 

			int transaction_amount_itbis_length = transaction_amount_itbis.length();
			if( transaction_amount_itbis_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount_itbis F5"),
				transaction_amount_itbis.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount_itbis);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount_itbis F5"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}


		if (input_field == 7)
		{
			transmition_date_time = token; 
			int transmition_date_time_length = transmition_date_time.length();
			if( transmition_date_time_length != 10)
			{
				MessageErrorLength(RWCString("transmition_date_time F7"),
					transmition_date_time_length,10);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,transmition_date_time);
		
			if ( (VerifyNumericField(incoming_field,10 ,
					RWCString("transmition_date_time F7"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			
		}

		if (input_field == 11)
		{
		
			system_trace = token; 
		/*
			int system_trace_length = system_trace.length();
			if( system_trace_length != 6)
			{
				MessageErrorLength(RWCString("system_trace F11"),
					system_trace_length,6);
				flag_salida = FALSE;
				break;
			}
		
			strcpy(incoming_field,system_trace);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("system_trace F11"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		*/
		}				 
					
		if (input_field == 12) 
		{				
					
			time_local_transaction = token;
			int time_local_transaction_length = time_local_transaction.length();
			if( time_local_transaction_length != 6)
			{
				MessageErrorLength(RWCString("time_local_transaction F12"),
					time_local_transaction_length,6);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,time_local_transaction);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("time_local_transaction F12"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		
		}
	
		if (input_field == 13)
		{
				
			date_local_transaction = token; 
			int date_local_transaction_length = date_local_transaction.length();
			if( date_local_transaction_length != 4)
			{
				MessageErrorLength(RWCString("date_local_transaction F13"),
				date_local_transaction_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,date_local_transaction);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("date_local_transaction F13"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 

		
		if (input_field == 14)
		{
				
			expiration_date = token; 
			int expiration_date_length = expiration_date.length();
			if( expiration_date_length != 4)
			{
				MessageErrorLength(RWCString("expiration_date F14"),
				expiration_date_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,expiration_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("expiration_date F14"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 
		if (input_field == 17)
		{
				
			capture_date = token; 
			int capture_date_length = capture_date.length();
			if( capture_date_length != 4)
			{
				MessageErrorLength(RWCString("capture_date F17"),
				capture_date_length,4);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,capture_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("capture_date F17"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}				 
	
		if (input_field == 18)
		{
				
			merchant_type = token; 
			int merchant_type_length = merchant_type.length();
			if( merchant_type_length != 4)
			{
				MessageErrorLength(RWCString("merchant_type F18"),
				merchant_type_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,merchant_type);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("merchant_type F18"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		

		if (input_field == 19)
		{
				
			acq_country_code = token; 

		}		
		
		if (input_field == 22)
		{
				
			pos_entry_mode = token; 
			int pos_entry_mode_length = pos_entry_mode.length();
			if( pos_entry_mode_length != 3)
			{
				MessageErrorLength(RWCString("pos_entry_mode F22"),
				pos_entry_mode_length,3);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_entry_mode);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("pos_entry_mode F22"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}	
		if (input_field == 24)
		{
				
			function_code = token; 
		}		

		if (input_field == 25)
		{
			pos_condition_code = token; 
			int pos_condition_code_length = pos_condition_code.length();
			if( pos_condition_code_length != 2)
			{
				MessageErrorLength(RWCString("pos_condition_code F25"),
				pos_condition_code_length,2);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_condition_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("pos_condition_code F25"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}		

		if (input_field == 32)
		{
			
			//Este campo es variable y debe ser de 9 y delante del campo debe ir un 09
			//RWCString length_fiel_032 = "09"
			acquiring_institution_id_code = token; 
			
			int acquiring_institution_id_code_length = acquiring_institution_id_code.length();
			//if( acquiring_institution_id_code_length != 9)
			if( (acquiring_institution_id_code_length < 9) || (acquiring_institution_id_code_length > 15))
			{
				MessageErrorLength(RWCString("acquiring_institution_id_code F32"),
				acquiring_institution_id_code_length,9);
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 35)
		{
			
			//Este campo es variable y debe ser de 37 y delante del campo debe ir un 37
			track_2 = token; 
			int track_2_length = track_2.length();
			if( (track_2_length > 37) || (track_2_length < 30))
			{
				MessageErrorLength(RWCString("track_2 F35"),
				track_2_length,37);
				flag_salida = FALSE;
				break;
			}


			RWCString track_primera_parte;
			RWCString track_segunda_parte;
			RWCTokenizer next1(track_2);
			int counter_token = 0;
			RWCString token1;
					
			/*This extract the BIN from the Message*/
			while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
			{	
				if (counter_token == 0)
				{
					track_primera_parte = token1; 
				}			
				if (counter_token == 1)
				{
					track_segunda_parte = token1; 
				}			
				counter_token++;
			}
			strcpy(incoming_field,track_primera_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_primera F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,track_segunda_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_segunda F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}	

		if (input_field == 37)
		{
			retrieval_reference_number = token; 
			int retrieval_reference_number_length = retrieval_reference_number.length();
			if( retrieval_reference_number_length != 12)
			{
				MessageErrorLength(RWCString("retrieval_reference_number F37"),
				retrieval_reference_number_length,12);
				flag_salida = FALSE;
				break;
			}
		}	

		if (input_field == 41)
		{
			card_acceptor_terminal_id = token; 
			/*
			int card_acceptor_terminal_id_length = card_acceptor_terminal_id.length();
			if( card_acceptor_terminal_id_length != 16)
			{
				MessageErrorLength(RWCString("card_acceptor_terminal_id F41"),
				card_acceptor_terminal_id_length,16);
				flag_salida = FALSE;
				break;
			}
			*/
		}			

	
		if (input_field == 42)
		{
			card_acceptor_id_code = token; 
			/*
			int card_acceptor_id_code_length = card_acceptor_id_code.length();
			if( card_acceptor_id_code_length != 15)
			{
				MessageErrorLength(RWCString("card_acceptor_id_code F42"),
				card_acceptor_id_code_length,15);
				flag_salida = FALSE;
				break;
			}
			*/
		}
	
		if (input_field == 43)
		{
			card_acceptor_name_location = token; 
			int card_acceptor_name_location_length = card_acceptor_name_location.length();
			if( card_acceptor_name_location_length != 40)
			{
				MessageErrorLength(RWCString("card_acceptor_name_location F43"),
				card_acceptor_name_location_length,40);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 48)
		{
			pos_retailer_data = token; 
		/*
			int pos_retailer_data_length = pos_retailer_data.length();
			if( pos_retailer_data_length != 27)
			{
				MessageErrorLength(RWCString("pos_retailer_data F48"),
				pos_retailer_data_length,27);
				flag_salida = FALSE;
				break;
			}
			*/
		}				
		if (input_field == 49)
		{
			currency_code_transaction = token; 
			int currency_code_transaction_length = currency_code_transaction.length();
			if( currency_code_transaction_length != 3)
			{
				MessageErrorLength(RWCString("currency_code_transaction F49"),
				currency_code_transaction_length,3);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 52)
		{
			pin_data = token; 
			int pin_data_length = pin_data.length();
			if( pin_data_length != 16)
			{
				MessageErrorLength(RWCString("pin_data F52"),
				pin_data_length,16);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pin_data);
			if ( (VerifyHexField(incoming_field,16 ,
					RWCString("pin_data F52"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}			
	
		if (input_field == 60)
		{
			pos_terminal_data = token; 
		
		
		}			
	
		if (input_field == 61)
		{
			pos_issuer_data = token; 
		
		
		}			
		if (input_field == 62)
		{
				geographic_data = token; 
		}
		if (input_field == 63)
		{
			CVV2 = token; 
		
			/*
			if(CVV2(0,1) != "&")
			{
				cout << "< ************Invalid CVV2 ******************* > " << endl;
				flag_salida = FALSE;
				break;
			}
			*/
		}
		
		if (input_field == 102)
		{
			account_information_102 = token; 
		
			/*
			if(CVV2(0,1) != "&")
			{
				cout << "< ************Invalid CVV2 ******************* > " << endl;
				flag_salida = FALSE;
				break;
			}
			*/
		}
		if (input_field == 120)
		{
			pos_terminal_address_branch = token; 
			int pos_terminal_address_branch_length = pos_terminal_address_branch.length();
			if( pos_terminal_address_branch_length != 29)
			{
				MessageErrorLength(RWCString("pos_terminal_address_branch F120"),
				pos_terminal_address_branch_length,29);
				flag_salida = FALSE;
				break;
			}
		
		}			


		if (input_field == 123)
		{
			pos_invoice_data = token; 
			int pos_invoice_data_length = pos_invoice_data.length();
			if( (pos_invoice_data_length < 15) || (pos_invoice_data_length > 20))
			{
				MessageErrorLength(RWCString("pos_invoice_data F123"),
				pos_invoice_data_length,20);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (input_field == 125)
		{
			pos_settlement_data = token; 
			int pos_settlement_data_length = pos_settlement_data.length();
			if( (pos_settlement_data_length < 9) || (pos_settlement_data_length > 12))
			{
				MessageErrorLength(RWCString("pos_settlement_data F125"),
				pos_settlement_data_length,pos_settlement_data_length);
				flag_salida = FALSE;
				break;
			}
		
		}		
		if (input_field == 126)
		{
			
			card_identifier = token; 
		
		}			

		break;
	}
	//cout << "Valor flag_salida > " << flag_salida << endl;
	return	flag_salida ;
		
}


/*
BOOL MQUtility::VerifyIsoAllField( RWCString input_msg, int input_field) 
{
	
	char incoming_field[256] = {""};
	RWCString msg_reponse_with_tcp_header = "";
	int count = 0;
	BOOL flag_salida = TRUE;
	RWCString token;
	token = input_msg;
	while(1)
	{	
		if (input_field == 3)
		{
			processing_code= token; 
			int processing_code_length = processing_code.length();
			if( processing_code_length != 6)
			{
				
				MessageErrorLength(RWCString("processing_code F3"),
					processing_code_length,6);
				flag_salida = FALSE;
				break;
			}
			
			strcpy(incoming_field,processing_code);
		
			if ( (VerifyNumericField(incoming_field, 6,
					RWCString("processing_code F3"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}
		
		if (input_field == 4)
		{
			transaction_amount = token; 

			int transaction_amount_length = transaction_amount.length();
			if( transaction_amount_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount F4"),
				transaction_amount.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount F4"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}

		if (input_field == 5)
		{
			transaction_amount_itbis = token; 

			int transaction_amount_itbis_length = transaction_amount_itbis.length();
			if( transaction_amount_itbis_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount_itbis F5"),
				transaction_amount_itbis.length(),12);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,transaction_amount_itbis);
			
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount_itbis F5"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}


		if (input_field == 7)
		{
			transmition_date_time = token; 
			int transmition_date_time_length = transmition_date_time.length();
			if( transmition_date_time_length != 10)
			{
				MessageErrorLength(RWCString("transmition_date_time F7"),
					transmition_date_time_length,10);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,transmition_date_time);
		
			if ( (VerifyNumericField(incoming_field,10 ,
					RWCString("transmition_date_time F7"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			
		}

		if (input_field == 11)
		{
		
			system_trace = token; 
			int system_trace_length = system_trace.length();
			if( system_trace_length != 6)
			{
				MessageErrorLength(RWCString("system_trace F11"),
					system_trace_length,6);
				flag_salida = FALSE;
				break;
			}
		
			strcpy(incoming_field,system_trace);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("system_trace F11"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}				 
					
		if (input_field == 12) 
		{				
					
			time_local_transaction = token;
			int time_local_transaction_length = time_local_transaction.length();
			if( time_local_transaction_length != 6)
			{
				MessageErrorLength(RWCString("time_local_transaction F12"),
					time_local_transaction_length,6);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,time_local_transaction);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("time_local_transaction F12"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		
		}
	
		if (input_field == 13)
		{
				
			date_local_transaction = token; 
			int date_local_transaction_length = date_local_transaction.length();
			if( date_local_transaction_length != 4)
			{
				MessageErrorLength(RWCString("date_local_transaction F13"),
				date_local_transaction_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,date_local_transaction);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("date_local_transaction F13"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 

		
		if (input_field == 14)
		{
				
			expiration_date = token; 
			int expiration_date_length = expiration_date.length();
			if( expiration_date_length != 4)
			{
				MessageErrorLength(RWCString("expiration_date F14"),
				expiration_date_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,expiration_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("expiration_date F14"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 
		if (input_field == 17)
		{
				
			capture_date = token; 
			int capture_date_length = capture_date.length();
			if( capture_date_length != 4)
			{
				MessageErrorLength(RWCString("capture_date F17"),
				capture_date_length,4);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,capture_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("capture_date F17"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}				 
	
		if (input_field == 18)
		{
				
			merchant_type = token; 
			int merchant_type_length = merchant_type.length();
			if( merchant_type_length != 4)
			{
				MessageErrorLength(RWCString("merchant_type F18"),
				merchant_type_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,merchant_type);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("merchant_type F18"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 22)
		{
				
			pos_entry_mode = token; 
			int pos_entry_mode_length = pos_entry_mode.length();
			if( pos_entry_mode_length != 3)
			{
				MessageErrorLength(RWCString("pos_entry_mode F22"),
				pos_entry_mode_length,3);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_entry_mode);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("pos_entry_mode F22"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		

		if (input_field == 25)
		{
			pos_condition_code = token; 
			int pos_condition_code_length = pos_condition_code.length();
			if( pos_condition_code_length != 2)
			{
				MessageErrorLength(RWCString("pos_condition_code F25"),
				pos_condition_code_length,2);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_condition_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("pos_condition_code F25"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}		

		if (input_field == 32)
		{
			
			//Este campo es variable y debe ser de 9 y delante del campo debe ir un 09
			//RWCString length_fiel_032 = "09"
			acquiring_institution_id_code = token; 
			
			int acquiring_institution_id_code_length = acquiring_institution_id_code.length();
			//if( acquiring_institution_id_code_length != 9)
			if( (acquiring_institution_id_code_length < 9) || (acquiring_institution_id_code_length > 15))
			{
				MessageErrorLength(RWCString("acquiring_institution_id_code F32"),
				acquiring_institution_id_code_length,9);
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (input_field == 35)
		{
			
			//Este campo es variable y debe ser de 37 y delante del campo debe ir un 37
			track_2 = token; 
			int track_2_length = track_2.length();
			if( (track_2_length > 37) || (track_2_length < 30))
			{
				MessageErrorLength(RWCString("track_2 F35"),
				track_2_length,37);
				flag_salida = FALSE;
				break;
			}


			RWCString track_primera_parte;
			RWCString track_segunda_parte;
			RWCTokenizer next1(track_2);
			int counter_token = 0;
			RWCString token1;
					
			//This extract the BIN from the Message
			while(!(token1=next1("=")).isNull() || !(token1=next1("D")).isNull())
			{	
				if (counter_token == 0)
				{
					track_primera_parte = token1; 
				}			
				if (counter_token == 1)
				{
					track_segunda_parte = token1; 
				}			
				counter_token++;
			}
			strcpy(incoming_field,track_primera_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_primera F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,track_segunda_parte);
			if ( (VerifyNumericField(incoming_field,strlen(incoming_field),
					RWCString("Track_2_segunda F35"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}	

		if (input_field == 37)
		{
			retrieval_reference_number = token; 
			int retrieval_reference_number_length = retrieval_reference_number.length();
			if( retrieval_reference_number_length != 12)
			{
				MessageErrorLength(RWCString("retrieval_reference_number F37"),
				retrieval_reference_number_length,12);
				flag_salida = FALSE;
				break;
			}
		}	

		if (input_field == 41)
		{
			card_acceptor_terminal_id = token; 
			int card_acceptor_terminal_id_length = card_acceptor_terminal_id.length();
			if( card_acceptor_terminal_id_length != 16)
			{
				MessageErrorLength(RWCString("card_acceptor_terminal_id F41"),
				card_acceptor_terminal_id_length,16);
				flag_salida = FALSE;
				break;
			}
		}			

	
		if (input_field == 42)
		{
			card_acceptor_id_code = token; 
			int card_acceptor_id_code_length = card_acceptor_id_code.length();
			if( card_acceptor_id_code_length != 15)
			{
				MessageErrorLength(RWCString("card_acceptor_id_code F42"),
				card_acceptor_id_code_length,15);
				flag_salida = FALSE;
				break;
			}
		}
	
		if (input_field == 43)
		{
			card_acceptor_name_location = token; 
			int card_acceptor_name_location_length = card_acceptor_name_location.length();
			if( card_acceptor_name_location_length != 40)
			{
				MessageErrorLength(RWCString("card_acceptor_name_location F43"),
				card_acceptor_name_location_length,40);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 48)
		{
			pos_retailer_data = token; 
	
		}				
		if (input_field == 49)
		{
			currency_code_transaction = token; 
			int currency_code_transaction_length = currency_code_transaction.length();
			if( currency_code_transaction_length != 3)
			{
				MessageErrorLength(RWCString("currency_code_transaction F49"),
				currency_code_transaction_length,3);
				flag_salida = FALSE;
				break;
			}
		}			

		if (input_field == 52)
		{
			pin_data = token; 
			int pin_data_length = pin_data.length();
			if( pin_data_length != 16)
			{
				MessageErrorLength(RWCString("pin_data F52"),
				pin_data_length,16);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pin_data);
			if ( (VerifyHexField(incoming_field,16 ,
					RWCString("pin_data F52"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
	
		}			
	
		if (input_field == 60)
		{
			pos_terminal_data = token; 
			int pos_terminal_data_length = pos_terminal_data.length();
			if( pos_terminal_data_length != 16)
			{
				MessageErrorLength(RWCString("pos_terminal_data F60"),
				pos_terminal_data_length,16);
				flag_salida = FALSE;
				break;
			}
		
		}			
	
		if (input_field == 61)
		{
			pos_issuer_data = token; 
			int pos_issuer_data_length = pos_issuer_data.length();
			if( pos_issuer_data_length != 19)
			{
				MessageErrorLength(RWCString("pos_issuer_data F61"),
				pos_issuer_data_length,19);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (input_field == 63)
		{
			CVV2 = token; 
		
		
		}
		
		if (input_field == 102)
		{
			account_information_102 = token; 
		
		
		}
		if (input_field == 120)
		{
			pos_terminal_address_branch = token; 
			int pos_terminal_address_branch_length = pos_terminal_address_branch.length();
			if( pos_terminal_address_branch_length != 29)
			{
				MessageErrorLength(RWCString("pos_terminal_address_branch F120"),
				pos_terminal_address_branch_length,29);
				flag_salida = FALSE;
				break;
			}
		
		}			


		if (input_field == 123)
		{
			pos_invoice_data = token; 
			int pos_invoice_data_length = pos_invoice_data.length();
			if( (pos_invoice_data_length < 15) || (pos_invoice_data_length > 20))
			{
				MessageErrorLength(RWCString("pos_invoice_data F123"),
				pos_invoice_data_length,20);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (input_field == 125)
		{
			pos_settlement_data = token; 
			int pos_settlement_data_length = pos_settlement_data.length();
			if( (pos_settlement_data_length < 9) || (pos_settlement_data_length > 12))
			{
				MessageErrorLength(RWCString("pos_settlement_data F125"),
				pos_settlement_data_length,pos_settlement_data_length);
				flag_salida = FALSE;
				break;
			}
		
		}			

		break;
	}
	//cout << "Valor flag_salida > " << flag_salida << endl;
	return	flag_salida ;
		
}

*/

void MQUtility::ShowFieldIso8583B24Discover(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if ((incoming(18,1) == "8") || (incoming(18,1) == "9") || (incoming(18,1) == "A")
		|| (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "D")
		|| (incoming(18,1) == "E") || (incoming(18,1) == "F"))
	{

		//Se crea los fields con valores fijos
		 RWTValVector<int> iso_field_length(129,0);
	      
		iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
		iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
		iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
		iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;   iso_field_length[19] = 3;	
		iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
		iso_field_length[28] = 9;   iso_field_length[30] = 32; 	iso_field_length[37] = 12; 
		iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
		iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
		iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
		iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
		iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
		iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
		iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
		iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
		iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
		iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
		if(application == "base24")
		{
			iso_field_length[41] = 8;
		}

		if(application == "posterm")
		{
			iso_field_length[41] = 8;
		}

	
		if(application == "posterm")
		{

			msg_type_from_incming = incoming(7,4);

			response_0210_generic_from_iso += incoming(7,4);
		
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		//	response_0210_generic_from_iso +=delimiter;

			ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

			if (ascii_bit(0,1) == "7")
			{
				 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
				 hex_bit += "0000000000000000";
				 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
				 bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(19,incoming.length()-19);
			 

			}

			else
			{
				hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
				if(debug == 1)
		 
					 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
				bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(27,incoming.length()-27);

			}
		}

		if(application == "base24")
		{
	
		  msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
			//response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			//response_0210_generic_from_iso +=delimiter;

		}




		bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

		//Se saca el message type de retorno para enviarse
		int j = 0;

		for(j = 0; j < 128; j++)
		{
			if(bit_set_fiedl(j,1) == "1")
			{
	
				switch (field_length.RetornoFieldNumber(j+1))
				{
				case LLLVAR:
			
					lllvar	= msg_for_processing(next_field,LLLVAR);
					var_field = atoi(lllvar);
					next_field = next_field+LLLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				//	response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
					if((j+1) == 125)
						retorno_125 = msg_for_processing(next_field,var_field);
				//	response_0210_generic_from_iso +=delimiter;
					next_field = next_field+var_field;
				

					break;
		
				case LLVAR:
				
					llvar	= msg_for_processing(next_field,LLVAR);
					var_field = atoi(llvar);
					next_field = next_field+LLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing(next_field,var_field);
					response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
					//response_0210_generic_from_iso +=delimiter;
					next_field = next_field+var_field;
					break;
			
				case FIXED:
				
				
					next_field = next_field+iso_field_length[j+1];
					if((j+1 != 0) && (j+1 != 1))
					{
					
					
						if(j+1 == 53)
						{
							msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
							//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						//response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						//	response_0210_generic_from_iso +=delimiter;
						}
						else
						{
							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
							//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							//response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							//response_0210_generic_from_iso +=delimiter;
						}
					}
			
				}
			}
		
		}

	}
	else // BitMap de 16
	{
			//Se crea los fields con valores fijos
		 RWTValVector<int> iso_field_length(65,0);
	      
		iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
		iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
		iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
		iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;   iso_field_length[19] = 3;	
		iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
		iso_field_length[28] = 9;   iso_field_length[30] = 32; 	iso_field_length[37] = 12; 
		iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
		iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
		iso_field_length[53] = 48;
	
	
		if(application == "base24")
		{
			iso_field_length[41] = 8;
		}

		if(application == "posterm")
		{
			iso_field_length[41] = 8;
		}

		

		if(application == "posterm")
		{

			msg_type_from_incming = incoming(7,4);

			response_0210_generic_from_iso += incoming(7,4);
		
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
			//response_0210_generic_from_iso +=delimiter;

			ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

			if (ascii_bit(0,1) == "7")
			{
				 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
				 hex_bit += "0000000000000000";
				 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
				 bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(19,incoming.length()-19);
			 

			}

			else
			{
				hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
				if(debug == 1)
		 
					 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
				bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(27,incoming.length()-27);

			}
		}

		if(application == "base24")
		{
	
		    msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16);
			msg_for_processing = incoming(34,incoming.length()-34);
			//response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		//	response_0210_generic_from_iso +=delimiter;

		}




		bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

		//Se saca el message type de retorno para enviarse
		int j = 0;

		for(j = 0; j < 65; j++)
		{
			if(bit_set_fiedl(j,1) == "1")
			{
	
				switch (field_length.RetornoFieldNumber(j+1))
				{
				case LLLVAR:
			
					lllvar	= msg_for_processing(next_field,LLLVAR);
					var_field = atoi(lllvar);
					next_field = next_field+LLLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					next_field = next_field+var_field;
				

					break;
		
				case LLVAR:
				
					llvar	= msg_for_processing(next_field,LLVAR);
					var_field = atoi(llvar);
					next_field = next_field+LLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					next_field = next_field+var_field;
					break;
			
				case FIXED:
				
				
					next_field = next_field+iso_field_length[j+1];
					if((j+1 != 0) && (j+1 != 1))
					{
					
					
						if(j+1 == 53)
						{
							msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
						}
						else
						{
							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						}
					}
			
				}
			}
		
		}
	}//Termina Else
 

}

void MQUtility::ShowFieldIso8583B24Format(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{



//	response_0210_generic_from_iso = "";
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if ((incoming(18,1) == "8") || (incoming(18,1) == "9") || (incoming(18,1) == "A")
		|| (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "D")
		|| (incoming(18,1) == "E") || (incoming(18,1) == "F"))
	{

		//Se crea los fields con valores fijos
		 RWTValVector<int> iso_field_length(129,0);
	      
		iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
		iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
		iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
		iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;   iso_field_length[19] = 3;	
		iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
		iso_field_length[28] = 9;   iso_field_length[30] = 32; 	iso_field_length[37] = 12; 
		iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
		iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
		iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
		iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
		iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
		iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
		iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
		iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
		iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
		iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
		if(application == "base24")
		{
			iso_field_length[41] = 16;
		}

		if(application == "posterm")
		{
			iso_field_length[41] = 8;
		}

	
		if(application == "posterm")
		{

			msg_type_from_incming = incoming(7,4);

			//response_0210_generic_from_iso += incoming(7,4);
		
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		//	response_0210_generic_from_iso +=delimiter;

			ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

			if (ascii_bit(0,1) == "7")
			{
				 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
				 hex_bit += "0000000000000000";
				 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
				 bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(19,incoming.length()-19);
			 

			}

			else
			{
				hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
				if(debug == 1)
		 
					 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
				bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(27,incoming.length()-27);

			}
		}

		if(application == "base24")
		{
	
		  msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
		//	response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			//response_0210_generic_from_iso +=delimiter;

		}




		bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

		//Se saca el message type de retorno para enviarse
		int j = 0;

		for(j = 0; j < 128; j++)
		{
			if(bit_set_fiedl(j,1) == "1")
			{
	
				switch (field_length.RetornoFieldNumber(j+1))
				{
				case LLLVAR:
			
					lllvar	= msg_for_processing(next_field,LLLVAR);
					var_field = atoi(lllvar);
					next_field = next_field+LLLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					//response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
					if((j+1) == 125)
						retorno_125 = msg_for_processing(next_field,var_field);
				//	response_0210_generic_from_iso +=delimiter;
					next_field = next_field+var_field;
				

					break;
		
				case LLVAR:
				
					llvar	= msg_for_processing(next_field,LLVAR);
					var_field = atoi(llvar);
					next_field = next_field+LLVAR;
					if(debug == 1)
					{
						//ReturnIso8583FieldValue(msg_input, j+1  ,	msg_for_processing(next_field,var_field));
						
						

						if((j+1) == 2)
						{
							RWCString pan_pci = msg_for_processing(next_field,var_field);
							
							pan_pci= pan_pci.replace(6,8,"********");
							
							ReturnIso8583FieldValue(msg_input, j+1  ,	pan_pci);
					
						}
						else
						if((j+1) == 35)
						{

							 
							RWCString iso_field_value_35 = msg_for_processing(next_field,var_field);
							RWCTokenizer next(iso_field_value_35);
							RWCString token;
							RWCString pan_number	 = "";
							RWCString  resto_track2	= "";
							int counter = 0;
							RWCString valor_exdate_from_track2;

							if(iso_field_value_35.contains("=") )
							{



								while(!(token=next("=")).isNull())
								{
	
		
									if (counter == 0)
									{
		
		
										pan_number = token;

									}
		
									if (counter == 1)
									{
		
		
										resto_track2 = token;

									}		
	
									counter ++;
								}


								//iso_field_value[2] = iso_field_value[2].replace(6,8,"********");

								pan_number = pan_number.replace(6,8,"********");
								resto_track2 = resto_track2.replace(0,20,"********************");

								//cout << "Valor de track2 " << pan_number+"="+resto_track2;
								ReturnIso8583FieldValue(msg_input, j+1  ,	pan_number+"="+resto_track2);
					
							}
							else
							if(iso_field_value_35.contains("D") )
							{



								while(!(token=next("D")).isNull())
								{
	
		
									if (counter == 0)
									{
		
		
										pan_number  = token;

									}
		
									if (counter == 1)
									{
		
		
										resto_track2 =token;

									}		
	
									counter ++;
								
								}

							}


							//cout << "Valor de track2 " << msg_for_processing(next_field,var_field) << endl;
						}
						else
						{

						    ReturnIso8583FieldValue(msg_input, j+1  ,	msg_for_processing(next_field,var_field));
					


						}
					}
					next_field = next_field+var_field;
					break;
			
				case FIXED:
				
				
					next_field = next_field+iso_field_length[j+1];
					if((j+1 != 0) && (j+1 != 1))
					{
					
					
						if(j+1 == 53)
						{
							msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
							//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
							response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						//	response_0210_generic_from_iso +=delimiter;
						}
						else
						if(j+1 == 14)
						{
							//msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,"****");	
						
						}
				
						else
						{
							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
							//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							//response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							//response_0210_generic_from_iso +=delimiter;
						}
					}
			
				}
			}
		
		}

	}
	else // BitMap de 16
	{
			//Se crea los fields con valores fijos
		 RWTValVector<int> iso_field_length(65,0);
	      
		iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
		iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
		iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
		iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;   iso_field_length[19] = 3;	
		iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
		iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
		iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
		iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
		iso_field_length[53] = 48;
	
	
		if(application == "base24")
		{
			iso_field_length[41] = 16;
		}

		if(application == "posterm")
		{
			iso_field_length[41] = 8;
		}

		

		if(application == "posterm")
		{

			msg_type_from_incming = incoming(7,4);

		//	response_0210_generic_from_iso += incoming(7,4);
		
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
			//response_0210_generic_from_iso +=delimiter;

			ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

			if (ascii_bit(0,1) == "7")
			{
				 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
				 hex_bit += "0000000000000000";
				 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
				 bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(19,incoming.length()-19);
			 

			}

			else
			{
				hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
				if(debug == 1)
		 
					 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
				bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(27,incoming.length()-27);

			}
		}

		if(application == "base24")
		{
	
		    msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16);
			msg_for_processing = incoming(34,incoming.length()-34);
		//	response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		//	response_0210_generic_from_iso +=delimiter;

		}




		bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

		//Se saca el message type de retorno para enviarse
		int j = 0;

		for(j = 0; j < 65; j++)
		{
			if(bit_set_fiedl(j,1) == "1")
			{
	
				switch (field_length.RetornoFieldNumber(j+1))
				{
				case LLLVAR:
			
					lllvar	= msg_for_processing(next_field,LLLVAR);
					var_field = atoi(lllvar);
					next_field = next_field+LLLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					next_field = next_field+var_field;
				

					break;
		
				case LLVAR:
				
					llvar	= msg_for_processing(next_field,LLVAR);
					var_field = atoi(llvar);
					next_field = next_field+LLVAR;

					if(debug == 1)
					{
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					   // if((j+1) == 35)
						//	cout << "Valor de track2 " << msg_for_processing(next_field,var_field) << endl;
					}
						
					next_field = next_field+var_field;
					break;
			
				case FIXED:
				
				
					next_field = next_field+iso_field_length[j+1];
					if((j+1 != 0) && (j+1 != 1))
					{
					
					
						if(j+1 == 53)
						{
							msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
						}
						else
						if(j+1 == 14)
						{
							//msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,"****");	
						
						}
					
						else
						{
							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						}
					}
			
				}
			}
		
		}
	}//Termina Else
 




}



RWCString MQUtility::getTrack2FromGenericVarAndAcc( RWCString incoming)
{

	//cout << "Valor de incoming > " << incoming << endl;

	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
//	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;

	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
		
								
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
			//cout << "Valor de field_number " << field_number << endl;
			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((atoi(field_number) == 35))
			{
				//cout << "valor de valor_field > " << valor_field << endl;
				msg_reponse_with_tcp_header += valor_field;
			}
				
			if ((atoi(field_number) == 102))
			{
				//cout << "valor de valor_field > " << valor_field << endl;
				msg_reponse_with_tcp_header += ",";
				msg_reponse_with_tcp_header += valor_field;
			}
		}
			
	}

	
	return msg_reponse_with_tcp_header;
}



RWCString MQUtility::getTrack2FromGenericVar( RWCString incoming)
{

	//cout << "Valor de incoming > " << incoming << endl;

	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
//	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;

	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
		
								
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		

			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((atoi(field_number) == 35))
			{
				//cout << "valor de valor_field > " << valor_field << endl;
				msg_reponse_with_tcp_header = valor_field;
			}
				
			
		}
			
	}

	
	return msg_reponse_with_tcp_header;
}

RWCString MQUtility::getTrack2FromGenericVar1C( RWCString incoming)
{

	//cout << "Valor de incoming > " << incoming << endl;

	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
//	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;

	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
														
						
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		

			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((atoi(field_number) == 35))
			{
				//cout << "valor de valor_field > " << valor_field << endl;
				msg_reponse_with_tcp_header = valor_field;
			}
				
			
		}
			
	}

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::GetFieldFromBtransFormat( RWCString incoming, int value_field)
{


	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;

	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
					
								
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		

			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((atoi(field_number) == value_field))
			{
				//cout << "valor de valor_field > " << valor_field << endl;
				msg_reponse_with_tcp_header = valor_field;
			}
				
			
		}
			
	}

	
	return msg_reponse_with_tcp_header;
}
RWCString MQUtility::GetFieldFromBtransFormat1C( RWCString incoming, int value_field)
{


	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(RWCString('\x1C'))).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;

	while(!(token=next2(RWCString('\x1C'))).isNull())
	{	
	
		F1 = token; 
		if( count == 0)
		{
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);

			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
											
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		

			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				iso_field[atoi(field_number)] = valor_field;
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((atoi(field_number) == value_field))
			{
				//cout << "valor de valor_field > " << valor_field << endl;
				msg_reponse_with_tcp_header = valor_field;
			}
				
			
		}
			
	}

	
	return msg_reponse_with_tcp_header;
}


RWCString MQUtility::SetFieldFromBtransFormat( RWCString incoming, int value_field,RWCString input_value)
{


	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCString delimiter = ",";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;

	while(!(token=next2(",")).isNull())
	{	
	
		F1 = token; 

		//cout << "Valor de F1 > " << F1 << endl;
		if( count == 0)
		{
			valor_field = F1;
			testiso200.setIsoMsg8583All("00001", valor_field);
			msg_reponse_with_tcp_header+=F1;
			msg_reponse_with_tcp_header+=delimiter;
			iso_field [1] = valor_field;
			field_number = "00001";
			count++;
		}	
		else
		{
											
			field_number = F1(0,MSG_FIELD);
			valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		

			if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
			{
				if(field_number != "00011")
				{
					iso_field[atoi(field_number)] = valor_field;
					msg_reponse_with_tcp_header+=F1;
					msg_reponse_with_tcp_header+=delimiter;
				}
				field_count = atoi(field_number); 
			}
			else
			{
				cout << "Problemas en uno de los campos recibidos" << endl;
				cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				break;
			}

			if ((atoi(field_number) == value_field))
			{
				msg_reponse_with_tcp_header+=field_number+input_value;
				msg_reponse_with_tcp_header+=delimiter;
			}
				
			
		}
			
	}

	
	return msg_reponse_with_tcp_header;
}

void MQUtility::showFieldFromGenericVar( RWCString incoming,int debug)
{

//	cout << "valor de incoming " << incoming << endl;
	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
//	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;


	for (i=0; i<counter_token; i++)
	{
		while(!(token=next2(",")).isNull())
		{	
	
			F1 = token; 
			if( count == 0)
			{

				if(debug == 1)
						cout << endl;
				valor_field = F1;
			//testiso200.setIsoMsg8583All("00001", valor_field);

				iso_field [1] = valor_field;
				field_number = "00001";
				count++;
			}	
			else
			{
												
				field_number = F1(0,MSG_FIELD);
				valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		

				if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
				{
					iso_field[atoi(field_number)] = valor_field;
					field_count = atoi(field_number); 

				}
				else
				{
					cout << "Problemas en uno de los campos recibidos" << endl;
					cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				}

					
			
			
			
			}
			
			if(debug == 1)
				cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
		}
	}

	
	//msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);

	//cout << "Valor de msg_reponse_with_tcp_header > " << msg_reponse_with_tcp_header << endl;
	
	//return msg_reponse_with_tcp_header;
}


void MQUtility::ShowFieldIso8583B24(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	//cout << endl;
//cout << "Valor de incoming > :" << incoming << endl;
//cout << endl;
	
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[24] = 3;  iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	//cout << endl;
	//cout << "Valor de incoming(18,1)" << incoming(18,1) << endl;
	//cout << endl;
	if( (application == "base24") && ( (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F") ))
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}
	else
	{
		msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,16)+"0000000000000000";
		msg_for_processing = incoming(34,incoming.length()-34);
		//response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		//response_0210_generic_from_iso +=delimiter;

		//cout << "Dentro de Else " << endl;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				if((j+1) == 125)
					retorno_125 = msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 53)
					{
						msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						if(debug == 1)

							ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
						//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						response_0210_generic_from_iso +=delimiter;
					}
					else
					{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						//response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	return retorno_125;

}

RWCString MQUtility::SetBtransFormatFromB24Format(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	//cout << endl;
	//cout << "Valor de incomimg > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString response_0210_generic_from_iso;
	RWCString  msg_processing_053 ;
	RWCString  field_53_exist;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;   iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	//if( (application == "base24") && ( (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F") ))
	if( application == "base24")
	{
	
		if(  (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F")  
			   || (incoming(18,1) == "8") ||  (incoming(18,1) == "9"))
		{

		
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

		}
		else
		{
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16)+"0000000000000000";
			msg_for_processing = incoming(34,incoming.length()-34);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

	
		}
	}





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
//				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);

				if((j+1) == 48)
					response_0210_generic_from_iso +="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					response_0210_generic_from_iso +="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					response_0210_generic_from_iso +="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					response_0210_generic_from_iso +="00063"+msg_for_processing(next_field,var_field);

		
				if((j+1) == 120)
					response_0210_generic_from_iso +="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					response_0210_generic_from_iso +="00123"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 124)
					response_0210_generic_from_iso +="00124"+msg_for_processing(next_field,var_field);
			

				if((j+1) == 125)
					response_0210_generic_from_iso += "00125"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 127)
					response_0210_generic_from_iso += "00127"+msg_for_processing(next_field,var_field);
								
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					response_0210_generic_from_iso += "00002"+msg_for_processing(next_field,var_field);

				}
				
				if((j+1) == 32)
				{
					response_0210_generic_from_iso += "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					response_0210_generic_from_iso += "00035"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				/*
				if((j+1) >= 32)
				//if( field_53_exist == "0")
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

						//	cout << "00035"+test_pre << endl;
							response_0210_generic_from_iso +=delimiter;
			
							response_0210_generic_from_iso += "00035"+test_pre;
						}
					  
					}

					
				}
			*/

				if((j+1) == 100)
				{
					response_0210_generic_from_iso += "00100"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				//if((j+1) == 2)
				//{
				//}
				//else
					response_0210_generic_from_iso +=delimiter;
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso += "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
							
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 15)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00015"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
	
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 26)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00026"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 70)
					{

						if(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]) == "001")

						{
						
							//RWCString wkp = "96E2CBC424DCCEDD";
							RWCString wkp = "31793C9226C07495";
							response_0210_generic_from_iso +="00053"+wkp;
							response_0210_generic_from_iso +=delimiter;

						
						}
						
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00070"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;

						
					}			
		
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}	
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	cout << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}


int MQUtility::RetornoFieldNumberVersion1993(int incoming_field )
{

	int length_field = 0;

	if ((incoming_field == 2) || (incoming_field == 32) || (incoming_field == 33) || (incoming_field == 35)
		                      || (incoming_field == 43) || (incoming_field == 45) || (incoming_field == 56) || (incoming_field == 93) 
							  || (incoming_field == 94) || (incoming_field == 100)
							  || (incoming_field == 101) || (incoming_field == 102) || (incoming_field == 103))
	{
		length_field = 2;

	}
	else
	if ((incoming_field == 48) || (incoming_field == 44) || (incoming_field == 54) || (incoming_field == 57)
		                       || (incoming_field == 58) || (incoming_field == 59) || (incoming_field == 60)
							   || (incoming_field == 61) || (incoming_field == 62) || (incoming_field == 63) || (incoming_field == 118)
							   || (incoming_field == 119) || (incoming_field == 120)|| (incoming_field == 123)
							   || (incoming_field == 124) || (incoming_field == 125) || (incoming_field == 126) || (incoming_field == 127))
	{
		length_field = 3;
	}
	else
	{
		length_field = 0;
	}

	return length_field;

	
}



RWCString MQUtility::SetBtransFormatFromB24Format1C(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	//cout << endl;
	//cout << "Valor de incomimg > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString response_0210_generic_from_iso;
	RWCString  msg_processing_053 ;
	RWCString  field_53_exist;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = '\x1C';
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;   iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	//if( (application == "base24") && ( (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F") ))
	if( application == "base24")
	{
	
		if(  (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F")  
			   || (incoming(18,1) == "8") ||  (incoming(18,1) == "9"))
		{

		
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

		}
		else
		{
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16)+"0000000000000000";
			msg_for_processing = incoming(34,incoming.length()-34);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

	
		}
	}





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
//				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);

				if((j+1) == 48)
					response_0210_generic_from_iso +="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					response_0210_generic_from_iso +="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					response_0210_generic_from_iso +="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					response_0210_generic_from_iso +="00063"+msg_for_processing(next_field,var_field);

		
				if((j+1) == 120)
					response_0210_generic_from_iso +="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					response_0210_generic_from_iso +="00123"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 124)
					response_0210_generic_from_iso +="00124"+msg_for_processing(next_field,var_field);
			

				if((j+1) == 125)
					response_0210_generic_from_iso += "00125"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 127)
					response_0210_generic_from_iso += "00127"+msg_for_processing(next_field,var_field);
								
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					//response_0210_generic_from_iso += "00002"+msg_for_processing(next_field,var_field);
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					response_0210_generic_from_iso += "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					response_0210_generic_from_iso += "00035"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				/*
				if((j+1) >= 32)
				//if( field_53_exist == "0")
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

						//	cout << "00035"+test_pre << endl;
							response_0210_generic_from_iso +=delimiter;
			
							response_0210_generic_from_iso += "00035"+test_pre;
						}
					  
					}

					
				}
			*/

				if((j+1) == 100)
				{
					response_0210_generic_from_iso += "00100"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				if((j+1) == 2)
				{
				}
				else
					response_0210_generic_from_iso +=delimiter;
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso += "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
							
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 15)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00015"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
	
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 70)
					{

						if(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]) == "001")

						{
						
							//RWCString wkp = "96E2CBC424DCCEDD";
							RWCString wkp = "31793C9226C07495";
							response_0210_generic_from_iso +="00053"+wkp;
							response_0210_generic_from_iso +=delimiter;

						
						}
						
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00070"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;

						
					}			
		
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}	
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	cout << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetBtransFormatFromB24FormatNOPB(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	//cout << endl;
	//cout << "Valor de incomimg > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString response_0210_generic_from_iso;
	RWCString  msg_processing_053 ;
	RWCString  field_53_exist;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;   iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	//if( (application == "base24") && ( (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F") ))
	if( application == "base24")
	{
	
		if(  (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F")  
			   || (incoming(18,1) == "8") ||  (incoming(18,1) == "9"))
		{

		
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

		}
		else
		{
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16)+"0000000000000000";
			msg_for_processing = incoming(34,incoming.length()-34);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

	
		}
	}





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
//				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);

				if((j+1) == 48)
					response_0210_generic_from_iso +="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					response_0210_generic_from_iso +="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					response_0210_generic_from_iso +="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					response_0210_generic_from_iso +="00063"+msg_for_processing(next_field,var_field);

		
				if((j+1) == 120)
					response_0210_generic_from_iso +="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					response_0210_generic_from_iso +="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					response_0210_generic_from_iso += "00125"+msg_for_processing(next_field,var_field);
			
								
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					//response_0210_generic_from_iso += "00002"+msg_for_processing(next_field,var_field);
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					response_0210_generic_from_iso += "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					response_0210_generic_from_iso += "00035"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				/*
				if((j+1) >= 32)
				//if( field_53_exist == "0")
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

						//	cout << "00035"+test_pre << endl;
							response_0210_generic_from_iso +=delimiter;
			
							response_0210_generic_from_iso += "00035"+test_pre;
						}
					  
					}

					
				}
			*/

				if((j+1) == 100)
				{
					response_0210_generic_from_iso += "00100"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				if((j+1) == 2)
				{
				}
				else
					response_0210_generic_from_iso +=delimiter;
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso += "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
							
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 15)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00015"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
	
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 70)
					{

						/*
						if(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]) == "001")

						{
						
							//RWCString wkp = "96E2CBC424DCCEDD";
							RWCString wkp = "31793C9226C07495";
							response_0210_generic_from_iso +="00053"+wkp;
							response_0210_generic_from_iso +=delimiter;

						
						}
						*/
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00070"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;

						
					}			
		
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}	
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	cout << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}


RWCString MQUtility::SetBtransFormatFromB24FormatNOPB1C(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	//cout << endl;
	//cout << "Valor de incomimg > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString response_0210_generic_from_iso;
	RWCString  msg_processing_053 ;
	RWCString  field_53_exist;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = '\x1C';
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;   iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	//if( (application == "base24") && ( (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F") ))
	if( application == "base24")
	{
	
		if(  (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F")  
			   || (incoming(18,1) == "8") ||  (incoming(18,1) == "9"))
		{

		
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

		}
		else
		{
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16)+"0000000000000000";
			msg_for_processing = incoming(34,incoming.length()-34);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

	
		}
	}





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
//				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);

				if((j+1) == 48)
					response_0210_generic_from_iso +="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					response_0210_generic_from_iso +="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					response_0210_generic_from_iso +="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					response_0210_generic_from_iso +="00063"+msg_for_processing(next_field,var_field);

		
				if((j+1) == 120)
					response_0210_generic_from_iso +="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					response_0210_generic_from_iso +="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					response_0210_generic_from_iso += "00125"+msg_for_processing(next_field,var_field);
			
								
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					//response_0210_generic_from_iso += "00002"+msg_for_processing(next_field,var_field);
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					response_0210_generic_from_iso += "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					response_0210_generic_from_iso += "00035"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				/*
				if((j+1) >= 32)
				//if( field_53_exist == "0")
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

						//	cout << "00035"+test_pre << endl;
							response_0210_generic_from_iso +=delimiter;
			
							response_0210_generic_from_iso += "00035"+test_pre;
						}
					  
					}

					
				}
			*/

				if((j+1) == 100)
				{
					response_0210_generic_from_iso += "00100"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				if((j+1) == 2)
				{
				}
				else
					response_0210_generic_from_iso +=delimiter;
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso += "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
							
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 15)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00015"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
	
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 70)
					{

						/*
						if(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]) == "001")

						{
						
							//RWCString wkp = "96E2CBC424DCCEDD";
							RWCString wkp = "31793C9226C07495";
							response_0210_generic_from_iso +="00053"+wkp;
							response_0210_generic_from_iso +=delimiter;

						
						}
						*/
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00070"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;

						
					}			
		
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}	
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	cout << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}




RWCString MQUtility::SetBtransFormatFromB24FormaVbv(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	//cout << endl;
	//cout << "Valor de incomimg > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  response_0210_generic_from_iso;
	RWCString  msg_processing_053 ;
	int  field_63_exist = 0;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;   iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	//if( (application == "base24") && ( (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F") ))
	if( application == "base24")
	{
	
		if(  (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F")  
			   || (incoming(18,1) == "8") ||  (incoming(18,1) == "9"))
		{

		
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

		}
		else
		{
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16)+"0000000000000000";
			msg_for_processing = incoming(34,incoming.length()-34);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;

	
		}
	}





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
//				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);

				/*
				if((j+1) == 48)
					response_0210_generic_from_iso +="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					response_0210_generic_from_iso +="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					response_0210_generic_from_iso +="00061"+msg_for_processing(next_field,var_field);

*/
				if((j+1) == 63)
				{
					field_63_exist = 1;
					RWCString field_63_completo;
					
					field_63_completo=msg_for_processing(next_field,var_field);
				
		
					if( (field_63_completo(25,1) == "B"))
					{
						field_63_completo = field_63_completo(33,1);
						response_0210_generic_from_iso+="00063"+field_63_completo;
						response_0210_generic_from_iso +=delimiter;

			
					}
					else
					{

						response_0210_generic_from_iso+="00063";
						response_0210_generic_from_iso +=delimiter;


					}
		
		
		

			

					
				}
		/*
				if((j+1) == 120)
					response_0210_generic_from_iso +="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					response_0210_generic_from_iso +="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					response_0210_generic_from_iso += "00125"+msg_for_processing(next_field,var_field);
			
			*/	
					if((j+1) == 125)
					{
						if(field_63_exist == 0)
						{
							response_0210_generic_from_iso +="00063";
							response_0210_generic_from_iso +=delimiter;
						}
					}
				
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			/*
				if((j+1) == 2)
				{
					//response_0210_generic_from_iso += "00002"+msg_for_processing(next_field,var_field);
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					response_0210_generic_from_iso += "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					response_0210_generic_from_iso += "00035"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}

  */
				/*
				if((j+1) >= 32)
				//if( field_53_exist == "0")
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

						//	cout << "00035"+test_pre << endl;
							response_0210_generic_from_iso +=delimiter;
			
							response_0210_generic_from_iso += "00035"+test_pre;
						}
					  
					}

					
				}
		

				if((j+1) == 100)
				{
					response_0210_generic_from_iso += "00100"+msg_for_processing(next_field,var_field);
					field_53_exist = "1";
				
				}
				
				if((j+1) == 2)
				{
				}
				else
					response_0210_generic_from_iso +=delimiter;
					*/
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso += "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
							
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				/*
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 15)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00015"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
	
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					
					*/
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j == 125)
					{
						if(field_63_exist == 1)
						{
							response_0210_generic_from_iso +="00063";
							response_0210_generic_from_iso +=delimiter;
						}
					}
				/*
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 70)
					{

					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00070"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;

						
					}			
		
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
					*/
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	cout << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}

/*

RWCString MQUtility::SetIso8583B24FromBanPais(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
//	RWCString  field_53_exist;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
//				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);

				if((j+1) == 48)
					response_0210_generic_from_iso +="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					response_0210_generic_from_iso +="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					response_0210_generic_from_iso +="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					response_0210_generic_from_iso +="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					response_0210_generic_from_iso +="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					response_0210_generic_from_iso +="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					response_0210_generic_from_iso += "00125"+msg_for_processing(next_field,var_field);
			
								
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					//response_0210_generic_from_iso += "00002"+msg_for_processing(next_field,var_field);
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					response_0210_generic_from_iso += "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					//response_0210_generic_from_iso += "00035"+msg_for_processing(next_field,var_field);
					track2_from_msg = msg_for_processing(next_field,var_field);
					field_53_exist = 1;;
				
				}
				
		
				if( (field_53_exist == 0) && ( (j+1) >= 32)  )
				{
					if( (pan_02.length() > 10) && (field_53_exist == 0) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

							track2_from_pan=test_pre;
						}
					  
					}

					
				}


				if((field_53_exist == 1)  && ( (j+1) == 35) ) 
				{
					response_0210_generic_from_iso +="00035"+track2_from_msg;
				}
				else
					response_0210_generic_from_iso +="00035"+track2_from_pan;
			
			
			
				if((j+1) == 2)
				{
				}
				else
					response_0210_generic_from_iso +=delimiter;
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						processing_banpais = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(processing_banpais == "203000")
						{
							new_processing_banpais = "223000";
						}
						else
						if(processing_banpais == "313000")
						{
							new_processing_banpais = "303000";
						}
					
						else
						{
							new_processing_banpais = "303000";
						}
					
						response_0210_generic_from_iso +="00003"+new_processing_banpais;
						response_0210_generic_from_iso +=delimiter;
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
		
			
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	cout << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}

  */
RWCString MQUtility::SetIso8583B24FromBanPaisB24(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
//	RWCString  field_53_exist;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
		
				if( (field_53_exist == 0) && ( (j+1) >= 32)  )
				{
					if( (pan_02.length() > 10) && (field_53_exist == 0) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

							iso_field_value[35]=  "00035"+test_pre;
						}
					  
					}

					
				}


			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						processing_banpais = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(processing_banpais == "203000")
						{
							new_processing_banpais = "223000";
						}
						else
						if(processing_banpais == "313000")
						{
							new_processing_banpais = "303000";
						}
						else
						if(processing_banpais == "013030")
						{
							new_processing_banpais = "013030";
						}
						else
							new_processing_banpais=processing_banpais;
					
					
					
						iso_field_value[3]="00003"+new_processing_banpais;	
						
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}

 
	response_0210_generic_from_iso = "0200,";
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
		


	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583B24FromVicanaToB24(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 8;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 54)
				iso_field_value[54]="00054"+msg_for_processing(next_field,var_field);
			


				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);

				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
		/*
				if( (field_53_exist == 0) && ( (j+1) >= 32)  )
				{
					if( (pan_02.length() > 10) && (field_53_exist == 0) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

							iso_field_value[35]=  "00035"+test_pre;
						}
					  
					}

					
				}
*/

			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						

					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 26)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[26]="00026"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{

						//if(debug == 1)
						//	ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[52]="00052"+RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8); 
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8));
						
						//iso_field_value[52]="00052"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}	
				}
			
			}
		}
		
	}

	
	RWCString field_48_rw = "4549121212         01000001";
	RWCString field_60_rw = "BPPRCER3+0000000";
	RWCString field_61_rw = "        00000000000";
	RWCString field_125_rw = "  HOSTB24 10";
	RWCString field_127_rw = "                               Q1"+iso_field_value[11](5,6)
		+"019822222221C000000000000C000000000000                                        ";


/*
	if(iso_field_value[14].length() == 0)
	{

		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		char pan_number[100]	 = {""};
		char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		else
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		else
		{
			strcpy(resto_track2 , "0000");

		}

		
		valor_exdate_from_track2 = resto_track2;
		iso_field_value[14] = "00014"+valor_exdate_from_track2(0,4);


	}

*/

	iso_field_value[7] = "00007"+set_tcp_header.SetMsgField(7);

	if(iso_field_value[37].length() == 0)
		iso_field_value[37] = "00037"+iso_field_value[11](5,6)+iso_field_value[11](5,6);
	

	if(iso_field_value[48].length() == 0)
		iso_field_value[48] = "00048"+field_48_rw;

	if(iso_field_value[60].length() == 0)
		iso_field_value[60] = "00060"+field_60_rw;

	if(iso_field_value[61].length() == 0)
		iso_field_value[61] = "00061"+field_61_rw;

	if(iso_field_value[125].length() == 0)
		iso_field_value[125] = "00125"+field_125_rw;

	/*
	if(iso_field_value[127].length() == 0)
		iso_field_value[127] = "00127"+field_127_rw;
*/

	if (strcmp(msg_type,"0200") == 0)
	
		response_0210_generic_from_iso = "0200,";


	if (strcmp(msg_type,"0420") == 0)
	{
	
		response_0210_generic_from_iso = "0420,";

		iso_field_value[11] = "00011"+set_tcp_header.SetMsgField(11);
	}
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
 
    response_0210_generic_from_iso = set_tcp_header.setMapIsoPosTermFromGeneric(response_0210_generic_from_iso,"base24","ISO025000050", 0);
		

	return response_0210_generic_from_iso;

}

RWCString MQUtility::GetIso8583FieldB24(RWCString incoming , char *msg_type, 
										          int debug, RWCString application,int input_field)
{


	RWCString  hex_bit = "";
	RWCString  field90 = "";
	RWCString  output_field = "";
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 8;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 54)
				iso_field_value[54]="00054"+msg_for_processing(next_field,var_field);
			


				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);

				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
		
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
		
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(input_field == 11)
					{
						if(j+1 == 11)
						{

							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

							iso_field_value[input_field] = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							output_field = iso_field_value[input_field];
				
						}
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{

					
						iso_field_value[52]="00052"+RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8); 
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8));
						
					}
					if(input_field == 90)
					{
						if(j+1 == 90)
						{

							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
							iso_field_value[input_field]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							output_field = iso_field_value[input_field];
						}
					}
				}
			
			}
		}
		
	}



//	iso_field_value[7] = "00007"+set_tcp_header.SetMsgField(7);


	if (strcmp(msg_type,"0200") == 0)
	
		response_0210_generic_from_iso = "0200,";


	if (strcmp(msg_type,"0420") == 0)
	
		response_0210_generic_from_iso = "0420,";

	/*
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 */
 
    //response_0210_generic_from_iso = set_tcp_header.setMapIsoPosTermFromGeneric(response_0210_generic_from_iso,"base24","ISO025000050", 0);
		
	
	return output_field;

}


RWCString MQUtility::GetIso8583FieldB24(RWCString incoming , char *msg_type, 
										          int debug, RWCString application,int input_field,int input_field2,int input_field3)
{


	RWCString  hex_bit = "";
	RWCString  field90 = "";
	RWCString  output_field = "";
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 8;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    bit_map_from_msg   = incoming(18,1);


		if(bit_map_from_msg   < "A")
		{
		
		 
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16)+"0000000000000000";

		//	cout << "Valor de bit_map_from_msg " << bit_map_from_msg << endl;

			msg_for_processing = incoming(34,incoming.length()-34);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;
		
		}
		else
		{
		
		
			msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
			response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			response_0210_generic_from_iso +=delimiter;
		}
	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 54)
				iso_field_value[54]="00054"+msg_for_processing(next_field,var_field);
			


				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);

				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
		
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
		
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if((input_field == 11) && (input_field != 0))
					{
						if(j+1 == 11)
						{

							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

							iso_field_value[11] = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							output_field += iso_field_value[11];
				
						}
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}


					if((input_field2 == 37)  && (input_field2 != 0))
					{
						if(j+1 == 37)
						{

							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

							iso_field_value[37] = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							output_field += iso_field_value[37];
				
						}
					}

					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{

					
						iso_field_value[52]="00052"+RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8); 
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8));
						
					}
					if(input_field == 90)
					{
						if(j+1 == 90)
						{

							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
							iso_field_value[input_field]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							output_field = iso_field_value[input_field];
						}
					}
				}
			
			}
		}
		
	}


	if (strcmp(msg_type,"0200") == 0)
	
		response_0210_generic_from_iso = "0200,";


	if (strcmp(msg_type,"0420") == 0)
	
		response_0210_generic_from_iso = "0420,";

 
		
	
	return output_field+"000000";

}




RWCString MQUtility::SetIso8583Msg0421FromB24Format(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field90	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 8;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 54)
				iso_field_value[54]="00054"+msg_for_processing(next_field,var_field);
			


				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);

				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
		
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
		
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{

					
						iso_field_value[52]="00052"+RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8); 
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , RetornoAsciiComplete(msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]),8));
						
					}
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//field90 = iso_field_value[input_field];
					}	
				}
			
			}
		}
		
	}



	//iso_field_value[11] = "00011"+set_tcp_header.SetMsgField(11);


	if (strcmp(msg_type,"0200") == 0)
	
		response_0210_generic_from_iso = "0200,";


	if (strcmp(msg_type,"0420") == 0)
	
		response_0210_generic_from_iso = "0421,";

	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
 
    response_0210_generic_from_iso = set_tcp_header.setMapIsoPosTermFromGeneric(response_0210_generic_from_iso,"base24","ISO025000050", 0);
		
	
	return response_0210_generic_from_iso;

}


void MQUtility::ShowFieldIso8583B24ForPostBridge(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

//	response_0210_generic_from_iso = "";
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if ((incoming(18,1) == "8") || (incoming(18,1) == "9") || (incoming(18,1) == "A")
		|| (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "D")
		|| (incoming(18,1) == "E") || (incoming(18,1) == "F"))
	{

		//Se crea los fields con valores fijos
		 RWTValVector<int> iso_field_length(129,0);
	      
		iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
		iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
		iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
		iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;   iso_field_length[19] = 3;	
		iso_field_length[22] = 3;	iso_field_length[23] = 3;   iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
		iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
		iso_field_length[38] = 6;   iso_field_length[39] = 2;   iso_field_length[40] = 3; 	iso_field_length[42] = 15;  
		iso_field_length[42] = 15; iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
		iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
		iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
		iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
		iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
		iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
		iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
		iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
		iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
		if(application == "base24")
		{
			iso_field_length[41] = 8;
		}

		if(application == "posterm")
		{
			iso_field_length[41] = 8;
		}

	
		if(application == "posterm")
		{

			msg_type_from_incming = incoming(7,4);

			//response_0210_generic_from_iso += incoming(7,4);
		
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		//	response_0210_generic_from_iso +=delimiter;

			ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

			if (ascii_bit(0,1) == "7")
			{
				 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
				 hex_bit += "0000000000000000";
				 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
				 bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(19,incoming.length()-19);
			 

			}

			else
			{
				hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
				if(debug == 1)
		 
					 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
				bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(27,incoming.length()-27);

			}
		}

		if(application == "base24")
		{
	
		  msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,32);
			msg_for_processing = incoming(50,incoming.length()-50);
		//	response_0210_generic_from_iso += incoming(14,4);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
			//response_0210_generic_from_iso +=delimiter;

		}




		bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

		//Se saca el message type de retorno para enviarse
		int j = 0;

		for(j = 0; j < 128; j++)
		{
			if(bit_set_fiedl(j,1) == "1")
			{
	
				switch (field_length.RetornoFieldNumber(j+1))
				{
				case LLLVAR:
			
					lllvar	= msg_for_processing(next_field,LLLVAR);
					var_field = atoi(lllvar);
					next_field = next_field+LLLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					if((j+1) == 125)
						retorno_125 = msg_for_processing(next_field,var_field);
					next_field = next_field+var_field;
				

					break;
		
				case LLVAR:
				
					llvar	= msg_for_processing(next_field,LLVAR);
					var_field = atoi(llvar);
					next_field = next_field+LLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					next_field = next_field+var_field;
					break;
			
				case FIXED:
				
				
					next_field = next_field+iso_field_length[j+1];
					if((j+1 != 0) && (j+1 != 1))
					{
					
					
						if(j+1 == 53)
						{
							msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
							response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						}
						else
						{
							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						}
					}
			
				}
			}
		
		}

	}
	else // BitMap de 16
	{
			//Se crea los fields con valores fijos
		 RWTValVector<int> iso_field_length(65,0);
	      
		iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
		iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
		iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
		iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;   iso_field_length[19] = 3;	
		iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
		iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
		iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
		iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
		iso_field_length[53] = 48;
	
	
		if(application == "base24")
		{
			iso_field_length[41] = 8;
		}

		if(application == "posterm")
		{
			iso_field_length[41] = 8;
		}

		

		if(application == "posterm")
		{

			msg_type_from_incming = incoming(7,4);

		
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
	
			ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

			if (ascii_bit(0,1) == "7")
			{
				 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
				 hex_bit += "0000000000000000";
				 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
				 bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(19,incoming.length()-19);
			 

			}

			else
			{
				hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
				if(debug == 1)
		 
					 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
				bit_map_from_msg   = hex_bit;
				msg_for_processing = incoming(27,incoming.length()-27);

			}
		}

		if(application == "base24")
		{
	
		    msg_type_from_incming = incoming(14,4);
			bit_map_from_msg   = incoming(18,16);
			msg_for_processing = incoming(34,incoming.length()-34);
			if(debug == 1)
			ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
	
		}




		bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

		//Se saca el message type de retorno para enviarse
		int j = 0;

		for(j = 0; j < 65; j++)
		{
			if(bit_set_fiedl(j,1) == "1")
			{
	
				switch (field_length.RetornoFieldNumber(j+1))
				{
				case LLLVAR:
			
					lllvar	= msg_for_processing(next_field,LLLVAR);
					var_field = atoi(lllvar);
					next_field = next_field+LLLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					next_field = next_field+var_field;
				

					break;
		
				case LLVAR:
				
					llvar	= msg_for_processing(next_field,LLVAR);
					var_field = atoi(llvar);
					next_field = next_field+LLVAR;
					if(debug == 1)
						ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
					next_field = next_field+var_field;
					break;
			
				case FIXED:
				
				
					next_field = next_field+iso_field_length[j+1];
					if((j+1 != 0) && (j+1 != 1))
					{
					
					
						if(j+1 == 53)
						{
							msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
							if(debug == 1)

								ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
						}
						else
						{
							if(debug == 1)
								ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						}
					}
			
				}
			}
		
		}
	}//Termina Else
 

}


RWCString MQUtility::SetIso8583DiscoverFromB24Format(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 8;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				
				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]="00062"+msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
					
				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
			
			
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  "00100"+msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]="00019"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]="00024"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]="00052"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}

	RWCString field_19_rw = "214";
	RWCString field_24_rw = "100";
	RWCString field_61_rw = "0000000000100";
	RWCString field_62_rw = "000000000000";
	RWCString field_126_rw = "0   0"; 
	RWCString field_127_rw = "03051";

	if(iso_field_value[19].length() == 0)
		iso_field_value[19] = "00019"+field_19_rw;

	if(iso_field_value[24].length() == 0)
		iso_field_value[24] = "00024"+field_24_rw;

	if(iso_field_value[61].length() == 0)
		iso_field_value[61] = "00061"+field_61_rw;

	if(iso_field_value[62].length() == 0)
		iso_field_value[62] = "00062"+field_62_rw;

	
	if(iso_field_value[126].length() == 0)
		iso_field_value[126] = "00126"+field_126_rw;

	if(iso_field_value[127].length() == 0)
		iso_field_value[127] = "00127"+field_127_rw;


	
	if (msg_type_from_incming == "0200")
		
		response_0210_generic_from_iso = "0100,";

	if (msg_type_from_incming == "0400")
		
		response_0210_generic_from_iso = "0400,";



	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
    response_0210_generic_from_iso = set_tcp_header.SetMapIsoDiscoverFromGeneric(response_0210_generic_from_iso,"base24","", 0);
		

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso85830800DiscoverFromB24Format(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 8;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				
				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]="00062"+msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
					
				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
			
			
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  "00100"+msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]="00019"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]="00024"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]="00052"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}



	
	if (msg_type_from_incming == "0800")
		
		response_0210_generic_from_iso = "0810,";

	if (msg_type_from_incming == "0820")
		
		response_0210_generic_from_iso = "0830,";



	iso_field_value[39]="0003900";

	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
    response_0210_generic_from_iso = set_tcp_header.SetMapIsoDiscoverFromGeneric(response_0210_generic_from_iso,"base24","", 0);
		

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583DiscoverFromB24FormatWithParameters(RWCString incoming , char *msg_type, 
										          int debug, RWCString application,RWCString field_19_rw , RWCString field_24_rw,
												  RWCString field_61_rw, RWCString field_62_rw, RWCString field_127_rw)



{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 8;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				
				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]="00062"+msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);
/*
				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
*/			
					
				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
			
			
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  "00100"+msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]="00019"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]="00024"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
/*
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
*/
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]="00052"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}


	RWCString field_126_rw = "0    ";
	RWCString field_42_rw = "601101900692466";
	

	if( (iso_field_value[19].length() == 0)  && (field_19_rw.length() != 0))
		iso_field_value[19] = "00019"+field_19_rw;

	if(iso_field_value[24].length() == 0)
		iso_field_value[24] = "00024"+field_24_rw;

	if(iso_field_value[42].length() == 0)
		iso_field_value[42] = "00042"+field_42_rw;




	
	if((iso_field_value[2].length() == 0) && (iso_field_value[35].length() != 0))
	{

			
		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		char pan_number[100]	 = {""};
		char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		valor_exdate_from_track2 = pan_number;
		//expiration_date = valor_exdate_from_track2(0,4);

		if(iso_field_value[02].length() == 0)

		    iso_field_value[02] = "00002"+valor_exdate_from_track2(5,valor_exdate_from_track2.length()-5);
		


	}

	if ( (iso_field_value[22](5,2) == "01") && (iso_field_value[35].length() != 0))
	{

			
		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		char pan_number[100]	 = {""};
		char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		valor_exdate_from_track2 = pan_number;
		if(iso_field_value[02].length() == 0)

		    iso_field_value[02] = "00002"+valor_exdate_from_track2(5,valor_exdate_from_track2.length()-5);
		
		iso_field_value[35] = "";
		iso_field_value[25] = "";

	}

	if ( iso_field_value[22](5,2) == "90")
	{


		iso_field_value[22] = "00022022"; 
		iso_field_value[61] = "000610000000000700";



	}
	
	if ( iso_field_value[22](5,2) == "98")
	{


		iso_field_value[22] = "00022902"; 
		iso_field_value[35] = "";
		iso_field_value[61] = "000612030000000100";


	}
	if ( iso_field_value[22](5,3) == "012")
	{


		iso_field_value[61] = "000610000000000700";


	}


	if(iso_field_value[61].length() == 0)
		iso_field_value[61] = "00061"+field_61_rw;

	if(iso_field_value[62].length() == 0)
		iso_field_value[62] = "00062"+field_62_rw;

	if(iso_field_value[63].length() != 0)
	{
		//cout << " Valor de iso_field_value[63] " << iso_field_value[63] << endl;
		
		if( (iso_field_value[63](19,2) == "P1") && (iso_field_value[63](25,1) == "3"))
		{
			iso_field_value[126] = "001261"+iso_field_value[63](27,3)+" ";
			
		}
		else
		iso_field_value[126] = "00126"+field_126_rw;

		
		
		iso_field_value[63] = "";

	}
	
	
	if(iso_field_value[127].length() == 0)
		iso_field_value[127] = "00127"+field_127_rw;


	
	if (msg_type_from_incming == "0200")
		
		response_0210_generic_from_iso = "0100,";

	if (msg_type_from_incming == "0400")
		
		response_0210_generic_from_iso = "0400,";



	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
    response_0210_generic_from_iso = set_tcp_header.SetMapIsoDiscoverFromGeneric(response_0210_generic_from_iso,"base24","", 0);
		

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583DiscoverFromB24FormatWithParameters1C(RWCString incoming , char *msg_type, 
										          int debug, RWCString application,RWCString field_19_rw , RWCString field_24_rw,
												  RWCString field_61_rw, RWCString field_62_rw, RWCString field_127_rw)



{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = '\x1C';
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 8;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
			
				
				if((j+1) == 59)
					iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]="00062"+msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);
/*
				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
*/			
				
				
				if((j+1) == 126)
				{
					
					if (msg_type_from_incming == "0400")
					{}
					else
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
			
				}
				


				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}
				if((j+1) == 33)
				{
					iso_field_value[33]= "00033"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					iso_field_value[35]=  "00035"+msg_for_processing(next_field,var_field);
				
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  "00100"+msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]="00019"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]="00024"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
/*
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
*/
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]="00052"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}


	RWCString field_126_rw = "0    ";
	RWCString field_42_rw = "601101900692466";
	

	if( (iso_field_value[19].length() == 0)  && (field_19_rw.length() != 0))
		iso_field_value[19] = "00019"+field_19_rw;

	if(iso_field_value[24].length() == 0)
		iso_field_value[24] = "00024"+field_24_rw;

	if(iso_field_value[42].length() == 0)
		iso_field_value[42] = "00042"+field_42_rw;

//	if( iso_field_value[32].length() == 0)

		iso_field_value[32] = "00032000000";

//	if( iso_field_value[33].length() == 0)

		iso_field_value[33] = "00033000000";
/*
	if( iso_field_value[124].length() == 0)

		iso_field_value[124] = "0012400";

*/
	
	if((iso_field_value[2].length() == 0) && (iso_field_value[35].length() != 0))
	{

			
		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		char pan_number[100]	 = {""};
		char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		valor_exdate_from_track2 = pan_number;
		//expiration_date = valor_exdate_from_track2(0,4);

		if(iso_field_value[02].length() == 0)

		    iso_field_value[02] = "00002"+valor_exdate_from_track2(5,valor_exdate_from_track2.length()-5);
		


	}

	if ( (iso_field_value[22](5,2) == "01") && (iso_field_value[35].length() != 0))
	{

			
		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		char pan_number[100]	 = {""};
		char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		valor_exdate_from_track2 = pan_number;
		if(iso_field_value[02].length() == 0)

		    iso_field_value[02] = "00002"+valor_exdate_from_track2(5,valor_exdate_from_track2.length()-5);
		
		iso_field_value[35] = "";
		iso_field_value[25] = "";

	}

	if ( iso_field_value[22](5,2) == "90")
	{


		iso_field_value[22] = "00022022"; 
		iso_field_value[61] = "000610000000000700";



	}
	
	if ( iso_field_value[22](5,2) == "98")
	{


		iso_field_value[22] = "00022902"; 
		iso_field_value[35] = "";
		iso_field_value[61] = "000612030000000100";


	}
	if ( iso_field_value[22](5,3) == "012")
	{


		iso_field_value[61] = "000610000000000700";


	}


	if(iso_field_value[61].length() == 0)
		iso_field_value[61] = "00061"+field_61_rw;

	if(iso_field_value[62].length() == 0)
		iso_field_value[62] = "00062"+field_62_rw;

	if(iso_field_value[63].length() != 0)
	{
		//cout << " Valor de iso_field_value[63] " << iso_field_value[63] << endl;
		
		if( (iso_field_value[63](19,2) == "P1") && (iso_field_value[63](25,1) == "3"))
		{
			iso_field_value[126] = "001261"+iso_field_value[63](27,3)+" ";
			
		}
		else
		iso_field_value[126] = "00126"+field_126_rw;

		
		
		iso_field_value[63] = "";

	}
	
	
	if(iso_field_value[127].length() == 0)
		iso_field_value[127] = "00127"+field_127_rw;

	RWCString char1C = '\x1C';
	
	if (msg_type_from_incming == "0200")
		
		response_0210_generic_from_iso = "0100"+char1C;

	if (msg_type_from_incming == "0400")
	{
		
		response_0210_generic_from_iso = "0400"+char1C;
	
	
	}



	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
		
			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
    response_0210_generic_from_iso = set_tcp_header.SetMapIsoDiscoverFrom1C(response_0210_generic_from_iso,"base24","", 0);
		

	return response_0210_generic_from_iso;

}


/*

RWCString MQUtility::SetIso8583B24FromTransPlata0210(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
					field48_RW=msg_for_processing(next_field,var_field);
					//iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field48_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					//	cout << "Valor de primer_token :" << primer_token << endl;
					//	cout << "Valor de segundo_token :" << segundo_token << endl;

						
							RWCString test_pre=primer_token+"="+segundo_token(0,4);	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

					
							iso_field_value[35] = "00035"+test_pre;
					
					
					
							iso_field_value[14] = "00014"+segundo_token(0,4);
			
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
				iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
				//field63_RW=msg_for_processing(next_field,var_field);
		
				}




				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);

					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(msg_for_processing(next_field,var_field));
					int count2 = 0;
					
					while(!(token=next("=")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					//RWCString field_63_pagos = "& 0000300095! P1100016 "+primer_token+" ! P1200004 "+iso_field_value[14](5,4);
					//RWCString field_63_pagos = "& 0000300095! P800016 "+primer_token+"! P900004 "+iso_field_value[14](5,4);
					//iso_field_value[63] = "00063"+field_63_pagos;

					RWCString field_48_pagos = primer_token+"!"+iso_field_value[14](5,4);

					RWCString test_pre=field_48_pagos;

					char pre_test = '\x30';
					size_t test = 27-test_pre.length();
					test_pre.append(pre_test , test);

					iso_field_value[48] = "00048"+test_pre;
				//	cout << "Valor de test_pre > " << test_pre << endl;
				




				}
				
				if((j+1) >= 32)
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

				
							iso_field_value[35]= "00035"+test_pre;
						}
					  
					}

					
				}
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						processing_banpais = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						
						if(processing_banpais == "013030")
						{
							new_processing_banpais = "402020";
						}
					
						else
						{
							new_processing_banpais = "303000";
						}
					
						iso_field_value[3]="00003"+new_processing_banpais;
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						
						iso_field_value[38] = "00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1])+"0000";
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						
						RWCString doble_nine = "99";
						iso_field_value[39]="00039"+doble_nine;
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}
	response_0210_generic_from_iso = "0210,";
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
			//cout << j <<  " " << iso_field_value[j] << endl;

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 



	return response_0210_generic_from_iso;

}




  */

RWCString MQUtility::SetIso8583B24FromTransPlata0200Retiro(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  field63_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
					//field48_RW=msg_for_processing(next_field,var_field);
					//iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
					/*
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field48_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

						cout << "Valor de primer_token :" << primer_token << endl;
						cout << "Valor de segundo_token :" << segundo_token << endl;

						
							RWCString test_pre=primer_token+"="+segundo_token(0,4);	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

							iso_field_value[35] = "00035"+test_pre;
					
							iso_field_value[14] = "00014"+segundo_token(0,4);
					*/
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
					
					iso_field_value[63] = "00063& 0000300045!";
					
					//iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
					field63_RW=msg_for_processing(next_field,var_field);
			
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field63_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
						if (count2 == 2)
						{
							tercer_token= token;
						}
						count2++;
					}

						//cout << "Valor de segundo_token :" << segundo_token << ":" <<endl;
						//cout << "Valor de tercer_token :" << tercer_token << ":" << endl;

						
						RWCString test_pre=segundo_token(10,segundo_token.length()-11)+"="+tercer_token(10,tercer_token.length()-10);	

						char pre_test = '\x30';
						size_t test = 37-test_pre.length();
						test_pre.append(pre_test , test);

						iso_field_value[35] = "00035"+test_pre;
					
						iso_field_value[14] = "00014"+tercer_token(10,tercer_token.length()-10);
				
				}




				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					//iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);

					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(msg_for_processing(next_field,var_field));
					int count2 = 0;
					
					while(!(token=next("=")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					//RWCString field_63_pagos = "& 0000300095! P1100016 "+primer_token+" ! P1200004 "+iso_field_value[14](5,4);
					//RWCString field_63_pagos = "& 0000300095! P800016 "+primer_token+"! P900004 "+iso_field_value[14](5,4);
					//iso_field_value[63] = "00063"+field_63_pagos;

					RWCString field_48_pagos = primer_token+"!"+iso_field_value[14](5,4);

					RWCString test_pre=field_48_pagos;

					char pre_test = '\x30';
					size_t test = 27-test_pre.length();
					test_pre.append(pre_test , test);

					iso_field_value[48] = "00048"+test_pre;
					//cout << "Valor de test_pre > " << test_pre << endl;
				
					//iso_field_value[48]=test_pre;



				}
				
				if((j+1) >= 32)
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

				
							iso_field_value[35]= "00035"+test_pre;
						}
					  
					}

					
				}
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						processing_banpais = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(processing_banpais == "402020")
						{
							new_processing_banpais = "013030";
						}
						else
						if(processing_banpais == "313000")
						{
							new_processing_banpais = "303000";
						}
					
						else
						{
							new_processing_banpais = "303000";
						}
					
						iso_field_value[3]="00003"+new_processing_banpais;
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}

 	
	response_0210_generic_from_iso = "0200"+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]
									 +delimiter+iso_field_value[14]+delimiter+iso_field_value[17]+delimiter+iso_field_value[18]
									 +delimiter+iso_field_value[22]+delimiter+iso_field_value[25]+delimiter+iso_field_value[32]
									 +delimiter+iso_field_value[35]+delimiter+iso_field_value[37]+delimiter+iso_field_value[41]
									 +delimiter+iso_field_value[42]+delimiter+iso_field_value[43]+delimiter+iso_field_value[48]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[52]+delimiter+iso_field_value[60]
									 +delimiter+iso_field_value[61]+delimiter+iso_field_value[63]+delimiter+iso_field_value[120]
									 +delimiter+iso_field_value[123]+delimiter+iso_field_value[125];

	return response_0210_generic_from_iso;

}


void MQUtility::Retorno_200_B24(RWCString incoming , char *msg_type, char *name_user)
{
	
	
	int procesar = 1;
/*
	int next_field_last = 0;
	RWCString primero_parte_63;
	RWCString segunda_parte_63;
	RWCString tercera_parte_63;
	RWCString cuarta_parte_63;
	RWCString quinta_parte_63;
	RWCString num_lotes_pov;
	RWCString hex_bit = incoming(18,32);
*/	
	RWCString num_lotes_pov;
	RWCString batch_record1_0123;
	RWCString tercera_parte_63;

//	MQUtility test_mq;
	//////////////////////////////////////////////////////////////////////////////////////
	if(procesar == 1)
	{		
	
		int debug = 0;
				
		
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	char pan_number[100]	 = {""};
	char resto_track2[100]	= {""};
		
	
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[41] = 16; iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;


	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		
		if(debug == 1)
				
			test_iso_new.ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
				test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
					iso_field_value[48]=msg_for_processing(next_field,var_field);
						
					if(iso_field_value[48](0,1) == "R")
					{


						tercera_parte_63 = iso_field_value[48](1,12);
						tercera_parte_63 = tercera_parte_63.strip( RWCString::leading, ' ') ;
						num_lotes_pov=iso_field_value[48](13,3);

				
					}
			
				}
				if((j+1) == 59)
					iso_field_value[59]=msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]=msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]=msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]=msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]=msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
					
				if((j+1) == 126)
					iso_field_value[126]= msg_for_processing(next_field,var_field);
			
			
				if((j+1) == 127)
					iso_field_value[127]= msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					RWCString pan_rw = msg_for_processing(next_field,var_field);
					strcpy(pan_number,pan_rw);
					iso_field_value[2]=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
			
					iso_field_value[35]=  msg_for_processing(next_field,var_field);
				
					
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
					
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 5)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[5]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 25)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}


	RWCString track_2_rw = iso_field_value[35];
		
	RWCString token1;
	RWCString primer_token,segundo_token,tercer_token;
	RWCTokenizer next1(track_2_035);
	int count2 = 0;
					
	while(!(token1=next1("=")).isNull())
	{
		if (count2 == 0)
		{
			primer_token = token1;
		}
		if (count2 == 1)
		{
			segundo_token= token1;
		}
					
		count2++;
	}
	
	RWCString switch_key_127=iso_field_value[13]+iso_field_value[12]+
		           "0200"+iso_field_value[37]+primer_token(primer_token.length()-6,6);
   	
	//RWCString switch_key = local_transaction_date+local_transaction_time+"0200"+retrieval_reference_number;
	
    //cout << "Valor de switch_key_127 > " << switch_key_127 << endl;

		
		char pan1[17]								= "4931372032057778";
		char msg_type_sql[5]						= "0200";								
		char processing_code_F3[7]					= "000000";              
		char transaction_amount_F4[13]				= "000000001000"; 
		char transaction_amount_F5[13]				= "000000001000"; 
		char transmission_date_time_F7[11]			= "1122185321";       
		char system_trace_audit_number_F11[7]		= "051767";
		char local_transaction_time_F12[7]			= "125321";
		char local_transaction_date_F13[5]			= "0607";
		char expiration_date_14[5]					= "0409";
		char capture_date_F17[5]					= "0000";
		char merchant_type_F18[5]					= "5812";
		char point_service_entry_mode_F22[4]		= "810";
		char point_service_condition_code_F25[3]	= "59";
		char acquiring_institution_id_code_F32[10]	= "000077185";
		char track2_F35[38]							= "5400831500012011=040900000000000000";
		char retrieval_reference_number_F37[13]		= "339397910019";
		char responde_id_response_038[7]			= "000000";
		char responde_code_039[3]					= "91";
		char card_acceptor_terminal_id_F41[17]		= "239387912393    ";
		char card_acceptor_id_code_F42[16]			= "349000003      ";
		char card_acceptor_name_location_F43[41]	= "FERRETERIA AMERICANA REP. DOM.       DOM";
		char pos_retailer_data_48[28]				= "111111111111111111122223333";
		char transaction_currency_code_F49[4]		= "214";
		char personal_id_number_F52[17]				= "D3CED104F9235D44";
		char pos_terminal_data_60[17]				= "TERMPR04TES40000";
		char pos_issuer_data_61[20]					= "1111222200000000000";
		char field_63[512]							= "& 0000300045! P100003 816";
		char pos_terminal_address_branch_0120[30]	= "CAJA FERR. AMERICANA         ";
		char pos_invoice_data_123[21]				= "          9397910019";
		char pos_settlement_data_0125[13]			= "  HOSTB24 10";
		char switch_key_char[28]					= {""};
		char compensated[2]							= "0";
		char sponsor_bank[9]						= {""};
		char num_lotes[4]		     				= {""};
		char tran_type[3]							= {""};
		char from_account[3]						= {""};
		char to_account[3]							= {""};
		
		RWCString card_acceptor_id_code_042_rw =iso_field_value[42](0,9); 
	


		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		//char pan_number[100]	 = {""};
		//char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan1 , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
/*
	cout <<"Valor de pan_number           > " << pan_number << endl;
	cout <<"Valor de iso_field_value[3]   > " << iso_field_value[3] << endl;
	cout <<"Valor de iso_field_value[4]   > " << iso_field_value[4] << endl;
	cout <<"Valor de iso_field_value[5]   > " << iso_field_value[5] << endl;
	cout <<"Valor de iso_field_value[7]   > " << iso_field_value[7] << endl;
	cout <<"Valor de iso_field_value[11]  > " << iso_field_value[11] << endl;
	cout <<"Valor de iso_field_value[12]  > " << iso_field_value[12] << endl;
	cout <<"Valor de iso_field_value[13]  > " << iso_field_value[13] << endl;
	cout <<"Valor de iso_field_value[14]  > " << iso_field_value[14] << endl;
	cout <<"Valor de iso_field_value[17]  > " << iso_field_value[17] << endl;
	cout <<"Valor de iso_field_value[18]  > " << iso_field_value[18] << endl;
	cout <<"Valor de iso_field_value[22]  > " << iso_field_value[22] << endl;
	cout <<"Valor de iso_field_value[25]  > " << iso_field_value[25] << endl;
	cout <<"Valor de iso_field_value[32]  > " << iso_field_value[32] << endl;
	cout <<"Valor de iso_field_value[35]  > " << iso_field_value[35] << endl;
	cout <<"Valor de iso_field_value[37]  > " << iso_field_value[37] << endl;
	cout <<"Valor de iso_field_value[38]  > " << iso_field_value[38] << endl;
	cout <<"Valor de iso_field_value[39]  > " << iso_field_value[39] << endl;
	cout <<"Valor de iso_field_value[41]  > " << iso_field_value[41] << endl;
	cout <<"Valor de iso_field_value[42]  > " << iso_field_value[42] << endl;
	cout <<"Valor de iso_field_value[43]  > " << iso_field_value[43] << endl;
	cout <<"Valor de iso_field_value[48]  > " << iso_field_value[48] << endl;
	cout <<"Valor de iso_field_value[49]  > " << iso_field_value[49] << endl;
	cout <<"Valor de iso_field_value[60]  > " << iso_field_value[60] << endl;
	cout <<"Valor de iso_field_value[61]  > " << iso_field_value[61] << endl;
	cout <<"Valor de iso_field_value[120] > " << iso_field_value[120] << endl;
	cout <<"Valor de iso_field_value[123] > " << iso_field_value[123] << endl;
	cout <<"Valor de iso_field_value[125] > " << iso_field_value[125] << endl;
	cout <<"Valor de switch_key_127       > " << switch_key_127 << endl;
	cout <<"Valor de num_lotes_pov        > " << num_lotes_pov << endl;

*/


		strcpy(pan1,pan_number);
		strcpy(processing_code_F3,iso_field_value[3]);
		strcpy(transaction_amount_F4,iso_field_value[4]);
		strcpy(transaction_amount_F5,iso_field_value[5]);
		strcpy(transmission_date_time_F7,iso_field_value[7]);
		strcpy(system_trace_audit_number_F11,iso_field_value[11]);
		strcpy(local_transaction_time_F12,iso_field_value[12]);
		strcpy(local_transaction_date_F13,iso_field_value[13]);
		strcpy(expiration_date_14,iso_field_value[14]);
		strcpy(capture_date_F17,iso_field_value[17]);
		strcpy(merchant_type_F18,iso_field_value[18]);
		strcpy(point_service_entry_mode_F22,iso_field_value[22]);
		strcpy(point_service_condition_code_F25,iso_field_value[25]);
		strcpy(acquiring_institution_id_code_F32,iso_field_value[32]);
		strcpy(track2_F35,iso_field_value[35]);
		strcpy(retrieval_reference_number_F37,iso_field_value[37]);
		strcpy(responde_id_response_038,iso_field_value[38]);
		strcpy(responde_code_039,iso_field_value[39]);
		strcpy(card_acceptor_terminal_id_F41,iso_field_value[41]);
		strcpy(card_acceptor_id_code_F42,card_acceptor_id_code_042_rw);
		strcpy(card_acceptor_name_location_F43,iso_field_value[43]);
		strcpy(pos_retailer_data_48,iso_field_value[48]);
		strcpy(transaction_currency_code_F49,iso_field_value[49]);
		strcpy(pos_terminal_data_60,iso_field_value[60]);
		strcpy(pos_issuer_data_61,iso_field_value[61]);
		strcpy(pos_terminal_address_branch_0120,iso_field_value[120]);
		strcpy(pos_invoice_data_123,iso_field_value[123]);
		strcpy(pos_settlement_data_0125,iso_field_value[125]);
		strcpy(switch_key_char,switch_key_127);
		strcpy(num_lotes,num_lotes_pov);
	//	strcpy(num_lotes,"123");
		SAConnection con; // create connection object


		RWCString local_transaction_date = local_transaction_date_F13;
		RWCString local_transaction_time = local_transaction_time_F12;
		RWCString retrieval_reference_number = retrieval_reference_number_F37;
		RWCString switch_key = local_transaction_date+local_transaction_time+"0200"+retrieval_reference_number;
		RWCString proccesing_code = processing_code_F3;
		RWCString tran_type_s = "";
		RWCString from_account_s = "";
		RWCString to_account_s = "";
		tran_type_s		= iso_field_value[3](0,2);
		from_account_s	= iso_field_value[3](2,2);
		to_account_s	= iso_field_value[3](4,2);
	
		strcpy(tran_type ,tran_type_s );
		strcpy(from_account ,from_account_s );
		strcpy(to_account ,to_account_s );
	
		strcpy(switch_key_char, switch_key);
		SACommand cmd(&con);//,"SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object

	
		try
		{
   
			con.Connect(
			"Btrans",     // database name
			"sa",   // user name
			"gc2436",   // password
			SA_SQLServer_Client);

		    cmd.setConnection(&con);
			//cout << name_user;
			cmd.setCommandText("SELECT * from userbtrans where username = :username");    // command object
			cmd.Param("username").setAsString() = name_user;


			cmd.Execute();
			while(cmd.FetchNext())
			{

			
			}

		 
			if (!strcmp(num_lotes,"") == 0)
			{
		
			} 

		    con.Disconnect();

			con.Connect(
			"Btrans_trans",     // database name
 			"sa",   // user name
			"gc2436",   // password
			SA_SQLServer_Client);

			char pan_from_db[17]	 = {""};
			char amount_from_db[17]	 = {""};
	        cmd.setConnection(&con);
	
			cmd.setCommandText("SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object
			cmd.Param("card_acceptor_terminal_id").setAsString() = card_acceptor_terminal_id_F41;


			cmd.Execute();
			while(cmd.FetchNext())
			{
			//	strcpy ( num_lotes, cmd.Field("num_lotes").asString());
				strcpy ( sponsor_bank, cmd.Field("sponsor_bank").asString());
			}

		 
			if (!strcmp(num_lotes,"") == 0)
			{
				
				//strcpy ( num_lotes, cmd.Field("num_lotes").asString());
				strcpy ( sponsor_bank, cmd.Field("sponsor_bank").asString());
			
			} 
			else
			{
				//strcpy ( num_lotes, "");
				strcpy ( sponsor_bank, cmd.Field("sponsor_bank").asString());
			
			}


			RWCString time_rw;
			RWTime t;
			time_rw = t.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
		
			cmd.setCommandText( \
			"INSERT INTO switch_gm(pan,processing_code,amount_trans,amount_settlement,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local,expiration_date,capture_date,merchant_type,pos_entry_mode,pos_conditional_code,\
			adquiring_institution_id_code,track_ii_data,retrieval_reference_number,authorization_id_response,response_code,card_acceptor_terminal_id, \
			card_acceptor_id_code,card_acceptor_name_location,additional_data,currency_code_transaction,currency_code_settlement, \
			atm_terminal_data,card_issuer_category_data,terminal_address_branch,pos_data_code,pos_settlement_data,switch_key,msg_type,date_local,in_req, \
			tran_type,from_account,to_account,sponsor_bank,compensated,merchant_reference_number,num_lote) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transaction_amount_itbis,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date,:expiration_date,:capture_date,:merchant_type,:point_service_entry_mode, :point_service_condition_code,  \
				 :acquiring_institution_id_code,:track2,:retrieval_reference_number,:authorization,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_id_code,:card_acceptor_name_location,:pos_retailer_data,:transaction_currency_code,:currency_code_setllement,\
				 :pos_terminal_data,:pos_issuer_data,:pos_terminal_address_branch,:pos_invoice_data,:pos_settlement_data, \
				 :switch_key,:msg_type_sql,:date_local,:in_time,:tran_type,:from_account,:to_account,:sponsor_bank,:compensated,:merchant_reference,:num_lotes)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transaction_amount_itbis").setAsString()		= transaction_amount_F5;

			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("expiration_date").setAsString()				= expiration_date_14;
			cmd.Param("capture_date").setAsString()					= local_transaction_date_F13;
			cmd.Param("merchant_type").setAsString()				= merchant_type_F18;
			cmd.Param("point_service_entry_mode").setAsString()		= point_service_entry_mode_F22;
			cmd.Param("point_service_condition_code").setAsString() = point_service_condition_code_F25;
			cmd.Param("acquiring_institution_id_code").setAsString()= acquiring_institution_id_code_F32;
			cmd.Param("track2").setAsString()						= "000000000000000000=00000000000000000000";
			cmd.Param("retrieval_reference_number").setAsString()   = retrieval_reference_number_F37;
			cmd.Param("authorization").setAsString()				= "000000";
			cmd.Param("response").setAsString()						= "LR";
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;

			cmd.Param("card_acceptor_id_code").setAsString()		= card_acceptor_id_code_F42;
			cmd.Param("card_acceptor_name_location").setAsString()	= card_acceptor_name_location_F43;

			cmd.Param("pos_retailer_data").setAsString()			= pos_retailer_data_48;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("currency_code_setllement").setAsString()		= transaction_currency_code_F49;
			cmd.Param("pos_terminal_data").setAsString()			= pos_terminal_data_60;
			cmd.Param("pos_issuer_data").setAsString()				= pos_issuer_data_61;
			cmd.Param("pos_terminal_address_branch").setAsString()  = pos_terminal_address_branch_0120;
			cmd.Param("pos_invoice_data").setAsString()				= pos_invoice_data_123;
			
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
		
			
			cmd.Param("switch_key").setAsString()					= switch_key_char;
		
			cmd.Param("tran_type").setAsString()					= tran_type;
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
	
			cmd.Param("msg_type_sql").setAsString()					= msg_type_sql;
			cmd.Param("from_account").setAsString()					= from_account;
			cmd.Param("to_account").setAsString()					= to_account;
			cmd.Param("sponsor_bank").setAsString()					= sponsor_bank;
			cmd.Param("compensated").setAsString()					= compensated;
			cmd.Param("merchant_reference").setAsString()			= tercera_parte_63;
			cmd.Param("num_lotes").setAsString()					= num_lotes;
			
		/*		
			cmd.setCommandText( \
			"INSERT INTO switch_gm(pan,processing_code,amount_trans,amount_settlement,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local,expiration_date,capture_date,merchant_type,pos_entry_mode,pos_conditional_code, \
			adquiring_institution_id_code,track_ii_data,retrieval_reference_number,authorization_id_response,response_code,card_acceptor_terminal_id, \
			card_acceptor_id_code,card_acceptor_name_location,additional_data,currency_code_transaction,currency_code_settlement, \
			atm_terminal_data,card_issuer_category_data,terminal_address_branch,pos_data_code,pos_settlement_data,msg_type, \
			tran_type,from_account,to_account,sponsor_bank,date_local,in_req,switch_key,compensated,merchant_reference_number,num_lote) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transaction_amount_itbis,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date,:expiration_date,:capture_date,:merchant_type,:point_service_entry_mode, \
				 :point_service_condition_code,:acquiring_institution_id_code,:track2,:retrieval_reference_number,:authorization,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_id_code,:card_acceptor_name_location,:pos_retailer_data,:transaction_currency_code,:currency_code_setllement, \
				 :pos_terminal_data,:pos_issuer_data,:pos_terminal_address_branch,:pos_invoice_data,:pos_settlement_data, \
				 :msg_type_sql,:tran_type,:from_account,:to_account,:sponsor_bank,:date_local,:in_time,:switch_key,:compensated,:merchant_reference,:num_lotes)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transaction_amount_itbis").setAsString()		= transaction_amount_F5;

			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("expiration_date").setAsString()				= expiration_date_14;
			cmd.Param("capture_date").setAsString()					= local_transaction_date_F13;
			cmd.Param("merchant_type").setAsString()				= merchant_type_F18;
			cmd.Param("point_service_entry_mode").setAsString()		= point_service_entry_mode_F22;
			cmd.Param("point_service_condition_code").setAsString() = point_service_condition_code_F25;
			cmd.Param("acquiring_institution_id_code").setAsString()= acquiring_institution_id_code_F32;
			cmd.Param("track2").setAsString()						= track2_F35;
			cmd.Param("retrieval_reference_number").setAsString()   = retrieval_reference_number_F37;
			cmd.Param("authorization").setAsString()				= responde_id_response_038;
			cmd.Param("response").setAsString()						= "LR";
		
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;
			cmd.Param("card_acceptor_id_code").setAsString()		= card_acceptor_id_code_F42;
			cmd.Param("card_acceptor_name_location").setAsString()	= card_acceptor_name_location_F43;
			cmd.Param("pos_retailer_data").setAsString()			= pos_retailer_data_48;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("currency_code_setllement").setAsString()		= transaction_currency_code_F49;
			cmd.Param("pos_terminal_data").setAsString()			= pos_terminal_data_60;
			cmd.Param("pos_issuer_data").setAsString()				= pos_issuer_data_61;
			cmd.Param("pos_terminal_address_branch").setAsString()  = pos_terminal_address_branch_0120;
			cmd.Param("pos_invoice_data").setAsString()				= pos_invoice_data_123;
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
		
			
		
			cmd.Param("msg_type_sql").setAsString()					= msg_type_sql;
			cmd.Param("tran_type").setAsString()					= tran_type;
			cmd.Param("from_account").setAsString()					= from_account;
			cmd.Param("to_account").setAsString()					= to_account;
			cmd.Param("sponsor_bank").setAsString()					= sponsor_bank;
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
			cmd.Param("switch_key").setAsString()					= switch_key_char;
			cmd.Param("compensated").setAsString()					= compensated;
			cmd.Param("merchant_reference").setAsString()			= tercera_parte_63;
			cmd.Param("num_lotes").setAsString()					= num_lotes;
		
		*/
			cmd.Execute();
	
		    con.Disconnect();

		}
		catch(SAException &x)
		{
			// SAConnection::Rollback()
			// can also throw an exception
			// (if a network error for example),
			// we will be ready
			try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			catch(SAException &)
			{
			}
				// print error message
				printf("%s\n", (const char*)x.ErrText());
			}
		}
	
////////////////////////////////////////////////////////////////////////////////////////////

	
	
	//return response_0210_generic_from_iso;

}



void MQUtility::Retorno_200_B24Vbv(RWCString incoming , char *msg_type)
{
	
	
	int procesar = 1;
/*
	int next_field_last = 0;
	RWCString primero_parte_63;
	RWCString segunda_parte_63;
	RWCString tercera_parte_63;
	RWCString cuarta_parte_63;
	RWCString quinta_parte_63;
	RWCString num_lotes_pov;
	RWCString hex_bit = incoming(18,32);
*/	
	RWCString num_lotes_pov;
	RWCString batch_record1_0123;
	RWCString tercera_parte_63;

//	MQUtility test_mq;
	//////////////////////////////////////////////////////////////////////////////////////
	if(procesar == 1)
	{		
	
		int debug = 0;
				
		
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	char pan_number[100]	 = {""};
	char resto_track2[100]	= {""};
		
	
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[41] = 16; iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;


	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		
		if(debug == 1)
				
			test_iso_new.ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
				test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
					iso_field_value[48]=msg_for_processing(next_field,var_field);
						
					if(iso_field_value[48](0,1) == "R")
					{


						tercera_parte_63 = iso_field_value[48](1,12);
						tercera_parte_63 = tercera_parte_63.strip( RWCString::leading, ' ') ;
						num_lotes_pov=iso_field_value[48](13,3);

				
					}
			
				}
				if((j+1) == 59)
					iso_field_value[59]=msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]=msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]=msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]=msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]=msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
					
				if((j+1) == 126)
					iso_field_value[126]= msg_for_processing(next_field,var_field);
			
			
				if((j+1) == 127)
					iso_field_value[127]= msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					RWCString pan_rw = msg_for_processing(next_field,var_field);
					strcpy(pan_number,pan_rw);
					iso_field_value[2]=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
			
					iso_field_value[35]=  msg_for_processing(next_field,var_field);
				
					
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
					
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 5)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[5]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 25)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}


	//cout << "Valor de iso_field_value[63] :" << iso_field_value[63] << endl;; 
	
	
	if(iso_field_value[63].length() != 0)
	{


		RWCString token;
		RWCString primer_token,segundo_token,tercer_token,cuarto_token;
		RWCTokenizer next(iso_field_value[63]);
		int count2 = 0;
					
		while(!(token=next("!")).isNull())
		{
			if (count2 == 0)
			{
				primer_token = token;
			}
			if (count2 == 1)
			{
				segundo_token= token;
			}
			if (count2 == 2)
			{
				tercer_token= token;
			}
			if (count2 == 3)
			{
				cuarto_token= token;
			}
			count2++;
		}


	if((primer_token(0,2) == "CF") || (primer_token(1,2) == "CF"))
	 {
		//cout << "Valor de primer_token(8,2)" << primer_token(8,2) << endl;
		tercera_parte_63 = primer_token(8,2);
	 }

	 if((segundo_token(0,2) == "CF") || (segundo_token(1,2) == "CF"))
	 {

		tercera_parte_63 = segundo_token(8,2);

	 }
	
	 if((tercer_token(0,2) == "CF") || (tercer_token(1,2) == "CF"))
	 {
		tercera_parte_63 = tercer_token(8,2);

	 }

	 

	 if((cuarto_token(0,2) == "CF") || (cuarto_token(1,2) == "CF"))
	 {

		tercera_parte_63 = cuarto_token(8,2);

	 }

	}















//	cout << "Valor de tercera_parte_63 " << tercera_parte_63 << endl;
	RWCString track_2_rw = iso_field_value[35];
		
	RWCString token1;
	RWCString primer_token,segundo_token,tercer_token;
	RWCTokenizer next1(track_2_035);
	int count2 = 0;
					
	while(!(token1=next1("=")).isNull())
	{
		if (count2 == 0)
		{
			primer_token = token1;
		}
		if (count2 == 1)
		{
			segundo_token= token1;
		}
					
		count2++;
	}
	
	RWCString switch_key_127=iso_field_value[13]+iso_field_value[12]+
		           "0200"+iso_field_value[37]+primer_token(primer_token.length()-6,6);
   	
	//RWCString switch_key = local_transaction_date+local_transaction_time+"0200"+retrieval_reference_number;
	
    //cout << "Valor de switch_key_127 > " << switch_key_127 << endl;

		
		char pan1[17]								= "4931372032057778";
		char msg_type_sql[5]						= "0200";								
		char processing_code_F3[7]					= "000000";              
		char transaction_amount_F4[13]				= "000000001000"; 
		char transaction_amount_F5[13]				= "000000001000"; 
		char transmission_date_time_F7[11]			= "1122185321";       
		char system_trace_audit_number_F11[7]		= "051767";
		char local_transaction_time_F12[7]			= "125321";
		char local_transaction_date_F13[5]			= "0607";
		char expiration_date_14[5]					= "0409";
		char capture_date_F17[5]					= "0000";
		char merchant_type_F18[5]					= "5812";
		char point_service_entry_mode_F22[4]		= "810";
		char point_service_condition_code_F25[3]	= "59";
		char acquiring_institution_id_code_F32[10]	= "000077185";
		char track2_F35[38]							= "5400831500012011=040900000000000000";
		char retrieval_reference_number_F37[13]		= "339397910019";
		char responde_id_response_038[7]			= "000000";
		char responde_code_039[3]					= "91";
		char card_acceptor_terminal_id_F41[17]		= "239387912393    ";
		char card_acceptor_id_code_F42[16]			= "349000003      ";
		char card_acceptor_name_location_F43[41]	= "FERRETERIA AMERICANA REP. DOM.       DOM";
		char pos_retailer_data_48[28]				= "111111111111111111122223333";
		char transaction_currency_code_F49[4]		= "214";
		char personal_id_number_F52[17]				= "D3CED104F9235D44";
		char pos_terminal_data_60[17]				= "TERMPR04TES40000";
		char pos_issuer_data_61[20]					= "1111222200000000000";
		char field_63[512]							= "& 0000300045! P100003 816";
		char pos_terminal_address_branch_0120[30]	= "CAJA FERR. AMERICANA         ";
		char pos_invoice_data_123[21]				= "          9397910019";
		char pos_settlement_data_0125[13]			= "  HOSTB24 10";
		char switch_key_char[28]					= {""};
		char compensated[2]							= "0";
		char sponsor_bank[9]						= {""};
		char num_lotes[4]		     				= {""};
		char tran_type[3]							= {""};
		char from_account[3]						= {""};
		char to_account[3]							= {""};
		char merchant_reference[250]				= {""};
		
		RWCString card_acceptor_id_code_042_rw =iso_field_value[42](0,9); 
	


		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		//char pan_number[100]	 = {""};
		//char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan1 , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
/*
	cout <<"Valor de pan_number           > " << pan_number << endl;
	cout <<"Valor de iso_field_value[3]   > " << iso_field_value[3] << endl;
	cout <<"Valor de iso_field_value[4]   > " << iso_field_value[4] << endl;
	cout <<"Valor de iso_field_value[5]   > " << iso_field_value[5] << endl;
	cout <<"Valor de iso_field_value[7]   > " << iso_field_value[7] << endl;
	cout <<"Valor de iso_field_value[11]  > " << iso_field_value[11] << endl;
	cout <<"Valor de iso_field_value[12]  > " << iso_field_value[12] << endl;
	cout <<"Valor de iso_field_value[13]  > " << iso_field_value[13] << endl;
	cout <<"Valor de iso_field_value[14]  > " << iso_field_value[14] << endl;
	cout <<"Valor de iso_field_value[17]  > " << iso_field_value[17] << endl;
	cout <<"Valor de iso_field_value[18]  > " << iso_field_value[18] << endl;
	cout <<"Valor de iso_field_value[22]  > " << iso_field_value[22] << endl;
	cout <<"Valor de iso_field_value[25]  > " << iso_field_value[25] << endl;
	cout <<"Valor de iso_field_value[32]  > " << iso_field_value[32] << endl;
	cout <<"Valor de iso_field_value[35]  > " << iso_field_value[35] << endl;
	cout <<"Valor de iso_field_value[37]  > " << iso_field_value[37] << endl;
	cout <<"Valor de iso_field_value[38]  > " << iso_field_value[38] << endl;
	cout <<"Valor de iso_field_value[39]  > " << iso_field_value[39] << endl;
	cout <<"Valor de iso_field_value[41]  > " << iso_field_value[41] << endl;
	cout <<"Valor de iso_field_value[42]  > " << iso_field_value[42] << endl;
	cout <<"Valor de iso_field_value[43]  > " << iso_field_value[43] << endl;
	cout <<"Valor de iso_field_value[48]  > " << iso_field_value[48] << endl;
	cout <<"Valor de iso_field_value[49]  > " << iso_field_value[49] << endl;
	cout <<"Valor de iso_field_value[60]  > " << iso_field_value[60] << endl;
	cout <<"Valor de iso_field_value[61]  > " << iso_field_value[61] << endl;
	cout <<"Valor de iso_field_value[120] > " << iso_field_value[120] << endl;
	cout <<"Valor de iso_field_value[123] > " << iso_field_value[123] << endl;
	cout <<"Valor de iso_field_value[125] > " << iso_field_value[125] << endl;
	cout <<"Valor de switch_key_127       > " << switch_key_127 << endl;
	cout <<"Valor de num_lotes_pov        > " << num_lotes_pov << endl;

*/


		strcpy(pan1,pan_number);
		strcpy(processing_code_F3,iso_field_value[3]);
		strcpy(transaction_amount_F4,iso_field_value[4]);
		strcpy(transaction_amount_F5,iso_field_value[5]);
		strcpy(transmission_date_time_F7,iso_field_value[7]);
		strcpy(system_trace_audit_number_F11,iso_field_value[11]);
		strcpy(local_transaction_time_F12,iso_field_value[12]);
		strcpy(local_transaction_date_F13,iso_field_value[13]);
		strcpy(expiration_date_14,iso_field_value[14]);
		strcpy(capture_date_F17,iso_field_value[17]);
		strcpy(merchant_type_F18,iso_field_value[18]);
		strcpy(point_service_entry_mode_F22,iso_field_value[22]);
		strcpy(point_service_condition_code_F25,iso_field_value[25]);
		strcpy(acquiring_institution_id_code_F32,iso_field_value[32]);
		strcpy(track2_F35,iso_field_value[35]);
		strcpy(retrieval_reference_number_F37,iso_field_value[37]);
		strcpy(responde_id_response_038,iso_field_value[38]);
		strcpy(responde_code_039,iso_field_value[39]);
		strcpy(card_acceptor_terminal_id_F41,iso_field_value[41]);
		strcpy(card_acceptor_id_code_F42,card_acceptor_id_code_042_rw);
		strcpy(card_acceptor_name_location_F43,iso_field_value[43]);
		strcpy(pos_retailer_data_48,iso_field_value[48]);
		strcpy(transaction_currency_code_F49,iso_field_value[49]);
		strcpy(pos_terminal_data_60,iso_field_value[60]);
		strcpy(pos_issuer_data_61,iso_field_value[61]);
		strcpy(pos_terminal_address_branch_0120,iso_field_value[120]);
		strcpy(pos_invoice_data_123,iso_field_value[123]);
		strcpy(pos_settlement_data_0125,iso_field_value[125]);
		strcpy(switch_key_char,switch_key_127);
		strcpy(num_lotes,num_lotes_pov);
	//	strcpy(num_lotes,"123");

		strcpy(merchant_reference,tercera_parte_63);
		SAConnection con; // create connection object


		RWCString local_transaction_date = local_transaction_date_F13;
		RWCString local_transaction_time = local_transaction_time_F12;
		RWCString retrieval_reference_number = retrieval_reference_number_F37;
		RWCString switch_key = local_transaction_date+local_transaction_time+"0200"+retrieval_reference_number;
		RWCString proccesing_code = processing_code_F3;
		RWCString tran_type_s = "";
		RWCString from_account_s = "";
		RWCString to_account_s = "";
		tran_type_s		= iso_field_value[3](0,2);
		from_account_s	= iso_field_value[3](2,2);
		to_account_s	= iso_field_value[3](4,2);
	
		strcpy(tran_type ,tran_type_s );
		strcpy(from_account ,from_account_s );
		strcpy(to_account ,to_account_s );
	
		strcpy(switch_key_char, switch_key);
		SACommand cmd(&con);//,"SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object

	
		try
		{

			con.Connect(
			"Btrans_trans",     // database name
 			"sa",   // user name
			"gc2436",   // password
			SA_SQLServer_Client);

			char pan_from_db[17]	 = {""};
			char amount_from_db[17]	 = {""};
	        cmd.setConnection(&con);
	
			cmd.setCommandText("SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object
			cmd.Param("card_acceptor_terminal_id").setAsString() = card_acceptor_terminal_id_F41;


			cmd.Execute();
			while(cmd.FetchNext())
			{
			//	strcpy ( num_lotes, cmd.Field("num_lotes").asString());
				strcpy ( sponsor_bank, cmd.Field("sponsor_bank").asString());
			}

		 
			if (!strcmp(num_lotes,"") == 0)
			{
				
				//strcpy ( num_lotes, cmd.Field("num_lotes").asString());
				strcpy ( sponsor_bank, cmd.Field("sponsor_bank").asString());
			
			} 
			else
			{
				//strcpy ( num_lotes, "");
				strcpy ( sponsor_bank, cmd.Field("sponsor_bank").asString());
			
			}
	//		cout << "Valor de tercera_parte_63 " << tercera_parte_63 << endl;

			RWCString time_rw;
			RWTime t;
			time_rw = t.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
		
			cmd.setCommandText( \
			"INSERT INTO switch_vbv(pan,processing_code,amount_trans,amount_settlement,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local,expiration_date,capture_date,merchant_type,pos_entry_mode,pos_conditional_code,\
			adquiring_institution_id_code,track_ii_data,retrieval_reference_number,authorization_id_response,response_code,card_acceptor_terminal_id, \
			card_acceptor_id_code,card_acceptor_name_location,additional_data,currency_code_transaction,currency_code_settlement, \
			atm_terminal_data,card_issuer_category_data,terminal_address_branch,pos_data_code,pos_settlement_data,switch_key,msg_type,date_local,in_req, \
			tran_type,from_account,to_account,sponsor_bank,compensated,merchant_reference_number,num_lote,vbv_campo) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transaction_amount_itbis,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date,:expiration_date,:capture_date,:merchant_type,:point_service_entry_mode, :point_service_condition_code,  \
				 :acquiring_institution_id_code,:track2,:retrieval_reference_number,:authorization,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_id_code,:card_acceptor_name_location,:pos_retailer_data,:transaction_currency_code,:currency_code_setllement,\
				 :pos_terminal_data,:pos_issuer_data,:pos_terminal_address_branch,:pos_invoice_data,:pos_settlement_data, \
				 :switch_key,:msg_type_sql,:date_local,:in_time,:tran_type,:from_account,:to_account,:sponsor_bank,:compensated,:merchant_reference_number,:num_lotes,:vbv_campo)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transaction_amount_itbis").setAsString()		= transaction_amount_F5;

			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("expiration_date").setAsString()				= expiration_date_14;
			cmd.Param("capture_date").setAsString()					= local_transaction_date_F13;
			cmd.Param("merchant_type").setAsString()				= merchant_type_F18;
			cmd.Param("point_service_entry_mode").setAsString()		= point_service_entry_mode_F22;
			cmd.Param("point_service_condition_code").setAsString() = point_service_condition_code_F25;
			cmd.Param("acquiring_institution_id_code").setAsString()= acquiring_institution_id_code_F32;
			cmd.Param("track2").setAsString()						= "000000000000000000=00000000000000000000";
			cmd.Param("retrieval_reference_number").setAsString()   = retrieval_reference_number_F37;
			cmd.Param("authorization").setAsString()				= "000000";
			cmd.Param("response").setAsString()						= "LR";
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;

			cmd.Param("card_acceptor_id_code").setAsString()		= card_acceptor_id_code_F42;
			cmd.Param("card_acceptor_name_location").setAsString()	= card_acceptor_name_location_F43;

			cmd.Param("pos_retailer_data").setAsString()			= pos_retailer_data_48;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("currency_code_setllement").setAsString()		= transaction_currency_code_F49;
			cmd.Param("pos_terminal_data").setAsString()			= pos_terminal_data_60;
			cmd.Param("pos_issuer_data").setAsString()				= pos_issuer_data_61;
			cmd.Param("pos_terminal_address_branch").setAsString()  = pos_terminal_address_branch_0120;
			cmd.Param("pos_invoice_data").setAsString()				= pos_invoice_data_123;
			
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
		
			
			cmd.Param("switch_key").setAsString()					= switch_key_char;
		
			cmd.Param("tran_type").setAsString()					= tran_type;
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
	
			cmd.Param("msg_type_sql").setAsString()					= msg_type_sql;
			cmd.Param("from_account").setAsString()					= from_account;
			cmd.Param("to_account").setAsString()					= to_account;
			cmd.Param("sponsor_bank").setAsString()					= sponsor_bank;
			cmd.Param("compensated").setAsString()					= compensated;
			cmd.Param("merchant_reference_number").setAsString()	= tercera_parte_63;
			cmd.Param("num_lotes").setAsString()					= num_lotes;
			cmd.Param("vbv_campo").setAsString()					= tercera_parte_63;
			

			cmd.Execute();
	
		    con.Disconnect();

		}
		catch(SAException &x)
		{
			// SAConnection::Rollback()
			// can also throw an exception
			// (if a network error for example),
			// we will be ready
			try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			catch(SAException &)
			{
			}
				// print error message
				printf("%s\n", (const char*)x.ErrText());
			}
		}
	
////////////////////////////////////////////////////////////////////////////////////////////

	
	
	//return response_0210_generic_from_iso;

}



void MQUtility::Retorno_210_B24(RWCString incoming , char *msg_type, char *name_user)
{
	
	
	int procesar = 1;



	//////////////////////////////////////////////////////////////////////////////////////
	if(procesar == 1)
	{		
	
		int debug = 0;
				
		
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	char pan_number[100]	 = {""};
	char resto_track2[100]	= {""};
		
	
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[41] = 16; iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;


	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		
		if(debug == 1)
				
			test_iso_new.ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
				test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]=msg_for_processing(next_field,var_field);
			
				
				if((j+1) == 59)
					iso_field_value[59]=msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]=msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]=msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]=msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]=msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
					
				if((j+1) == 126)
					iso_field_value[126]= msg_for_processing(next_field,var_field);
			
			
				if((j+1) == 127)
					iso_field_value[127]= msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					RWCString pan_rw = msg_for_processing(next_field,var_field);
					strcpy(pan_number,pan_rw);
					iso_field_value[2]=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
			
					iso_field_value[35]=  msg_for_processing(next_field,var_field);
				
					
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
					
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 25)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}


	RWCString track_2_rw = iso_field_value[35];
		
	RWCString token1;
	RWCString primer_token,segundo_token,tercer_token;
	RWCTokenizer next1(track_2_035);
	int count2 = 0;
					
	while(!(token1=next1("=")).isNull())
	{
		if (count2 == 0)
		{
			primer_token = token1;
		}
		if (count2 == 1)
		{
			segundo_token= token1;
		}
					
		count2++;
	}
	
	RWCString switch_key_127=iso_field_value[13]+iso_field_value[12]+
		           "0200"+iso_field_value[37]+primer_token(primer_token.length()-6,6);
   	
	//RWCString switch_key = local_transaction_date+local_transaction_time+"0200"+retrieval_reference_number;
	
	//cout << "Valor de iso_field_value[38] > " << iso_field_value[38] << endl;
	//cout << "Valor de iso_field_value[39] > " << iso_field_value[39] << endl;
    //cout << "Valor de switch_key_127 > " << switch_key_127 << endl;

		
		char pan1[17]								= "4931372032057778";
		char msg_type_sql[5]						= "0220";								
		char processing_code_F3[7]					= "000000";              
		char transaction_amount_F4[13]				= "000000001000"; 
		char transaction_amount_F5[13]				= "000000001000"; 
		char transmission_date_time_F7[11]			= "1122185321";       
		char system_trace_audit_number_F11[7]		= "051767";
		char local_transaction_time_F12[7]			= "125321";
		char local_transaction_date_F13[5]			= "0607";
		char expiration_date_14[5]					= "0409";
		char capture_date_F17[5]					= "0000";
		char merchant_type_F18[5]					= "5812";
		char point_service_entry_mode_F22[4]		= "810";
		char point_service_condition_code_F25[3]	= "59";
		char acquiring_institution_id_code_F32[10]	= "000077185";
		char track2_F35[38]							= "5400831500012011=040900000000000000";
		char retrieval_reference_number_F37[13]		= "339397910019";
		char responde_id_response_038[7]			= "000000";
		char responde_code_039[3]					= "91";
		char card_acceptor_terminal_id_F41[17]		= "239387912393    ";
		char card_acceptor_id_code_F42[16]			= "349000003      ";
		char card_acceptor_name_location_F43[41]	= "FERRETERIA AMERICANA REP. DOM.       DOM";
		char pos_retailer_data_48[28]				= "111111111111111111122223333";
		char transaction_currency_code_F49[4]		= "214";
		char personal_id_number_F52[17]				= "D3CED104F9235D44";
		char pos_terminal_data_60[17]				= "TERMPR04TES40000";
		char pos_issuer_data_61[20]					= "1111222200000000000";
		char field_63[512]							= "& 0000300045! P100003 816";
		char pos_terminal_address_branch_0120[30]	= "CAJA FERR. AMERICANA         ";
		char pos_invoice_data_123[21]				= "          9397910019";
		char pos_settlement_data_0125[13]			= "  HOSTB24 10";
		char switch_key_char[28]					= {""};
		char compensated[2]							= "0";
		char sponsor_bank[9]						= {""};
		char num_lotes[4]		     				= {""};
		char tran_type[3]							= {""};
		char from_account[3]						= {""};
		char to_account[3]							= {""};
		

		/*
		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		//char pan_number[100]	 = {""};
		//char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan1 , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}

		*/

		if(iso_field_value[63].length() != 0)
		{
		//	cout << " Valor de iso_field_value[63] " << iso_field_value[63] << endl;
		
			if( (iso_field_value[63](25,1) == "B"))
			{
				iso_field_value[63] = iso_field_value[63](33,1);
			
			}
			else
				iso_field_value[63] = "";

		
		
		

	}


		char switch_key_0127[40]							= {""};
		strcpy(switch_key_0127,switch_key_127);
		//cout << "Valor de switch_key_0127 > " << switch_key_0127 << endl;
	

		SAConnection con; // create connection object


		SACommand cmd(&con);//,"SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object

	
		try
		{
   
			//RWTime t;
			RWCString time_rw;
			RWTime now;
			time_rw = now.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
			con.Connect(
			  "Btrans_trans",     // database name
			"sa",   // user name
			"gc2436",   // password			SA_SQLServer_Client);
			SA_SQLServer_Client);

		    cmd.setConnection(&con);
		
			cmd.setCommandText("UPDATE switch_gm set response_code = :response , \
				in_req_rsp = :time_in , authorization_id_response = :authorization, merchant_reference_number = :field63 where switch_key = :switch");    // command object
		
			cmd.Param("response").setAsString() = iso_field_value[39];
			cmd.Param("authorization").setAsString() = iso_field_value[38];
			cmd.Param("field63").setAsString() = iso_field_value[63];
			cmd.Param("time_in").setAsString() = time_in_db;
			

			
			cmd.Param("switch").setAsString() = switch_key_0127;

			cmd.Execute();
		    con.Disconnect();

		
		}
		catch(SAException &x)
		{
		  // SAConnection::Rollback()
		  // can also throw an exception
		   // (if a network error for example),
		   // we will be ready
			 try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			 catch(SAException &)
			{
			}
	     // print error message
		   printf("%s\n", (const char*)x.ErrText());
		}
	}
		
/*
		strcpy(pan1,pan_number);
		strcpy(processing_code_F3,iso_field_value[3]);
		strcpy(transaction_amount_F4,iso_field_value[4]);
		strcpy(transmission_date_time_F7,iso_field_value[7]);
		strcpy(system_trace_audit_number_F11,iso_field_value[11]);
		strcpy(local_transaction_time_F12,iso_field_value[12]);
		strcpy(local_transaction_date_F13,iso_field_value[13]);
		strcpy(capture_date_F17,iso_field_value[17]);
		strcpy(acquiring_institution_id_code_F32,iso_field_value[32]);
		strcpy(track2_F35,iso_field_value[35]);
		strcpy(retrieval_reference_number_F37,iso_field_value[37]);
		strcpy(responde_id_response_038,iso_field_value[38]);
		strcpy(responde_code_039,iso_field_value[39]);
		strcpy(card_acceptor_terminal_id_F41,iso_field_value[41]);
				
		strcpy(card_acceptor_name_location_F43,iso_field_value[43]);
		strcpy(transaction_currency_code_F49,iso_field_value[49]);
		strcpy(pos_settlement_data_0125,iso_field_value[125]);

		SAConnection con; // create connection object
		SACommand cmd(&con);//,"SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object

	
		try
		{
   
			con.Connect(
			"Btrans_trans",     // database name
			"sa",   // user name
			"",   // password
			SA_SQLServer_Client);

		    cmd.setConnection(&con);
			cout << name_user;
	
			char pan_from_db[17]	 = {""};
			char amount_from_db[17]	 = {""};
	        cmd.setConnection(&con);




			RWCString time_rw;
			RWTime t;
			time_rw = t.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
			
			cmd.setCommandText( \
			"INSERT INTO switch_discover(pan,processing_code,amount_trans,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local,capture_date, \
			adquiring_institution_id_code,track_ii_data,retrieval_reference_number,authorization_id_response,response_code,card_acceptor_terminal_id, \
			card_acceptor_name_location,currency_code_transaction, \
			pos_settlement_data,msg_type,date_local,in_req) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date,:capture_date, \
				 :acquiring_institution_id_code,:track2,:retrieval_reference_number,:authorization,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_name_location,:transaction_currency_code,\
				 :pos_settlement_data, \
				 :tran_type,:date_local,:in_time)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("capture_date").setAsString()					= local_transaction_date_F13;
			cmd.Param("acquiring_institution_id_code").setAsString()= acquiring_institution_id_code_F32;
			cmd.Param("track2").setAsString()						= "000000000000000000=00000000000000000000";
			cmd.Param("retrieval_reference_number").setAsString()   = retrieval_reference_number_F37;
			cmd.Param("authorization").setAsString()				= responde_id_response_038;
			cmd.Param("response").setAsString()						= responde_code_039;
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
			cmd.Param("tran_type").setAsString()					= "0220";
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
		
		
			cmd.Execute();
	
		    con.Disconnect();

		}
		catch(SAException &x)
		{
			// SAConnection::Rollback()
			// can also throw an exception
			// (if a network error for example),
			// we will be ready
			try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			catch(SAException &)

			{
			}
				// print error message
				printf("%s\n", (const char*)x.ErrText());
			}
*/		
//		}
	
////////////////////////////////////////////////////////////////////////////////////////////

	
	
	//return response_0210_generic_from_iso;

}






void MQUtility::Retorno_210_B24Vbv(RWCString incoming , char *msg_type)
{
	
	
	int procesar = 1;



	//////////////////////////////////////////////////////////////////////////////////////
	if(procesar == 1)
	{		
	
		int debug = 0;
				
		
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};
	char pan_number[100]	 = {""};
	char resto_track2[100]	= {""};
		
	
	MQUtility set_tcp_header;

	//Se crea los fields con valores fijos
	RWTValVector<RWCString> iso_field_value(129,"");
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[41] = 16; iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;


	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		
		if(debug == 1)
				
			test_iso_new.ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;





	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
				test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				iso_field_value[48]=msg_for_processing(next_field,var_field);
			
				
				if((j+1) == 59)
					iso_field_value[59]=msg_for_processing(next_field,var_field);

				
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]=msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]=msg_for_processing(next_field,var_field);

				if((j+1) == 63)
					iso_field_value[63]=msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					iso_field_value[120]=msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
					
				if((j+1) == 126)
					iso_field_value[126]= msg_for_processing(next_field,var_field);
			
			
				if((j+1) == 127)
					iso_field_value[127]= msg_for_processing(next_field,var_field);
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					RWCString pan_rw = msg_for_processing(next_field,var_field);
					strcpy(pan_number,pan_rw);
					iso_field_value[2]=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
			
					iso_field_value[35]=  msg_for_processing(next_field,var_field);
				
					
				}
				
				if((j+1) == 100)
				{
					iso_field_value[100]=  msg_for_processing(next_field,var_field);
				
				}
	
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
										
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						iso_field_value[3]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
					
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					

						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
	
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 19)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 24)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 25)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}

					if(j+1 == 37)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
				
					if(j+1 == 38)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 39)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}
					if(j+1 == 41)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);

					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{
	
						iso_field_value[52]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 52  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
						
					}	

					
					if(j+1 == 90)
					{

					
						iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(debug == 1)
							test_iso_new.ReturnIso8583FieldValue(msg_input, 90  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));;
					}	
				}
			
			}
		}
		
	}


	RWCString track_2_rw = iso_field_value[35];
		
	RWCString token1;
	RWCString primer_token,segundo_token,tercer_token;
	RWCTokenizer next1(track_2_035);
	int count2 = 0;
					
	while(!(token1=next1("=")).isNull())
	{
		if (count2 == 0)
		{
			primer_token = token1;
		}
		if (count2 == 1)
		{
			segundo_token= token1;
		}
					
		count2++;
	}
	
	RWCString switch_key_127=iso_field_value[13]+iso_field_value[12]+
		           "0200"+iso_field_value[37]+primer_token(primer_token.length()-6,6);
   	
	//RWCString switch_key = local_transaction_date+local_transaction_time+"0200"+retrieval_reference_number;
	
	//cout << "Valor de iso_field_value[38] > " << iso_field_value[38] << endl;
	//cout << "Valor de iso_field_value[39] > " << iso_field_value[39] << endl;
    //cout << "Valor de switch_key_127 > " << switch_key_127 << endl;

		
		char pan1[17]								= "4931372032057778";
		char msg_type_sql[5]						= "0220";								
		char processing_code_F3[7]					= "000000";              
		char transaction_amount_F4[13]				= "000000001000"; 
		char transaction_amount_F5[13]				= "000000001000"; 
		char transmission_date_time_F7[11]			= "1122185321";       
		char system_trace_audit_number_F11[7]		= "051767";
		char local_transaction_time_F12[7]			= "125321";
		char local_transaction_date_F13[5]			= "0607";
		char expiration_date_14[5]					= "0409";
		char capture_date_F17[5]					= "0000";
		char merchant_type_F18[5]					= "5812";
		char point_service_entry_mode_F22[4]		= "810";
		char point_service_condition_code_F25[3]	= "59";
		char acquiring_institution_id_code_F32[10]	= "000077185";
		char track2_F35[38]							= "5400831500012011=040900000000000000";
		char retrieval_reference_number_F37[13]		= "339397910019";
		char responde_id_response_038[7]			= "000000";
		char responde_code_039[3]					= "91";
		char card_acceptor_terminal_id_F41[17]		= "239387912393    ";
		char card_acceptor_id_code_F42[16]			= "349000003      ";
		char card_acceptor_name_location_F43[41]	= "FERRETERIA AMERICANA REP. DOM.       DOM";
		char pos_retailer_data_48[28]				= "111111111111111111122223333";
		char transaction_currency_code_F49[4]		= "214";
		char personal_id_number_F52[17]				= "D3CED104F9235D44";
		char pos_terminal_data_60[17]				= "TERMPR04TES40000";
		char pos_issuer_data_61[20]					= "1111222200000000000";
		char field_63[512]							= "& 0000300045! P100003 816";
		char pos_terminal_address_branch_0120[30]	= "CAJA FERR. AMERICANA         ";
		char pos_invoice_data_123[21]				= "          9397910019";
		char pos_settlement_data_0125[13]			= "  HOSTB24 10";
		char switch_key_char[28]					= {""};
		char compensated[2]							= "0";
		char sponsor_bank[9]						= {""};
		char num_lotes[4]		     				= {""};
		char tran_type[3]							= {""};
		char from_account[3]						= {""};
		char to_account[3]							= {""};
		

		/*
		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		//char pan_number[100]	 = {""};
		//char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;

		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan_number , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan1 , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}

		*/

		if(iso_field_value[63].length() != 0)
		{
		//	cout << " Valor de iso_field_value[63] " << iso_field_value[63] << endl;
		
			if( (iso_field_value[63](25,1) == "B"))
			{
				iso_field_value[63] = iso_field_value[63](33,1);
			
			}
			else
				iso_field_value[63] = "";

		
		
		

		}


		char switch_key_0127[40]							= {""};
		strcpy(switch_key_0127,switch_key_127);
		//cout << "Valor de switch_key_0127 > " << switch_key_0127 << endl;
	

		SAConnection con; // create connection object


		SACommand cmd(&con);//,"SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object

	
		try
		{
   
			//RWTime t;
			RWCString time_rw;
			RWTime now;
			time_rw = now.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
			con.Connect(
			  "Btrans_trans",     // database name
			"sa",   // user name
			"gc2436",   // password			SA_SQLServer_Client);
			SA_SQLServer_Client);

		    cmd.setConnection(&con);
		
			cmd.setCommandText("UPDATE switch_vbv set response_code = :response , \
				in_req_rsp = :time_in , authorization_id_response = :authorization, merchant_reference_number = :field63 where switch_key = :switch");    // command object
		
			cmd.Param("response").setAsString() = iso_field_value[39];
			cmd.Param("authorization").setAsString() = iso_field_value[38];
			cmd.Param("field63").setAsString() = iso_field_value[63];
			cmd.Param("time_in").setAsString() = time_in_db;
			

			
			cmd.Param("switch").setAsString() = switch_key_0127;

			cmd.Execute();
		    con.Disconnect();

		
		}
		catch(SAException &x)
		{
		  // SAConnection::Rollback()
		  // can also throw an exception
		   // (if a network error for example),
		   // we will be ready
			 try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			 catch(SAException &)
			{
			}
	     // print error message
		   printf("%s\n", (const char*)x.ErrText());
		}
	}
		
/*
		strcpy(pan1,pan_number);
		strcpy(processing_code_F3,iso_field_value[3]);
		strcpy(transaction_amount_F4,iso_field_value[4]);
		strcpy(transmission_date_time_F7,iso_field_value[7]);
		strcpy(system_trace_audit_number_F11,iso_field_value[11]);
		strcpy(local_transaction_time_F12,iso_field_value[12]);
		strcpy(local_transaction_date_F13,iso_field_value[13]);
		strcpy(capture_date_F17,iso_field_value[17]);
		strcpy(acquiring_institution_id_code_F32,iso_field_value[32]);
		strcpy(track2_F35,iso_field_value[35]);
		strcpy(retrieval_reference_number_F37,iso_field_value[37]);
		strcpy(responde_id_response_038,iso_field_value[38]);
		strcpy(responde_code_039,iso_field_value[39]);
		strcpy(card_acceptor_terminal_id_F41,iso_field_value[41]);
				
		strcpy(card_acceptor_name_location_F43,iso_field_value[43]);
		strcpy(transaction_currency_code_F49,iso_field_value[49]);
		strcpy(pos_settlement_data_0125,iso_field_value[125]);

		SAConnection con; // create connection object
		SACommand cmd(&con);//,"SELECT * from  viewdetail_merchant where card_acceptor_terminal_id = :card_acceptor_terminal_id");    // command object

	
		try
		{
   
			con.Connect(
			"Btrans_trans",     // database name
			"sa",   // user name
			"",   // password
			SA_SQLServer_Client);

		    cmd.setConnection(&con);
			cout << name_user;
	
			char pan_from_db[17]	 = {""};
			char amount_from_db[17]	 = {""};
	        cmd.setConnection(&con);




			RWCString time_rw;
			RWTime t;
			time_rw = t.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
			
			cmd.setCommandText( \
			"INSERT INTO switch_discover(pan,processing_code,amount_trans,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local,capture_date, \
			adquiring_institution_id_code,track_ii_data,retrieval_reference_number,authorization_id_response,response_code,card_acceptor_terminal_id, \
			card_acceptor_name_location,currency_code_transaction, \
			pos_settlement_data,msg_type,date_local,in_req) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date,:capture_date, \
				 :acquiring_institution_id_code,:track2,:retrieval_reference_number,:authorization,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_name_location,:transaction_currency_code,\
				 :pos_settlement_data, \
				 :tran_type,:date_local,:in_time)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("capture_date").setAsString()					= local_transaction_date_F13;
			cmd.Param("acquiring_institution_id_code").setAsString()= acquiring_institution_id_code_F32;
			cmd.Param("track2").setAsString()						= "000000000000000000=00000000000000000000";
			cmd.Param("retrieval_reference_number").setAsString()   = retrieval_reference_number_F37;
			cmd.Param("authorization").setAsString()				= responde_id_response_038;
			cmd.Param("response").setAsString()						= responde_code_039;
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
			cmd.Param("tran_type").setAsString()					= "0220";
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
		
		
			cmd.Execute();
	
		    con.Disconnect();

		}
		catch(SAException &x)
		{
			// SAConnection::Rollback()
			// can also throw an exception
			// (if a network error for example),
			// we will be ready
			try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			catch(SAException &)

			{
			}
				// print error message
				printf("%s\n", (const char*)x.ErrText());
			}
*/		
//		}
	
////////////////////////////////////////////////////////////////////////////////////////////

	
	
	//return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583B24FromBanPais(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  track2_from_pan ;
	RWCString  track2_from_msg ;
	RWCString  msg_processing_053 ;
//	RWCString  field_53_exist;
	RWCString  bit_set_fiedl = "0";
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	int field_53_exist = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
//				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);

				if((j+1) == 48)
					response_0210_generic_from_iso +="00048"+msg_for_processing(next_field,var_field);
			
				if((j+1) == 60)
					response_0210_generic_from_iso +="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					response_0210_generic_from_iso +="00061"+msg_for_processing(next_field,var_field);


				if((j+1) == 63)
					response_0210_generic_from_iso +="00063"+msg_for_processing(next_field,var_field);


				if((j+1) == 120)
					response_0210_generic_from_iso +="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					response_0210_generic_from_iso +="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					response_0210_generic_from_iso += "00125"+msg_for_processing(next_field,var_field);
			
								
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					//response_0210_generic_from_iso += "00002"+msg_for_processing(next_field,var_field);
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					response_0210_generic_from_iso += "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					//response_0210_generic_from_iso += "00035"+msg_for_processing(next_field,var_field);
					track2_from_msg = msg_for_processing(next_field,var_field);
					field_53_exist = 1;;
				
				}
				
		
				if( (field_53_exist == 0) && ( (j+1) >= 32)  )
				{
					if( (pan_02.length() > 10) && (field_53_exist == 0) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

							track2_from_pan=test_pre;
						}
					  
					}

					
				}


				if((field_53_exist == 1)  && ( (j+1) == 35) ) 
				{
					response_0210_generic_from_iso +="00035"+track2_from_msg;
				}
				else
					response_0210_generic_from_iso +="00035"+track2_from_pan;
			
			
			
				if((j+1) == 2)
				{
				}
				else
					response_0210_generic_from_iso +=delimiter;
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						processing_banpais = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(processing_banpais == "203000")
						{
							new_processing_banpais = "223000";
						}
						else
						if(processing_banpais == "313000")
						{
							new_processing_banpais = "303000";
						}
					
						else
						{
							new_processing_banpais = "303000";
						}
					
						response_0210_generic_from_iso +="00003"+new_processing_banpais;
						response_0210_generic_from_iso +=delimiter;
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}			
		
			
				}
			
			}
		}
		
	}

    //iso_field_length[125] 
//	cout << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIsoGenericFromB24ForMonitor(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  field63_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = "     ";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;   iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[50] = 3; iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
			
				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					
					iso_field_value[2]= "00002"+msg_for_processing(next_field,var_field);
				}
				if((j+1) == 35)
				{
					
					
					//iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);

					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(msg_for_processing(next_field,var_field));
					int count2 = 0;
					
					while(!(token=next("=")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					iso_field_value[2] = primer_token;



				}
			
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
			
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
			
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[39]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
			
					}
				}
			
			}
		}
		
	}

 


	if((iso_field_value[2].length() == 0) && (iso_field_value[35].length() == 0))
		iso_field_value[2] = "0000000000000000";

	if(iso_field_value[38].length() == 0)
		iso_field_value[38] = "000000";

	if(iso_field_value[39].length() == 0)
		iso_field_value[39] = "WR";

	if((iso_field_value[61].length() != 0) && (iso_field_value[61](5,4) == "BM01"))
		iso_field_value[125] = "SVRCAPITALG";

		RWCString pan_pci = iso_field_value[2];
		pan_pci= pan_pci.replace(0,12,"************");

	
	response_0210_generic_from_iso = RWCString(msg_type)+delimiter+pan_pci+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[37]+delimiter+iso_field_value[38]
									 +delimiter+iso_field_value[39]+delimiter+iso_field_value[125];
	
	cout << "Message Input " << response_0210_generic_from_iso << endl;
	return response_0210_generic_from_iso;

}




RWCString MQUtility::SetIso8583B24FromTransPlata0200Pago(RWCString incoming , char *msg_type, 
										          int debug, RWCString application, RWCString field_42 )
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
					field48_RW=msg_for_processing(next_field,var_field);
					//iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field48_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

						//cout << "Valor de primer_token :" << primer_token << endl;
						//cout << "Valor de segundo_token :" << segundo_token << endl;

						
							RWCString test_pre=primer_token+"="+segundo_token(0,4);	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

					
							iso_field_value[35] = "00035"+test_pre;
					
					
					
							iso_field_value[14] = "00014"+segundo_token(0,4);
			
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
				iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
				}




				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);

					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(msg_for_processing(next_field,var_field));
					int count2 = 0;
					
					while(!(token=next("=")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					//RWCString field_63_pagos = "& 0000300095! P1100016 "+primer_token+" ! P1200004 "+iso_field_value[14](5,4);
					//RWCString field_63_pagos = "& 0000300095! P800016 "+primer_token+"! P900004 "+iso_field_value[14](5,4);
					//iso_field_value[63] = "00063"+field_63_pagos;

					RWCString field_48_pagos = primer_token+"!"+iso_field_value[14](5,4);

					RWCString test_pre=field_48_pagos;

					char pre_test = '\x30';
					size_t test = 27-test_pre.length();
					test_pre.append(pre_test , test);

					iso_field_value[48] = "00048"+test_pre;
					//cout << "Valor de test_pre > " << test_pre << endl;
				




				}
				
				if((j+1) >= 32)
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

				
							iso_field_value[35]= "00035"+test_pre;
						}
					  
					}

					
				}
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						processing_banpais = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						if(processing_banpais == "013030")
						{
							new_processing_banpais = "223030";
						}
					
					
						iso_field_value[3]="00003"+new_processing_banpais;
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}
    
 	iso_field_value[18] = "000186010";
	iso_field_value[42] = "00042"+field_42;
	iso_field_value[52] = "0005225142F80B444DBF0";

	iso_field_value[43] = "00043V01 VZLO CRED BU        CARACAS       VE";
	iso_field_value[63] = "00063& 0000300045!";
	iso_field_value[120] = "00120BANCO VENEZOLANO DE CREDITO  ";
	
	iso_field_value[123] = "00123"+iso_field_value[37](7,10)+iso_field_value[37](7,10);


	response_0210_generic_from_iso = "0200"+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]
									 +delimiter+iso_field_value[14]+delimiter+iso_field_value[17]+delimiter+iso_field_value[18]
									 +delimiter+iso_field_value[22]+delimiter+iso_field_value[25]+delimiter+iso_field_value[32]
									 +delimiter+iso_field_value[35]+delimiter+iso_field_value[37]+delimiter+iso_field_value[41]
									 +delimiter+iso_field_value[42]+delimiter+iso_field_value[43]+delimiter+iso_field_value[48]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[52]+delimiter+iso_field_value[60]
									 +delimiter+iso_field_value[61]+delimiter+iso_field_value[63]+delimiter+iso_field_value[120]
									 +delimiter+iso_field_value[123]+delimiter+iso_field_value[125];

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetSqlFieldFrom0420(RWCString incoming , char *msg_type, 
										           RWCString application )
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
	
		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
	
	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				
			
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
			
				if((j+1) == 2)
				{
					iso_field_value[2]=msg_for_processing(next_field,var_field);
				}
				
			
				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= msg_for_processing(next_field,var_field);
				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						
						iso_field_value[3]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

					
						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 37)
					{

					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 41)
					{

					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}	
					if(j+1 == 90)
					{

					
						iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}	
		
			
				}
			
			}
		}
		
	}
		response_0210_generic_from_iso = iso_field_value[2]+":"+iso_field_value[3]+":"+iso_field_value[90];


    /*
 	iso_field_value[18] = "000186010";
	iso_field_value[42] = "00042"+field_42;
	iso_field_value[52] = "0005225142F80B444DBF0";

	iso_field_value[43] = "00043V01 VZLO CRED BU        CARACAS       VE";
	iso_field_value[63] = "00063& 0000300045!";
	iso_field_value[120] = "00120BANCO VENEZOLANO DE CREDITO  ";
	
	iso_field_value[123] = "00123"+iso_field_value[37](7,10)+iso_field_value[37](7,10);


	response_0210_generic_from_iso = "0200"+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]
									 +delimiter+iso_field_value[14]+delimiter+iso_field_value[17]+delimiter+iso_field_value[18]
									 +delimiter+iso_field_value[22]+delimiter+iso_field_value[25]+delimiter+iso_field_value[32]
									 +delimiter+iso_field_value[35]+delimiter+iso_field_value[37]+delimiter+iso_field_value[41]
									 +delimiter+iso_field_value[42]+delimiter+iso_field_value[43]+delimiter+iso_field_value[48]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[52]+delimiter+iso_field_value[60]
									 +delimiter+iso_field_value[61]+delimiter+iso_field_value[63]+delimiter+iso_field_value[120]
									 +delimiter+iso_field_value[123]+delimiter+iso_field_value[125];

*/
		char pan1[17]								= "4931372032057778";
		char msg_type_sql[5]						= "0420";								
		char processing_code_F3[7]					= "000000";              
		char transaction_amount_F4[13]				= "000000001000"; 
		char transmission_date_time_F7[11]			= "1122185321";       
		char system_trace_audit_number_F11[7]		= "051767";
		char local_transaction_time_F12[7]			= "125321";
		char local_transaction_date_F13[5]			= "0607";
		char track2_F35[38]							= "5400831500012011=040900000000000000";
		char responde_code_039[3]					= "91";
		char card_acceptor_terminal_id_F41[17]		= "239387912393    ";
		char card_acceptor_id_code_F42[16]			= "349000003      ";
		char card_acceptor_name_location_F43[41]	= "FERRETERIA AMERICANA REP. DOM.       DOM";
		char transaction_currency_code_F49[4]		= "214";
		char pos_terminal_data_60[17]				= "TERMPR04TES40000";
		char pos_invoice_data_123[21]				= "          9397910019";
		char pos_settlement_data_0125[13]			= "  HOSTB24 10";
		char switch_key_char[43]					= {""};
		char tran_type[3]							= {""};
	
	
		strcpy(pan1,iso_field_value[2]);
		strcpy(processing_code_F3,iso_field_value[3]);
		strcpy(transaction_amount_F4,iso_field_value[4]);
		strcpy(transmission_date_time_F7,iso_field_value[7]);
		strcpy(system_trace_audit_number_F11,iso_field_value[11]);
		strcpy(local_transaction_time_F12,iso_field_value[12]);
		strcpy(local_transaction_date_F13,iso_field_value[13]);
		strcpy(track2_F35,iso_field_value[35]);
		strcpy(card_acceptor_terminal_id_F41,iso_field_value[41]);
		strcpy(card_acceptor_id_code_F42,iso_field_value[42]);
		strcpy(card_acceptor_name_location_F43,iso_field_value[43]);
		strcpy(transaction_currency_code_F49,iso_field_value[49]);
		strcpy(pos_terminal_data_60,iso_field_value[60]);
		strcpy(pos_invoice_data_123,iso_field_value[123]);
		strcpy(pos_settlement_data_0125,iso_field_value[125]);
		strcpy(switch_key_char,iso_field_value[90]);
	
		SAConnection con; // create connection object
		SACommand cmd(&con);
		try
		{
   
			con.Connect(
			"Btrans_Trans",     // database name
			"sa",   // user name
			"gc2436",   // password
			SA_SQLServer_Client);
			 cmd.setConnection(&con);
			 
			RWCString time_rw;
			RWTime t;
			time_rw = t.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
			
			
			cmd.setCommandText( \
			"INSERT INTO switch_pagos(pan,processing_code,amount_trans,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local, \
			track_ii_data,response_code,card_acceptor_terminal_id, \
			card_acceptor_id_code,card_acceptor_name_location,currency_code_transaction,\
		    card_issuer_category_data,pos_data_code,pos_settlement_data,msg_type, \
			tran_type,date_local,in_req,switch_key) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date, \
				 :track2,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_id_code,:card_acceptor_name_location,:transaction_currency_code, \
				 :pos_terminal_data,:pos_invoice_data,:pos_settlement_data, \
				 :msg_type_sql,:tran_type,:date_local,:in_time,:switch_key)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("track2").setAsString()						= track2_F35;
			cmd.Param("response").setAsString()						= "00";
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;
			cmd.Param("card_acceptor_id_code").setAsString()		= card_acceptor_id_code_F42;
			cmd.Param("card_acceptor_name_location").setAsString()	= card_acceptor_name_location_F43;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("pos_terminal_data").setAsString()			= pos_terminal_data_60;
			cmd.Param("pos_invoice_data").setAsString()				= pos_invoice_data_123;
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
			cmd.Param("msg_type_sql").setAsString()					= msg_type_sql;
			cmd.Param("tran_type").setAsString()					= tran_type;
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
			
			cmd.Param("switch_key").setAsString()					= switch_key_char;
		
			cmd.Execute();
	
		    con.Disconnect();

		}
		catch(SAException &x)
		{
			// SAConnection::Rollback()
			// can also throw an exception
			// (if a network error for example),
			// we will be ready
			try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			catch(SAException &)
			{
			
			}
				// print error message
			printf("%s\n", (const char*)x.ErrText());
		}
		
////////////////////////////////////////////////////////////////////////////////////////////

	

	return response_0210_generic_from_iso;

}


RWCString MQUtility::SetSqlFieldFrom0420ATH(RWCString incoming , char *msg_type, 
										           RWCString application )
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
	
		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
	
	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				
			
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
			
				if((j+1) == 2)
				{
					iso_field_value[2]=msg_for_processing(next_field,var_field);
				}
				
			
				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= msg_for_processing(next_field,var_field);
				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						
						iso_field_value[3]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

					
						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 37)
					{

					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 41)
					{

					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}	
					if(j+1 == 90)
					{

					
						iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}	
		
			
				}
			
			}
		}
		
	}
		response_0210_generic_from_iso = iso_field_value[2]+":"+iso_field_value[3]+":"+iso_field_value[90];


    /*
 	iso_field_value[18] = "000186010";
	iso_field_value[42] = "00042"+field_42;
	iso_field_value[52] = "0005225142F80B444DBF0";

	iso_field_value[43] = "00043V01 VZLO CRED BU        CARACAS       VE";
	iso_field_value[63] = "00063& 0000300045!";
	iso_field_value[120] = "00120BANCO VENEZOLANO DE CREDITO  ";
	
	iso_field_value[123] = "00123"+iso_field_value[37](7,10)+iso_field_value[37](7,10);


	response_0210_generic_from_iso = "0200"+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]
									 +delimiter+iso_field_value[14]+delimiter+iso_field_value[17]+delimiter+iso_field_value[18]
									 +delimiter+iso_field_value[22]+delimiter+iso_field_value[25]+delimiter+iso_field_value[32]
									 +delimiter+iso_field_value[35]+delimiter+iso_field_value[37]+delimiter+iso_field_value[41]
									 +delimiter+iso_field_value[42]+delimiter+iso_field_value[43]+delimiter+iso_field_value[48]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[52]+delimiter+iso_field_value[60]
									 +delimiter+iso_field_value[61]+delimiter+iso_field_value[63]+delimiter+iso_field_value[120]
									 +delimiter+iso_field_value[123]+delimiter+iso_field_value[125];

*/
		char pan1[17]								= "4931372032057778";
		char msg_type_sql[5]						= "0420";								
		char processing_code_F3[7]					= "000000";              
		char transaction_amount_F4[13]				= "000000001000"; 
		char transmission_date_time_F7[11]			= "1122185321";       
		char system_trace_audit_number_F11[7]		= "051767";
		char local_transaction_time_F12[7]			= "125321";
		char local_transaction_date_F13[5]			= "0607";
		char track2_F35[38]							= "5400831500012011=040900000000000000";
		char responde_code_039[3]					= "91";
		char card_acceptor_terminal_id_F41[17]		= "239387912393    ";
		char card_acceptor_id_code_F42[16]			= "349000003      ";
		char card_acceptor_name_location_F43[41]	= "FERRETERIA AMERICANA REP. DOM.       DOM";
		char transaction_currency_code_F49[4]		= "214";
		char pos_terminal_data_60[17]				= "TERMPR04TES40000";
		char pos_invoice_data_123[21]				= "          9397910019";
		char pos_settlement_data_0125[13]			= "  HOSTB24 10";
		char switch_key_char[43]					= {""};
		char tran_type[3]							= {""};
	
	
		strcpy(pan1,iso_field_value[2]);
		strcpy(processing_code_F3,iso_field_value[3]);
		strcpy(transaction_amount_F4,iso_field_value[4]);
		strcpy(transmission_date_time_F7,iso_field_value[7]);
		strcpy(system_trace_audit_number_F11,iso_field_value[11]);
		strcpy(local_transaction_time_F12,iso_field_value[12]);
		strcpy(local_transaction_date_F13,iso_field_value[13]);
		strcpy(track2_F35,iso_field_value[35]);
		strcpy(card_acceptor_terminal_id_F41,iso_field_value[41]);
		strcpy(card_acceptor_id_code_F42,iso_field_value[42]);
		strcpy(card_acceptor_name_location_F43,iso_field_value[43]);
		strcpy(transaction_currency_code_F49,iso_field_value[49]);
		strcpy(pos_terminal_data_60,iso_field_value[60]);
		strcpy(pos_invoice_data_123,iso_field_value[123]);
		strcpy(pos_settlement_data_0125,iso_field_value[125]);
		strcpy(switch_key_char,iso_field_value[90]);
	
		SAConnection con; // create connection object
		SACommand cmd(&con);
		try
		{
   
			con.Connect(
			"Btrans_Trans",     // database name
			"sa",   // user name
			"gc2436",   // password
			SA_SQLServer_Client);
			 cmd.setConnection(&con);
			 
			RWCString time_rw;
			RWTime t;
			time_rw = t.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
			
			
			cmd.setCommandText( \
			"INSERT INTO switch_pagos(pan,processing_code,amount_trans,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local, \
			track_ii_data,response_code,card_acceptor_terminal_id, \
			card_acceptor_id_code,card_acceptor_name_location,currency_code_transaction,\
		    card_issuer_category_data,pos_data_code,pos_settlement_data,msg_type, \
			tran_type,date_local,in_req,switch_key) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date, \
				 :track2,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_id_code,:card_acceptor_name_location,:transaction_currency_code, \
				 :pos_terminal_data,:pos_invoice_data,:pos_settlement_data, \
				 :msg_type_sql,:tran_type,:date_local,:in_time,:switch_key)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("track2").setAsString()						= track2_F35;
			cmd.Param("response").setAsString()						= "00";
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;
			cmd.Param("card_acceptor_id_code").setAsString()		= card_acceptor_id_code_F42;
			cmd.Param("card_acceptor_name_location").setAsString()	= card_acceptor_name_location_F43;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("pos_terminal_data").setAsString()			= pos_terminal_data_60;
			cmd.Param("pos_invoice_data").setAsString()				= pos_invoice_data_123;
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
			cmd.Param("msg_type_sql").setAsString()					= msg_type_sql;
			cmd.Param("tran_type").setAsString()					= tran_type;
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
			
			cmd.Param("switch_key").setAsString()					= switch_key_char;
		
			cmd.Execute();
	
		    con.Disconnect();

		}
		catch(SAException &x)
		{
			// SAConnection::Rollback()
			// can also throw an exception
			// (if a network error for example),
			// we will be ready
			try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			catch(SAException &)
			{
			
			}
				// print error message
			printf("%s\n", (const char*)x.ErrText());
		}
		
////////////////////////////////////////////////////////////////////////////////////////////

	

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetSqlFieldFrom0420Vicana(RWCString incoming , char *msg_type, 
										           RWCString application )
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
	
		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
	
	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				
			
				if((j+1) == 60)
					iso_field_value[60]=msg_for_processing(next_field,var_field);


				if((j+1) == 123)
					iso_field_value[123]=msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
			
				if((j+1) == 2)
				{
					iso_field_value[2]=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= msg_for_processing(next_field,var_field);
				}

				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= msg_for_processing(next_field,var_field);
				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						
						iso_field_value[3]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

					
						iso_field_value[4]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

					
						iso_field_value[7]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

					
						iso_field_value[11]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

					
						iso_field_value[12]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

					
						iso_field_value[13]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

					
						iso_field_value[37]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 41)
					{

					
						iso_field_value[41]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

					
						iso_field_value[42]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

					
						iso_field_value[43]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

					
						iso_field_value[49]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}	
					if(j+1 == 90)
					{

					
						iso_field_value[90]=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}	
		
			
				}
			
			}
		}
		
	}
		response_0210_generic_from_iso = iso_field_value[2]+":"+iso_field_value[3]+":"+iso_field_value[90];


    /*
 	iso_field_value[18] = "000186010";
	iso_field_value[42] = "00042"+field_42;
	iso_field_value[52] = "0005225142F80B444DBF0";

	iso_field_value[43] = "00043V01 VZLO CRED BU        CARACAS       VE";
	iso_field_value[63] = "00063& 0000300045!";
	iso_field_value[120] = "00120BANCO VENEZOLANO DE CREDITO  ";
	
	iso_field_value[123] = "00123"+iso_field_value[37](7,10)+iso_field_value[37](7,10);


	response_0210_generic_from_iso = "0200"+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]
									 +delimiter+iso_field_value[14]+delimiter+iso_field_value[17]+delimiter+iso_field_value[18]
									 +delimiter+iso_field_value[22]+delimiter+iso_field_value[25]+delimiter+iso_field_value[32]
									 +delimiter+iso_field_value[35]+delimiter+iso_field_value[37]+delimiter+iso_field_value[41]
									 +delimiter+iso_field_value[42]+delimiter+iso_field_value[43]+delimiter+iso_field_value[48]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[52]+delimiter+iso_field_value[60]
									 +delimiter+iso_field_value[61]+delimiter+iso_field_value[63]+delimiter+iso_field_value[120]
									 +delimiter+iso_field_value[123]+delimiter+iso_field_value[125];

*/
		char pan1[17]								= "4931372032057778";
		char msg_type_sql[5]						= "0420";								
		char processing_code_F3[7]					= "000000";              
		char transaction_amount_F4[13]				= "000000001000"; 
		char transmission_date_time_F7[11]			= "1122185321";       
		char system_trace_audit_number_F11[7]		= "051767";
		char local_transaction_time_F12[7]			= "125321";
		char local_transaction_date_F13[5]			= "0607";
		char acquiring_institution_id_code_F32[10]	= "000077185";
		char retrieval_reference_number_F37[13]		= "339397910019";
		char track2_F35[38]							= "5400831500012011=040900000000000000";
		char responde_code_039[3]					= "91";
		char card_acceptor_terminal_id_F41[17]		= "239387912393    ";
		char card_acceptor_id_code_F42[16]			= "349000003      ";
		char card_acceptor_name_location_F43[41]	= "FERRETERIA AMERICANA REP. DOM.       DOM";
		char transaction_currency_code_F49[4]		= "214";
		char pos_terminal_data_60[17]				= "TERMPR04TES40000";
		char pos_invoice_data_123[21]				= "          9397910019";
		char pos_settlement_data_0125[13]			= "VICANA      ";
		char switch_key_char[43]					= {""};
		char tran_type[3]							= {""};
	
	
		strcpy(pan1,iso_field_value[2]);
		strcpy(processing_code_F3,iso_field_value[3]);
		strcpy(transaction_amount_F4,iso_field_value[4]);
		strcpy(transmission_date_time_F7,iso_field_value[7]);
		strcpy(system_trace_audit_number_F11,iso_field_value[11]);
		strcpy(local_transaction_time_F12,iso_field_value[12]);
		strcpy(local_transaction_date_F13,iso_field_value[13]);
		strcpy(acquiring_institution_id_code_F32,iso_field_value[32]);
		strcpy(track2_F35,iso_field_value[35]);
		strcpy(retrieval_reference_number_F37,iso_field_value[37]);
		strcpy(card_acceptor_terminal_id_F41,iso_field_value[41]);
		strcpy(card_acceptor_id_code_F42,iso_field_value[42]);
		strcpy(card_acceptor_name_location_F43,iso_field_value[43]);
		strcpy(transaction_currency_code_F49,iso_field_value[49]);
		strcpy(pos_terminal_data_60,iso_field_value[60]);
		strcpy(pos_invoice_data_123,iso_field_value[123]);
		strcpy(pos_settlement_data_0125,"VICANA      ");
		strcpy(switch_key_char,iso_field_value[90]);


		RWCTokenizer next(iso_field_value[35]);
		RWCString token;
		//char pan_number[100]	 = {""};
		char resto_track2[100]	= {""};
		int counter = 0;
		RWCString valor_exdate_from_track2;


		if(iso_field_value[35].contains("=") )
		{



			while(!(token=next("=")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan1 , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}
		
		if(iso_field_value[35].contains("D") )
		{



			while(!(token=next("D")).isNull())
			{
	
		
				if (counter == 0)
				{
		
		
					strcpy(pan1 , ((LPCTSTR) (RWCString)token));

				}
		
				if (counter == 1)
				{
		
		
					strcpy(resto_track2, ((LPCTSTR) (RWCString)token));

				}		
	
				counter ++;
			}
		}


	
		SAConnection con; // create connection object
		SACommand cmd(&con);
		try
		{
   
			con.Connect(
			"Btrans_Trans",     // database name
			"sa",   // user name
			"gc2436",   // password
			SA_SQLServer_Client);
			 cmd.setConnection(&con);
			 
			RWCString time_rw;
			RWTime t;
			time_rw = t.asString('\0', RWZone::local());
			char time_in_db[30] = {""};
			strcpy (time_in_db, time_rw);
			
			
			cmd.setCommandText( \
			"INSERT INTO switch_vicana(pan,processing_code,amount_trans,transm_date_time,system_trace_audit_number, \
			trans_time_local, trans_date_local, adquiring_institution_id_code, \
			track_ii_data,retrieval_reference_number,response_code,card_acceptor_terminal_id, \
			card_acceptor_id_code,card_acceptor_name_location,currency_code_transaction,\
		    card_issuer_category_data,pos_data_code,pos_settlement_data,msg_type, \
			tran_type,date_local,in_req,switch_key) \
			VALUES \
			(:pan_card,:processing_code, :transaction_amount,:transmission_date_time,:system_trace_audit_number, \
				 :local_transaction_time,:local_transaction_date, \
				 :acquiring_institution_id_code,:track2,:retrieval_reference_number,:response,:card_acceptor_terminal_id, \
				 :card_acceptor_id_code,:card_acceptor_name_location,:transaction_currency_code, \
				 :pos_terminal_data,:pos_invoice_data,:pos_settlement_data, \
				 :msg_type_sql,:tran_type,:date_local,:in_time,:switch_key)") ;    // command object

			cmd.Param("pan_card").setAsString()						= pan1;
			cmd.Param("processing_code").setAsString()				= processing_code_F3;
			cmd.Param("transaction_amount").setAsString()			= transaction_amount_F4;
			cmd.Param("transmission_date_time").setAsString()		= transmission_date_time_F7;
			cmd.Param("system_trace_audit_number").setAsString()	= system_trace_audit_number_F11;
			cmd.Param("local_transaction_time").setAsString()		= local_transaction_time_F12;
			cmd.Param("local_transaction_date").setAsString()		= local_transaction_date_F13;
			cmd.Param("acquiring_institution_id_code").setAsString()= acquiring_institution_id_code_F32;
			cmd.Param("track2").setAsString()						= "0000000000000000=00000000000000000000";
			cmd.Param("retrieval_reference_number").setAsString()   = retrieval_reference_number_F37;
			cmd.Param("response").setAsString()						= "00";
			cmd.Param("card_acceptor_terminal_id").setAsString()	= card_acceptor_terminal_id_F41;
			cmd.Param("card_acceptor_id_code").setAsString()		= card_acceptor_id_code_F42;
			cmd.Param("card_acceptor_name_location").setAsString()	= card_acceptor_name_location_F43;
			cmd.Param("transaction_currency_code").setAsString()    = transaction_currency_code_F49;
			cmd.Param("pos_terminal_data").setAsString()			= pos_terminal_data_60;
			cmd.Param("pos_invoice_data").setAsString()				= pos_invoice_data_123;
			cmd.Param("pos_settlement_data").setAsString()			= pos_settlement_data_0125;
			cmd.Param("msg_type_sql").setAsString()					= msg_type_sql;
			cmd.Param("tran_type").setAsString()					= tran_type;
			cmd.Param("date_local").setAsString() 					= time_in_db;
			cmd.Param("in_time").setAsString()	 					= time_in_db;
			
			cmd.Param("switch_key").setAsString()					= switch_key_char;
		
			cmd.Execute();
	
		    con.Disconnect();

		}
		catch(SAException &x)
		{
			// SAConnection::Rollback()
			// can also throw an exception
			// (if a network error for example),
			// we will be ready
			try
			{
		       // on error rollback changes
				 con.Rollback();
			}
			catch(SAException &)
			{
			
			}
				// print error message
			printf("%s\n", (const char*)x.ErrText());
		}
		
////////////////////////////////////////////////////////////////////////////////////////////

	

	return response_0210_generic_from_iso;

}


RWCString MQUtility::SetIso8583B24FromTransPlata0420Pago(RWCString incoming , char *msg_type, 
										          int debug, RWCString application, RWCString field_125 )
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				/*
				if((j+1) == 48)
				{
					field48_RW=msg_for_processing(next_field,var_field);
					//iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field48_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

						//cout << "Valor de primer_token :" << primer_token << endl;
						//cout << "Valor de segundo_token :" << segundo_token << endl;

						
							RWCString test_pre=primer_token+"="+segundo_token(0,4);	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

					
							iso_field_value[35] = "00035"+test_pre;
					
					
					
							iso_field_value[14] = "00014"+segundo_token(0,4);
			
				
				}
				*/
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);

				/*
				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
				iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
				}




				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);
				*/
			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);

					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(msg_for_processing(next_field,var_field));
					int count2 = 0;
					
					while(!(token=next("=")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					iso_field_value[2] = "00002"+primer_token;
					/*
					RWCString field_48_pagos = primer_token+"!"+iso_field_value[14](5,4);

					RWCString test_pre=field_48_pagos;

					char pre_test = '\x30';
					size_t test = 27-test_pre.length();
					test_pre.append(pre_test , test);

					iso_field_value[48] = "00048"+test_pre;
					//cout << "Valor de test_pre > " << test_pre << endl;
				*/




				}
				
				if((j+1) >= 32)
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

				
							iso_field_value[35]= "00035"+test_pre;
						}
					  
					}

					
				}
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						/*
						if(processing_banpais == "013030")
						{
							new_processing_banpais = "223030";
						}
					
					
						iso_field_value[3]="00003"+new_processing_banpais;
						*/
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				/*
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					*/
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}
    
 	//iso_field_value[18] = "000186010";
	//iso_field_value[42] = "00042"+field_42;
	//iso_field_value[52] = "0005225142F80B444DBF0";

	//iso_field_value[43] = "00043V01 VZLO CRED BU        CARACAS       VE";
	//iso_field_value[63] = "00063& 0000300045!";
	//iso_field_value[120] = "00120BANCO VENEZOLANO DE CREDITO  ";
	
	iso_field_value[90] = "000900200"+iso_field_value[37](5,12)+iso_field_value[7](5,10)+"0000000000000000";
	iso_field_value[125] = "00125"+field_125;
	

	response_0210_generic_from_iso = "0420"+delimiter+iso_field_value[2]+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]+delimiter+iso_field_value[35]
									 +delimiter+iso_field_value[37]+delimiter+iso_field_value[41]+delimiter+iso_field_value[42]+delimiter+iso_field_value[43]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[60]+delimiter+iso_field_value[90]+delimiter+iso_field_value[123]
									 +delimiter+iso_field_value[125];

	return response_0210_generic_from_iso;

}


RWCString MQUtility::Set0420BtransFormatFromIso8583(RWCString incoming , char *msg_type, 
										          int debug, RWCString application, RWCString field_125 )
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				/*
				if((j+1) == 48)
				{
					field48_RW=msg_for_processing(next_field,var_field);
					//iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field48_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

						//cout << "Valor de primer_token :" << primer_token << endl;
						//cout << "Valor de segundo_token :" << segundo_token << endl;

						
							RWCString test_pre=primer_token+"="+segundo_token(0,4);	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

					
							iso_field_value[35] = "00035"+test_pre;
					
					
					
							iso_field_value[14] = "00014"+segundo_token(0,4);
			
				
				}
				*/
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);

				/*
				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
				iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
				}




				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);
				*/
			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]= "00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);

					/*
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(msg_for_processing(next_field,var_field));
					int count2 = 0;
					
					while(!(token=next("=")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					iso_field_value[2] = "00002"+primer_token;
					*/
					  /*
					RWCString field_48_pagos = primer_token+"!"+iso_field_value[14](5,4);

					RWCString test_pre=field_48_pagos;

					char pre_test = '\x30';
					size_t test = 27-test_pre.length();
					test_pre.append(pre_test , test);

					iso_field_value[48] = "00048"+test_pre;
					//cout << "Valor de test_pre > " << test_pre << endl;
				*/




				}
				/*
				if((j+1) >= 32)
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

				
							iso_field_value[35]= "00035"+test_pre;
						}
					  
					}

					
				}
	*/
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[3] = "00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						/*
						if(processing_banpais == "013030")
						{
							new_processing_banpais = "223030";
						}
					
					
						iso_field_value[3]="00003"+new_processing_banpais;
						*/
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					
					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}
    
 	//iso_field_value[18] = "000186010";
	//iso_field_value[42] = "00042"+field_42;
	//iso_field_value[52] = "0005225142F80B444DBF0";

	//iso_field_value[43] = "00043V01 VZLO CRED BU        CARACAS       VE";
	//iso_field_value[63] = "00063& 0000300045!";
	//iso_field_value[120] = "00120BANCO VENEZOLANO DE CREDITO  ";
	
	iso_field_value[90] = "000900200"+iso_field_value[37](5,12)+iso_field_value[13](5,4)+iso_field_value[12](5,6)+"0000000000000000";
	iso_field_value[125] = "00125"+field_125;
	

	if (iso_field_value[39].length() == 0)
		iso_field_value[39] = "00039R9";
	
	/*
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
			//cout << j <<  " " << iso_field_value[j] << endl;

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
*/
/*
	response_0210_generic_from_iso = "0420"+delimiter+iso_field_value[2]+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]+delimiter+iso_field_value[35]
									 +delimiter+iso_field_value[37]+delimiter+iso_field_value[41]+delimiter+iso_field_value[42]+delimiter+iso_field_value[43]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[60]+delimiter+iso_field_value[90]+delimiter+iso_field_value[123]
									 +delimiter+iso_field_value[125];

*/
	response_0210_generic_from_iso = "0420"+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]+delimiter+iso_field_value[14]
									 +delimiter+iso_field_value[17]+delimiter+iso_field_value[18]+delimiter+iso_field_value[22]+delimiter+iso_field_value[25]
									 +delimiter+iso_field_value[32]
									 +delimiter+iso_field_value[35]
									 +delimiter+iso_field_value[37]+delimiter+iso_field_value[39]+delimiter+iso_field_value[41]+delimiter+iso_field_value[42]+delimiter+iso_field_value[43]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[60]+delimiter+iso_field_value[61]+delimiter+iso_field_value[90]+delimiter+iso_field_value[123]
									 +delimiter+iso_field_value[125];

	
	
	return response_0210_generic_from_iso;

}




RWCString MQUtility::SetIso8583B24FromTransPlata0210(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
					field48_RW=msg_for_processing(next_field,var_field);
					//iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field48_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					//	cout << "Valor de primer_token :" << primer_token << endl;
					//	cout << "Valor de segundo_token :" << segundo_token << endl;

						
							RWCString test_pre=primer_token+"="+segundo_token(0,4);	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

					
							iso_field_value[35] = "00035"+test_pre;
					
					
					
							iso_field_value[14] = "00014"+segundo_token(0,4);
			
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
				iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
				//field63_RW=msg_for_processing(next_field,var_field);
			/*
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field63_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
						if (count2 == 2)
						{
							tercer_token= token;
						}
						count2++;
					}

						cout << "Valor de segundo_token :" << segundo_token << endl;
						cout << "Valor de tercer_token :" << tercer_token << endl;

						
							RWCString test_pre=segundo_token(9,segundo_token.length()-9)+"="+tercer_token(9,tercer_token.length()-9);	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

					
							iso_field_value[35] = "00035"+test_pre;
					
					
					
							iso_field_value[14] = "00014"+tercer_token(9,tercer_token.length()-9);
				*/
				}




				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					pan_02=msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);

					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(msg_for_processing(next_field,var_field));
					int count2 = 0;
					
					while(!(token=next("=")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
					
						count2++;
					}

					//RWCString field_63_pagos = "& 0000300095! P1100016 "+primer_token+" ! P1200004 "+iso_field_value[14](5,4);
					//RWCString field_63_pagos = "& 0000300095! P800016 "+primer_token+"! P900004 "+iso_field_value[14](5,4);
					//iso_field_value[63] = "00063"+field_63_pagos;

					RWCString field_48_pagos = primer_token+"!"+iso_field_value[14](5,4);

					RWCString test_pre=field_48_pagos;

					char pre_test = '\x30';
					size_t test = 27-test_pre.length();
					test_pre.append(pre_test , test);

					iso_field_value[48] = "00048"+test_pre;
				//	cout << "Valor de test_pre > " << test_pre << endl;
				




				}
				
				if((j+1) >= 32)
				{
					if( (pan_02.length() > 10) ) //&& (iso_field_length[35] == 0))
					{
							
						if(iso_field_length[35] == 0)
						{
					
							track_02=pan_02+"="+expiration_date;
						
							RWCString test_pre=track_02;	

							char pre_test = '\x30';
							size_t test = 37-test_pre.length();
							test_pre.append(pre_test , test);

				
							iso_field_value[35]= "00035"+test_pre;
						}
					  
					}

					
				}
			
				if((j+1) == 2)
				{
				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
						RWCString processing_banpais = "";
						RWCString new_processing_banpais = "";

						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						processing_banpais = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						
						if(processing_banpais == "013030")
						{
							new_processing_banpais = "402020";
						}
					
						else
						{
							new_processing_banpais = "303000";
						}
					
						iso_field_value[3]="00003"+new_processing_banpais;
							}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						
						iso_field_value[38] = "00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1])+"0000";
						iso_field_value[39]="00039"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						
						
						RWCString doble_nine = "99";
						iso_field_value[39]="00039"+doble_nine;
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}
	response_0210_generic_from_iso = "0210,";
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
			//cout << j <<  " " << iso_field_value[j] << endl;

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
//	cout << "Valor de test_output " << test_output << endl; 
/*
	response_0210_generic_from_iso = "0210"+delimiter+iso_field_value[3]+delimiter+iso_field_value[4]+delimiter+iso_field_value[7]
		                             +delimiter+iso_field_value[11]+delimiter+iso_field_value[12]+delimiter+iso_field_value[13]
									 +delimiter+iso_field_value[14]+delimiter+iso_field_value[18]
									 +delimiter+iso_field_value[22]+delimiter+iso_field_value[25]+delimiter+iso_field_value[32]
									 +delimiter+iso_field_value[35]+delimiter+iso_field_value[37]+delimiter+iso_field_value[41]
									 +delimiter+iso_field_value[48]
									 +delimiter+iso_field_value[49]+delimiter+iso_field_value[60]
									 +delimiter+iso_field_value[61]+delimiter+iso_field_value[63]
								     +delimiter+iso_field_value[125];
*/


	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583B24Msg0210FromIso8583B24Msg0200(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		
		if(incoming(14,4) == "0200")
			response_0210_generic_from_iso += "0210";

		if(incoming(14,4) == "0800")
			response_0210_generic_from_iso += "0810";
	//	else
	//		response_0210_generic_from_iso += incoming(14,4);



		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
						iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
							
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
		
				}

				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
				
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 100)
				{
					
					
					iso_field_value[100]= "00100"+msg_for_processing(next_field,var_field);


				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
									
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						
						//RWCString doble_nine = "99";
						iso_field_value[39]="0003900";
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}

	if (iso_field_value[38].length() == 0)
		iso_field_value[38] = "00038"+iso_field_value[11](5,6);
	
	if (iso_field_value[39].length() == 0)
		iso_field_value[39] = "0003900";
	
	
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
	
	RWCString test_now = test_iso_new.SetIso8583B24FromBtransFormat(response_0210_generic_from_iso,"base24","ISO025000050",0);
	response_0210_generic_from_iso = test_now;

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583B24Msg0210FromIso8583B24Msg0200(RWCString incoming , char *msg_type, 
										          int debug, RWCString application,RWCString answer)
{


	RWCString response_0210_generic_from_iso;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;
	iso_field_length[19] = 3;
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 8;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		
		if(incoming(14,4) == "0200")
			response_0210_generic_from_iso += "0210";

		if(incoming(14,4) == "0800")
			response_0210_generic_from_iso += "0810";
	//	else
	//		response_0210_generic_from_iso += incoming(14,4);



		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
						iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
							
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
		
				}

				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
				

				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
				
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 100)
				{
					
					
					iso_field_value[100]= "00100"+msg_for_processing(next_field,var_field);


				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
									
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						
						//RWCString doble_nine = "99";
						iso_field_value[39]="0003900";
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
			
				}
			
			}
		}
		
	}

	if (iso_field_value[38].length() == 0)
		iso_field_value[38] = "00038000000";
	
	if (iso_field_value[39].length() == 0)
		iso_field_value[39] = "00039"+answer;
	
	
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
	//cout << "Valor de response_0210_generic_from_iso > " << response_0210_generic_from_iso << endl;
	
	RWCString test_now = test_iso_new.SetIso8583B24FromBtransFormat(response_0210_generic_from_iso,"base24","ISO025000050",0);
	response_0210_generic_from_iso = test_now;

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583B24Msg0200FromIso8583B24Msg0200VBV(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString response_0210_generic_from_iso;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;
	iso_field_length[19] = 3;
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		//response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		
		if(incoming(14,4) == "0200")
			response_0210_generic_from_iso += "0200";

		if(incoming(14,4) == "0800")
			response_0210_generic_from_iso += "0810";
	//	else
	//		response_0210_generic_from_iso += incoming(14,4);



		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
						iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
							
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
					/*

					RWCString field63_RW=msg_for_processing(next_field,var_field);
		
					RWCString token;
					RWCString primer_token,segundo_token,tercer_token;
					RWCTokenizer next(field63_RW);
					int count2 = 0;
					
					while(!(token=next("!")).isNull())
					{
						if (count2 == 0)
						{
							primer_token = token;
						}
						if (count2 == 1)
						{
							segundo_token= token;
						}
						if (count2 == 2)
						{
							tercer_token= token;
						}
						count2++;
					}

						cout << "Valor de primero_token :" << primer_token << endl;
						cout << "Valor de segundo_token :" << segundo_token << endl;

						cout << "Valor de tercer_token :" << tercer_token << endl;

		
						//field63_RW =primer_token+"!"+segundo_token+"!"+tercer_token(0,8)+RetornoHexadecimalComplete(tercer_token(8,40),20);

						field63_RW =primer_token+"!"+segundo_token+"!"+tercer_token;

						
						cout << "Valor de field63_RW :" << field63_RW << endl;

						iso_field_value[63]="00063"+field63_RW;
						
						//RetornoHexadecimalComplete(tercer_token(8,40),20)

					*/
				}

				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
				

				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
				
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 100)
				{
					
					
					iso_field_value[100]= "00100"+msg_for_processing(next_field,var_field);


				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
									
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						
						//RWCString doble_nine = "99";
						iso_field_value[39]="0003900";
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[52]="00052"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
				}
			
			}
		}
		
	}
/*
	if (iso_field_value[38].length() == 0)
		iso_field_value[38] = "00038000000";
	
	if (iso_field_value[39].length() == 0)
		iso_field_value[39] = "00039"+answer;
*/	
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
	//cout << "Valor de response_0210_generic_from_iso > " << response_0210_generic_from_iso << endl;
	
	RWCString test_now = test_iso_new.SetIso8583B24FromBtransFormatVBV(response_0210_generic_from_iso,"base24","ISO025000050",0);
	response_0210_generic_from_iso = test_now;

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583B24Msg0200FromIso8583B24Msg0200VBV1C(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString response_0210_generic_from_iso;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = '\x1C';
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;
	iso_field_length[19] = 3;
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		//response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		
		if(incoming(14,4) == "0200")
			response_0210_generic_from_iso += "0200";

		if(incoming(14,4) == "0800")
			response_0210_generic_from_iso += "0810";



		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
						iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
							
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);
		
				if((j+1) == 63)
				{
					
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				}

				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);
				

				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
				
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 100)
				{
					
					
					iso_field_value[100]= "00100"+msg_for_processing(next_field,var_field);


				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
									
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						
						//RWCString doble_nine = "99";
						iso_field_value[39]="0003900";
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
					if(j+1 == 52)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[52]="00052"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
		
				}
			
			}
		}
		
	}
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
	
	RWCString test_now = test_iso_new.SetIso8583B24FromBtransFormatVBV1C(response_0210_generic_from_iso,"base24","ISO025000050",0);
	response_0210_generic_from_iso = test_now;

	return response_0210_generic_from_iso;

}


RWCString MQUtility::SetIso8583DiscoverMsg0110FromIso8583DiscoverMsg0100(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 8;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(2,4);
		bit_map_from_msg   = incoming(6,32);
		msg_for_processing = incoming(38,incoming.length()-38);
		
		if(incoming(2,4) == "0100")
			response_0210_generic_from_iso += "0110";

		if(incoming(2,4) == "0800")
			response_0210_generic_from_iso += "0810";

		if(incoming(2,4) == "0400")
			response_0210_generic_from_iso += "0410";
	//	else
	//		response_0210_generic_from_iso += incoming(14,4);



		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(2,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
						iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
							
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]="00062"+msg_for_processing(next_field,var_field);
		
		
				if((j+1) == 63)
				{
					
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
		
				}

				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);

				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
		
				
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 100)
				{
					
					
					iso_field_value[100]= "00100"+msg_for_processing(next_field,var_field);


				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
									
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]="00019"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]="00024"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						
						//RWCString doble_nine = "99";
						iso_field_value[39]="0003900";
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
			
				}
			
			}
		}
		
	}

	if (iso_field_value[38].length() == 0)
		iso_field_value[38] = "00038"+iso_field_value[11](5,6);
	
	//if (iso_field_value[39].length() == 0)
	//	iso_field_value[39] = "0003900";
	
	char response_code[8] = {""};
	const static char* appName = "VISAF_TO_B24";
	const static char* appAddr = "\\BtransGeneric\\INI\\BSINK_SIM_DISCOVER.INI";
	


	GetPrivateProfileString(appName,"response_code","",response_code,sizeof(response_code),appAddr);
	if (strcmp(response_code,"") == 0)
	{
		cout << "Problem Opening Initialization File to get response_code"<< endl;
		exit(0);
	}
	
	iso_field_value[39] = response_code;
	
	
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
			//cout << j <<  " " << iso_field_value[j] << endl;

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
	//cout << "valor de response_0210_generic_from_iso " << response_0210_generic_from_iso << endl;
	
	RWCString test_now = test_iso_new.SetIso8583B24FromBtransFormat(response_0210_generic_from_iso,"base24","",0);
	response_0210_generic_from_iso = test_now;

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583CapitalGMsg1210FromIso8583CapitalGMsg1200(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4; iso_field_length[19] = 3;	
	iso_field_length[22] = 3;	iso_field_length[24] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(2,4);
		bit_map_from_msg   = incoming(6,32);
		msg_for_processing = incoming(38,incoming.length()-38);
		
		if(incoming(2,4) == "1200")
			response_0210_generic_from_iso += "1210";

		if(incoming(2,4) == "1800")
			response_0210_generic_from_iso += "1810";

		if(incoming(2,4) == "1400")
			response_0210_generic_from_iso += "1410";
		
		if(incoming(2,4) == "1420")
			response_0210_generic_from_iso += "1430";
	
	//	else
	//		response_0210_generic_from_iso += incoming(14,4);



		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(2,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
						iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
							
				
				}
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]="00062"+msg_for_processing(next_field,var_field);
		
		
				if((j+1) == 63)
				{
					
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
		
				}

				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);

				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
		
				
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 100)
				{
					
					
					iso_field_value[100]= "00100"+msg_for_processing(next_field,var_field);


				}
				
							
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
									
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]="00019"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]="00024"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}

					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						
						//RWCString doble_nine = "99";
						iso_field_value[39]="0003900";
					}
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
			
				}
			
			}
		}
		
	}

	if (iso_field_value[38].length() == 0)
		iso_field_value[38] = "00038"+iso_field_value[11](5,6);
	
	if (iso_field_value[39].length() == 0)
		iso_field_value[39] = "0003900";
	
	
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
			//cout << j <<  " " << iso_field_value[j] << endl;

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}
 
	
	RWCString test_now = test_iso_new.SetIso8583B24FromBtransFormat(response_0210_generic_from_iso,"base24","",0);
	response_0210_generic_from_iso = test_now;

	return response_0210_generic_from_iso;

}

RWCString MQUtility::SetIso8583CapitalGMsg1210FromIso8583CapitalGMsg12001993(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{


	const static char* appName = "0200";
	const static char* appAddr = "\\BtransGeneric\\INI\\RESPONSE_CODE_1200.INI";
	char response_code_char[9] = {""};
	char response_field_48[256] = {""};
	char response_field_125[1024] = {""};

	GetPrivateProfileString(appName,"response_code_char","",response_code_char,sizeof(response_code_char),appAddr);
	if (strcmp(response_code_char,"") == 0)
	{
		cout<< response_code_char<<endl;
		cout << "Problem Opening Initialization File to get response_code_char"<< endl;
	}
	GetPrivateProfileString(appName,"response_field_48","",response_field_48,sizeof(response_field_48),appAddr);
	if (strcmp(response_field_48,"") == 0)
	{
		cout<< response_field_48<<endl;
		cout << "Problem Opening Initialization File to get response_field_48"<< endl;
	}
	GetPrivateProfileString(appName,"response_field_125","",response_field_125,sizeof(response_field_125),appAddr);
	if (strcmp(response_field_125,"") == 0)
	{
		cout<< response_field_125<<endl;
		cout << "Problem Opening Initialization File to get response_field_125"<< endl;
	}
	cout << "Valor de response_code     " << response_code_char << endl;
	cout << "Valor de response_field_48 " << response_field_48 << endl;



	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  field48_RW;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = '\x1C';
	RWCString  retorno_125 = "";
	RWCString  expiration_date = "";
	RWCString  track_02 = "";
	RWCString  pan_02 = "";
	RWCString  msg_type_from_incming = "" ;
	response_0210_generic_from_iso = "";
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};


	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	RWTValVector<RWCString> iso_field_value(129,"");
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 16; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 12; 	iso_field_length[12] = 14; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 8;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[24] = 3;  iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 32; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 3; 	iso_field_length[42] = 15;  
	iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(2,4);
		bit_map_from_msg   = incoming(6,32);
		msg_for_processing = incoming(38,incoming.length()-38);
		
		if(incoming(2,4) == "1200")
			response_0210_generic_from_iso += "1210";

		if(incoming(2,4) == "1220")
			response_0210_generic_from_iso += "1230";

		if(incoming(2,4) == "1221")
			response_0210_generic_from_iso += "1230";


		if(incoming(2,4) == "1800")
			response_0210_generic_from_iso += "1810";

		if(incoming(2,4) == "1804")
			response_0210_generic_from_iso += "1814";


		if(incoming(2,4) == "1400")
			response_0210_generic_from_iso += "1410";
		
		if(incoming(2,4) == "1420")
			response_0210_generic_from_iso += "1430";

		if(incoming(2,4) == "1421")
			response_0210_generic_from_iso += "1430";
	
	
	//	else
	//		response_0210_generic_from_iso += incoming(14,4);



		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(2,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumberVersion1993(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));

				if((j+1) == 48)
				{
						iso_field_value[48]="00048"+msg_for_processing(next_field,var_field);
							
				
				}
				if((j+1) == 59)
				{
						iso_field_value[59]="00059"+msg_for_processing(next_field,var_field);
							
				
				}
			
				if((j+1) == 60)
					iso_field_value[60]="00060"+msg_for_processing(next_field,var_field);


				if((j+1) == 61)
					iso_field_value[61]="00061"+msg_for_processing(next_field,var_field);

				if((j+1) == 62)
					iso_field_value[62]="00062"+msg_for_processing(next_field,var_field);
		
		
				if((j+1) == 63)
				{
					
					iso_field_value[63]="00063"+msg_for_processing(next_field,var_field);
				
		
				}

				if((j+1) == 120)
					iso_field_value[120]="00120"+msg_for_processing(next_field,var_field);

			
				if((j+1) == 123)
					iso_field_value[123]="00123"+msg_for_processing(next_field,var_field);

				if((j+1) == 125)
					iso_field_value[125]= "00125"+msg_for_processing(next_field,var_field);

				if((j+1) == 126)
					iso_field_value[126]= "00126"+msg_for_processing(next_field,var_field);
		
				
				if((j+1) == 127)
					iso_field_value[127]= "00127"+msg_for_processing(next_field,var_field);
			
								
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				if((j+1) == 2)
				{
					iso_field_value[2]="00002"+msg_for_processing(next_field,var_field);
				}
				
				if((j+1) == 32)
				{
					iso_field_value[32]= "00032"+msg_for_processing(next_field,var_field);
				}


				if((j+1) == 35)
				{
					
					
					iso_field_value[35]= "00035"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 43)
				{
					
					
					iso_field_value[43]= "00043"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 56)
				{
					
					
					iso_field_value[56]= "00056"+msg_for_processing(next_field,var_field);


				}

				if((j+1) == 93)
				{
					
					
					iso_field_value[93]= "00093"+msg_for_processing(next_field,var_field);


				}
				if((j+1) == 94)
				{
					
					
					iso_field_value[94]= "00094"+msg_for_processing(next_field,var_field);


				}
			
			
			
				if((j+1) == 100)
				{
					
					
					iso_field_value[100]= "00100"+msg_for_processing(next_field,var_field);


				}
				
				
				
				if((j+1) == 102)
				{
					
					
					iso_field_value[102]= "00102"+msg_for_processing(next_field,var_field);


				}
				

				if((j+1) == 103)
				{
					
					
					iso_field_value[103]= "00103"+msg_for_processing(next_field,var_field);


				}
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 3)
					{
						
					
						
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
									
						iso_field_value[3]="00003"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 4)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[4]="00004"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 7)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[7]="00007"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 11)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[11]="00011"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 12)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[12]="00012"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 13)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[13]="00013"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 14)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[14]="00014"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						expiration_date=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 17)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[17]="00017"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 18)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[18]="00018"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 19)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[19]="00019"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
				
					if(j+1 == 22)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[22]="00022"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 24)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[24]="00024"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 25)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[25]="00025"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
							
					if(j+1 == 30)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[30]="00030"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}


					if(j+1 == 37)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[37]="00037"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					if(j+1 == 38)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[38]="00038"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					/*
					if(j+1 == 39)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
										
						
						//RWCString doble_nine = "99";
						iso_field_value[39]="0003900";
					}
					*/
					if(j+1 == 41)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[41]="00041"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 42)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[42]="00042"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					/*
					if(j+1 == 43)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[43]="00043"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}
					*/
					if(j+1 == 49)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[49]="00049"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
					if(j+1 == 90)
					{

						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						iso_field_value[90]="00090"+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					}			
			
				}
			
			}
		}
		
	}


	iso_field_value[43] = "";
	iso_field_value[127] = "";


	if (iso_field_value[38].length() == 0)
	{
		
		if ( (iso_field_value[123](5,3) == "ATM") || 	(incoming(2,4) == "1804") 
			||  (iso_field_value[3](5,2) == "18"))
		{

			iso_field_value[38] = "00038UNI000";
		}

		else
		{
			RWCString response_value = 	iso_field_value[37](5,6);
			iso_field_value[38] = "00038"+response_value;



		}

	}

	iso_field_value[39] = response_code_char;
	
	//iso_field_value[48] = "00048+000000001390894+000000001390894+000000001390894+000000001390894BMD";
	
	iso_field_value[48] = response_field_48;

	if(iso_field_value[3](5,2) == "38")

		iso_field_value[125] = response_field_125;
	else

		iso_field_value[125] = "";
	/*
	if(incoming(2,4) == "1200")
	{
			response_0210_generic_from_iso += "1210";

	const static char* appName = "0200";
	const static char* appAddr = "\\BtransGeneric\\INI\\RESPONSE_CODE_1200.INI";
	char response_code[9] = {""};


	GetPrivateProfileString(appName,"response_code","",response_code,sizeof(response_code),appAddr);
	if (strcmp(response_code,"") == 0)
	{
		cout<< response_code<<endl;
		cout << "Problem Opening Initialization File to get response_code"<< endl;
	}

	cout << "Valor de response_code " << response_code << endl;
	//if (iso_field_value[39].length() == 0)
	iso_field_value[39] = response_code;
}
*/
	
	
	for(j = 0; j < 128; j++)
	{

		if(iso_field_value[j].length() != 0)
		{
			//cout << j <<  " " << iso_field_value[j] << endl;

			response_0210_generic_from_iso+=iso_field_value[j]+delimiter;
		}

	}

	cout << "valor de response_0210_generic_from_iso " << response_0210_generic_from_iso << endl;
 
	
	RWCString test_now = test_iso_new.SetIso8583B24FromBtransFormat1993(response_0210_generic_from_iso,"base24","",0);
	response_0210_generic_from_iso = test_now;

	return response_0210_generic_from_iso;

}

void MQUtility::ShowFieldIso8583B241993(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 16; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 12; 	iso_field_length[12] = 14; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 8;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[24] = 3;  iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}
	if(application == "base24") //&& ( (incoming(18,1) == "A") || (incoming(18,1) == "B") || (incoming(18,1) == "C") || (incoming(18,1) == "F") ))
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}
	else
	{
		msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,16)+"0000000000000000";
		msg_for_processing = incoming(34,incoming.length()-34);
		//response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		//response_0210_generic_from_iso +=delimiter;

		//cout << "Dentro de Else " << endl;

	}




	bit_set_fiedl = setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				if((j+1) == 125)
					retorno_125 = msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 53)
					{
						msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						if(debug == 1)

							ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
						response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						response_0210_generic_from_iso +=delimiter;
					}
					else
					{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				}
			
			}
		}
		
	}


}


void MQUtility::ReturnIso8583FieldValue(char *msg_type, int field_value, RWCString field_name)
{
	
	cout << "    <field id=*" << field_value  << "* value=<"   << field_name	<< ">" << endl;  
	

}

int MQUtility::RetornoFieldNumber(int incoming_field )
{

	int length_field = 0;

	if ((incoming_field == 2) || (incoming_field == 32) || (incoming_field == 33) || (incoming_field == 35)
		                      || (incoming_field == 44) || (incoming_field == 45) || (incoming_field == 93) 
							  || (incoming_field == 94) || (incoming_field == 100)
							  || (incoming_field == 101) || (incoming_field == 102) || (incoming_field == 103))
	{
		length_field = 2;

	}
	else
	if ((incoming_field == 48)  || (incoming_field == 54) || (incoming_field == 56) || (incoming_field == 57)
		                       || (incoming_field == 58) || (incoming_field == 59) || (incoming_field == 60)
							   || (incoming_field == 61) || (incoming_field == 62) || (incoming_field == 63) || (incoming_field == 118)
							   || (incoming_field == 119) || (incoming_field == 120)|| (incoming_field == 123)
							   || (incoming_field == 124) || (incoming_field == 125) || (incoming_field == 126) || (incoming_field == 127))
	{
		length_field = 3;
	}
	else
	{
		length_field = 0;
	}

	return length_field;

	
}


RWCString MQUtility::setMapIsoPosTermFromGeneric100( RWCString incoming, char *application, char *header_msg ,int debug)
{


	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
	RWCString header_tpdu = header_msg;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int field = 0;
	int i = 0;
	int count = 0;
	int field_count = 0;
	int counter_token = 0;
	char incoming_field[256] = {""};
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;

	if (strcmp(application,"posterm") == 0)
	{
		testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(header_tpdu,5));
	}
	if (strcmp(application,"base24") == 0)
	{
		 testiso200.setIsoMsg8583("header", header_tpdu);
	}
	
	for (i=0; i<counter_token; i++)
	{
		while(!(token=next2(",")).isNull())
		{	
	
			F1 = token; 
			if( count == 0)
			{

				valor_field = F1;
				testiso200.setIsoMsg8583All("00001", valor_field);

				iso_field [1] = valor_field;
				field_number = "00001";
				count++;
			}	
			else
			{
												
				field_number = F1(0,MSG_FIELD);
				valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		

				if((atoi(field_number) > 0) && (atoi(field_number) <= 129))
				{
					iso_field[atoi(field_number)] = valor_field;
					field_count = atoi(field_number); 

				}
				else
				{
					cout << "Problemas en uno de los campos recibidos" << endl;
					cout << "El ultimo csmpo recibido bien es : " << field_count <<  endl;
				}

				if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 52))
				{
					testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
				}
				
				
				
				
				/*
				if ((strcmp(application,"posterm") == 0) && (atoi(field_number) == 63))
				{
					//testiso200.setIsoMsg8583All("00052",testiso200.RetornoHexadecimalComplete(valor_field,8));
				
					int counter_token = 0;
					RWCString field_63_01;
					RWCString field_63_02;
					RWCString field_63_03;
					RWCTokenizer next1(valor_field);
					RWCString token1;

					while(!(token1=next1("!")).isNull())
					{	
						if (counter_token == 0)
						{
							field_63_01 = token1; 
		
						}			

						if (counter_token == 1)
						{
							field_63_02 = token1; 
		
						}			

						if (counter_token == 2)
						{
							field_63_03 = token1; 
	
		
						}	

						counter_token++;
					}

					int long_token2 = 0;
					long_token2 = field_63_02.length(); 
					int long_token3 = 0;
					long_token3 = field_63_03.length(); 
					RWCString field_048 = "";

					if( (long_token2 > 3) || (long_token3 > 9))
					{
	
					  field_048 = field_63_02((long_token2-3),3)+field_63_03((long_token3-10),10 );
					}
					else
					{
						field_048 = "0000000000000";
					}

					 testiso200.setIsoMsg8583All("00048", field_048);
				
				}
				*/
				if ((strcmp(application,"posterm") == 0) && (atoi(field_number) != 52))
				{
					testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
				}
			
				if (strcmp(application,"base24") == 0)
				{
					testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
				}
			
			}
			if(debug == 1)
				cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  
			
		}
	}

	msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	
	return msg_reponse_with_tcp_header;
}

RWCString MQUtility::setMapIsoBase24FromGeneric( RWCString incoming, char *application,int debug)
{


	RWTValVector<RWCString> iso_field(129,"0");
	RWCString F1;
	RWCString field_number;
	RWCString valor_field;
	RWCString msg_reponse_with_tcp_header = "";
	RWCTokenizer next(incoming);
	RWCTokenizer next2(incoming);
	RWCString token;
	RWCString token2;
	int test = 0;

	int field = 0;
	int i = 0;
	int counter_token = 0;	
	
	char incoming_field[256] = {""};
	
	int count = 0;
	
		
	while(!(token=next(",")).isNull())
	{	
			counter_token++;
	}

	MQUtility testiso200;
	for (i=0; i<counter_token; i++)
	{
		while(!(token=next2(",")).isNull())
		{	
	
			F1 = token; 

			if( count == 0)
			{
				
				field_number = F1(0,MSG_FIELD);
				valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
			
				if (strcmp(application,"posterm") == 0)
				{
					iso_field[atoi(field_number)] = testiso200.setIsoMsg8583("TPDU", testiso200.RetornoHexadecimalComplete(valor_field,5));
				}
				if (strcmp(application,"base24") == 0)
				{
					iso_field[atoi(field_number)] = testiso200.setIsoMsg8583("header", valor_field);
				}
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
				count++;
			}	
			else
			{
	
				field_number = F1(0,MSG_FIELD);
				valor_field = F1(MSG_FIELD,F1.length()-MSG_FIELD);
		
				iso_field[atoi(field_number)] = valor_field;
				testiso200.setIsoMsg8583All(field_number, iso_field [atoi(field_number)]);
			}
		
			
				if(debug == 1)
		

				cout << "    <field id=*"<<atoi(field_number)<<"* value=<"   << iso_field[atoi(field_number)]				<< ">" << endl;  

			
		}
	}


	msg_reponse_with_tcp_header += testiso200.getIsoMsg8583(application);
	
	return msg_reponse_with_tcp_header;
}

//This funtion is for create a message for B24
//This fiction read the iso-generic message a reade each token a put in 
//variable that correspond.

//This funtion create the message ISO8583 B24 
RWCString MQUtility::setIsoMsg8583(RWCString message, RWCString input)
{

	char buffer[20];

	if(message == "header")
	{
	  
		msg_type = input;
	
	}
	if(message == "TPDU")
	{
	  
		msg_type += input;
	
	}
	if(message == "MTI")
	{
	  
		msg_type += input;
	
	}
	if(message == "F2")
	{
	    
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(1,1) = "1";
	
	}
	if(message == "F3")
	{
	  
		isomsg8583 += input;
		bit_map_iso(2,1) = "1";
	
	}

	if(message == "F4")
	{
	  
		isomsg8583 += input;
		bit_map_iso(3,1) = "1";
	
	}

	if(message == "F5")
	{
	  
		isomsg8583 += input;
		bit_map_iso(4,1) = "1";
	
	}

	if(message == "F7")
	{
	  
		isomsg8583 += input;
		bit_map_iso(6,1) = "1";
	
	}

	if(message == "F11")
	{
	  
		isomsg8583 += input;
		bit_map_iso(10,1) = "1";
	
	}	
	if(message == "F12")
	{
	  
		isomsg8583 += input;
		bit_map_iso(11,1) = "1";
	
	}	
	if(message == "F13")
	{
	  
		isomsg8583 += input;
		bit_map_iso(12,1) = "1";
	
	}
	if(message == "F15")
	{
	  
		isomsg8583 += input;
		bit_map_iso(14,1) = "1";
	
	}

	if(message == "F35")
	{
	  

		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(34,1) = "1";
	
	}
	if(message == "F37")
	{
	  
	
		isomsg8583 += input;
		bit_map_iso(36,1) = "1";
	
	}
	if(message == "F41")
	{
	  
		isomsg8583 += input;
		bit_map_iso(40,1) = "1";
	
	}

	if(message == "F45")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(44,1) = "1";
	
	}

	if(message == "F48")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(47,1) = "1";
	
	}

	if(message == "F49")
	{
	  
		isomsg8583 += input;
		bit_map_iso(48,1) = "1";
	
	}
	if(message == "F52")
	{
	  
		isomsg8583 += input;
		bit_map_iso(51,1) = "1";
	
	}
	if(message == "F60")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(59,1) = "1";
	
	}


	if(message == "F61")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(60,1) = "1";
	
	}
	if(message == "F63")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(62,1) = "1";
	
	}


	if(message == "F70")
	{
	  
		isomsg8583 += input;
		bit_map_iso(69,1) = "1";
	
	}
	if(message == "F90")
	{
	  
		isomsg8583 += input;
		bit_map_iso(89,1) = "1";
	
	}
	if(message == "F102")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(101,1) = "1";
	
	}
	if(message == "F120")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(121,1) = "1";
	
	}


	if(message == "F123")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(122,1) = "1";
	
	}

	if(message == "F125")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(124,1) = "1";
	
	}
	if(message == "F127")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input="0"+RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(126,1) = "1";
	
	}



	isomsg8583complete = isomsg8583;
	return isomsg8583complete;
}

RWCString MQUtility::setIsoMsg8583All(RWCString message, RWCString input)
{

	char buffer[20];

	if(message == "header")
	{
	  
		msg_type = input;
	
	}
	if(message == "TPDU")
	{
	  
		msg_type += input;
	
	}
	if(message == "00001")
	{
	  
		msg_type += input;
	
	}
	if(message == "00002")
	{
	    
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(1,1) = "1";
	
	}
	if(message == "00003")
	{
	  
		isomsg8583 += input;
		bit_map_iso(2,1) = "1";
	
	}

	if(message == "00004")
	{
	  
		isomsg8583 += input;
		bit_map_iso(3,1) = "1";
	
	}

	if(message == "00005")
	{
	  
		isomsg8583 += input;
		bit_map_iso(4,1) = "1";
	
	}

	if(message == "00007")
	{
	  
		isomsg8583 += input;
		bit_map_iso(6,1) = "1";
	
	}

	if(message == "00011")
	{
	  
		isomsg8583 += input;
		bit_map_iso(10,1) = "1";
	
	}	
	if(message == "00012")
	{
	  
		isomsg8583 += input;
		bit_map_iso(11,1) = "1";
	
	}	
	if(message == "00013")
	{
	  
		isomsg8583 += input;
		bit_map_iso(12,1) = "1";
	
	}
	if(message == "00014")
	{
	  
		isomsg8583 += input;
		bit_map_iso(13,1) = "1";
	
	}
	if(message == "00015")
	{
	  
		isomsg8583 += input;
		bit_map_iso(14,1) = "1";
	
	}

	if(message == "00017")
	{
	  
		isomsg8583 += input;
		bit_map_iso(16,1) = "1";
	
	}
	if(message == "00018")
	{
	  
		isomsg8583 += input;
		bit_map_iso(17,1) = "1";
	
	}
	if(message == "00019")
	{
	  
		isomsg8583 += input;
		bit_map_iso(18,1) = "1";
	
	}
	if(message == "00022")
	{
	  
		isomsg8583 += input;
		bit_map_iso(21,1) = "1";
	
	}
	if(message == "00023")
	{
	  
		isomsg8583 += input;
		bit_map_iso(22,1) = "1";
	
	}


	if(message == "00024")
	{
	  
		isomsg8583 += input;
		bit_map_iso(23,1) = "1";
	
	}
	if(message == "00025")
	{
	  
		isomsg8583 += input;
		bit_map_iso(24,1) = "1";
	
	}
	if(message == "00026")
	{
	  
		isomsg8583 += input;
		bit_map_iso(25,1) = "1";
	
	}
	if(message == "00028")
	{
	  
		isomsg8583 += input;
		bit_map_iso(27,1) = "1";
	
	}
	if(message == "00030")
	{
	  
		isomsg8583 += input;
		bit_map_iso(29,1) = "1";
	
	}
	if(message == "00032")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(31,1) = "1";
	
	}
	if(message == "00033")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(32,1) = "1";
	
	}
	
	if(message == "00035")
	{
	  

		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(34,1) = "1";
	
	}

	if(message == "00037")
	{
	  

	
		isomsg8583 += input;
		bit_map_iso(36,1) = "1";
	
	}
	if(message == "00038")
	{
	
		isomsg8583 += input;
		bit_map_iso(37,1) = "1";
	
	}
	if(message == "00039")
	{
	  
		isomsg8583 += input;
		bit_map_iso(38,1) = "1";
	
	}
	if(message == "00040")
	{
	  
		isomsg8583 += input;
		bit_map_iso(39,1) = "1";
	
	}
	if(message == "00041")
	{
	  
		isomsg8583 += input;
		bit_map_iso(40,1) = "1";
	
	}
	if(message == "00042")
	{
	  
		isomsg8583 += input;
		bit_map_iso(41,1) = "1";
	
	}
	if(message == "00043")
	{
	  
		isomsg8583 += input;
		bit_map_iso(42,1) = "1";
	
	}

	if(message == "00045")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(44,1) = "1";
	
	}

	if(message == "00048")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(47,1) = "1";
	
	}

	if(message == "00049")
	{
	  
		isomsg8583 += input;
		bit_map_iso(48,1) = "1";
	
	}
	if(message == "00050")
	{
	  
		isomsg8583 += input;
		bit_map_iso(49,1) = "1";
	
	}

	if(message == "00052")
	{
	  
		isomsg8583 += input;
		bit_map_iso(51,1) = "1";
	
	}
	if(message == "00054")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(53,1) = "1";
	
	}
	if(message == "00056")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(55,1) = "1";
	
	}
	if(message == "00059")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(58,1) = "1";
	
	}


	if(message == "00060")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(59,1) = "1";
	
	}
	if(message == "00061")
	{
	  
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(60,1) = "1";
	}

	if(message == "00062")
	{
	  
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(61,1) = "1";
	}
	if(message == "00063")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			//input="0"+RWCString(buffer)+input;
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(62,1) = "1";
	}



	if(message == "00070")
	{
	  
		isomsg8583 += input;
		bit_map_iso(69,1) = "1";
	
	}
	if(message == "00090")
	{
	  
		isomsg8583 += input;
		bit_map_iso(89,1) = "1";
	
	}
	if(message == "00093")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(92,1) = "1";
	
	}
	if(message == "00094")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(93,1) = "1";
	
	}


	if(message == "00095")
	{
	  
		isomsg8583 += input;
		bit_map_iso(94,1) = "1";
	
	}

	if(message == "00100")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(99,1) = "1";
	
	}
	if(message == "00102")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(101,1) = "1";
	
	}
	if(message == "00103")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(102,1) = "1";
	
	}
	if(message == "00120")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(119,1) = "1";
	
	}

	if(message == "00123")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(122,1) = "1";
	
	}

	if(message == "00124")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(123,1) = "1";
	
	}

	if(message == "00125")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(124,1) = "1";
	
	}

	if(message == "00126")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(125,1) = "1";
	
	}


	if(message == "00127")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(126,1) = "1";
	
	}

	RWCString last_char = '\x03';
	isomsg8583complete = isomsg8583;
	isomsg8583complete=isomsg8583complete+last_char;
//	cout << "Valor de isomsg8583complete "<< isomsg8583complete << endl;
	return isomsg8583complete;
}

RWCString MQUtility::setIsoMsg8583All1Version1993(RWCString message, RWCString input)
{

	char buffer[20];

	if(message == "header")
	{
	  
		msg_type = input;
	
	}
	if(message == "TPDU")
	{
	  
		msg_type += input;
	
	}
	if(message == "00001")
	{
	  
		msg_type += input;
	
	}
	if(message == "00002")
	{
	    
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(1,1) = "1";
	
	}
	if(message == "00003")
	{
	  
		isomsg8583 += input;
		bit_map_iso(2,1) = "1";
	
	}

	if(message == "00004")
	{
	  
		isomsg8583 += input;
		bit_map_iso(3,1) = "1";
	
	}

	if(message == "00005")
	{
	  
		isomsg8583 += input;
		bit_map_iso(4,1) = "1";
	
	}

	if(message == "00007")
	{
	  
		isomsg8583 += input;
		bit_map_iso(6,1) = "1";
	
	}

	if(message == "00011")
	{
	  
		isomsg8583 += input;
		bit_map_iso(10,1) = "1";
	
	}	
	if(message == "00012")
	{
	  
		isomsg8583 += input;
		bit_map_iso(11,1) = "1";
	
	}	
	if(message == "00013")
	{
	  
		isomsg8583 += input;
		bit_map_iso(12,1) = "1";
	
	}
	if(message == "00014")
	{
	  
		isomsg8583 += input;
		bit_map_iso(13,1) = "1";
	
	}
	if(message == "00015")
	{
	  
		isomsg8583 += input;
		bit_map_iso(14,1) = "1";
	
	}

	if(message == "00017")
	{
	  
		isomsg8583 += input;
		bit_map_iso(16,1) = "1";
	
	}
	if(message == "00018")
	{
	  
		isomsg8583 += input;
		bit_map_iso(17,1) = "1";
	
	}
	if(message == "00019")
	{
	  
		isomsg8583 += input;
		bit_map_iso(18,1) = "1";
	
	}
	if(message == "00022")
	{
	  
		isomsg8583 += input;
		bit_map_iso(21,1) = "1";
	
	}

	if(message == "00024")
	{
	  
		isomsg8583 += input;
		bit_map_iso(23,1) = "1";
	
	}
	if(message == "00025")
	{
	  
		isomsg8583 += input;
		bit_map_iso(24,1) = "1";
	
	}
	if(message == "00030")
	{
	  
		isomsg8583 += input;
		bit_map_iso(29,1) = "1";
	
	}

	if(message == "00032")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(31,1) = "1";
	
	}
	if(message == "00033")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(32,1) = "1";
	
	}
	
	if(message == "00035")
	{
	  

		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(34,1) = "1";
	
	}

	if(message == "00037")
	{
	  

	
		isomsg8583 += input;
		bit_map_iso(36,1) = "1";
	
	}
	if(message == "00038")
	{
	  

	
		isomsg8583 += input;
		bit_map_iso(37,1) = "1";
	
	}
	if(message == "00039")
	{
	  

	
		isomsg8583 += input;
		bit_map_iso(38,1) = "1";
	
	}
	if(message == "00041")
	{
	  
		isomsg8583 += input;
		bit_map_iso(40,1) = "1";
	
	}
	if(message == "00042")
	{
	  
		isomsg8583 += input;
		bit_map_iso(41,1) = "1";
	
	}
	if(message == "00043")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(42,1) = "1";
	
	}

	if(message == "00045")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(44,1) = "1";
	
	}

	if(message == "00048")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(47,1) = "1";
	
	}

	if(message == "00049")
	{
	  
		isomsg8583 += input;
		bit_map_iso(48,1) = "1";
	
	}
	if(message == "00052")
	{
	  
		isomsg8583 += input;
		bit_map_iso(51,1) = "1";
	
	}

	if(message == "00054")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(53,1) = "1";
	
	}
	if(message == "00056")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(55,1) = "1";
	
	}


	if(message == "00059")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(58,1) = "1";
	
	}
	if(message == "00060")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(59,1) = "1";
	
	}
	if(message == "00061")
	{
	  
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(60,1) = "1";
	}

	if(message == "00062")
	{
	  
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(61,1) = "1";
	}
	if(message == "00063")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			//input="0"+RWCString(buffer)+input;
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(62,1) = "1";
	}



	if(message == "00070")
	{
	  
		isomsg8583 += input;
		bit_map_iso(69,1) = "1";
	
	}
	if(message == "00090")
	{
	  
		isomsg8583 += input;
		bit_map_iso(89,1) = "1";
	
	}
	if(message == "00093")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(92,1) = "1";
	
	}
	if(message == "00094")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(93,1) = "1";
	
	}
	if(message == "00095")
	{
	  
		isomsg8583 += input;
		bit_map_iso(94,1) = "1";
	
	}
	
	if(message == "00100")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(99,1) = "1";
	
	}
	if(message == "00102")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(101,1) = "1";
	
	}
	if(message == "00103")
	{
	  
		_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		isomsg8583 += input;
		bit_map_iso(102,1) = "1";
	
	}
	if(message == "00120")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(119,1) = "1";
	
	}

	if(message == "00123")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(122,1) = "1";
	
	}

	if(message == "00124")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(123,1) = "1";
	
	}

	if(message == "00125")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(124,1) = "1";
	
	}

	if(message == "00126")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(125,1) = "1";
	
	}


	if(message == "00127")
	{
	  	_itoa( (input.length()), buffer, 10 );
		if(input.length() < 10)
		{
			input="00"+RWCString(buffer)+input;
		}
		else
		if(  (input.length() > 10) && (input.length() < 99))
		{
			input="0"+RWCString(buffer)+input;
		}
		else
		{
			input=RWCString(buffer)+input;
		}
		
		isomsg8583 += input;
		bit_map_iso(126,1) = "1";
	
	}

	//RWCString last_char = '\x03';
	isomsg8583complete = isomsg8583;
	//isomsg8583complete=isomsg8583complete+last_char;
//	cout << "Valor de isomsg8583complete "<< isomsg8583complete << endl;
	return isomsg8583complete;
}



RWCString MQUtility::getIsoMsg8583(RWCString type)
{
	char bit_map_ascii2[33] = {""};
	char bit_map_ascii_to_convert[2] = {""};
	RWCString test_bit;

	RWCString pin_wk_ascii = "";
	RWCString pin_bk_hex = "";
	RWCString pin_bk_hex_sub = "";
	char vic_test[3]   = {""};
	char vic_test2[17] = {""};

	int i;
	for( i = 0; i < 32; i++)
	{
										
		test_bit = setBitMap(bit_map_iso( (i*4),4 ));

		strcpy(bit_map_ascii_to_convert, test_bit);
		strcat(bit_map_ascii2, bit_map_ascii_to_convert);
		
	}


	pin_wk_ascii = bit_map_ascii2;
	
	
	if (type == "posterm")
	{
		for( i = 0; i < 16; i++)
		{
										
			pin_bk_hex_sub=pin_wk_ascii((i*2),2);
								
		
			pin_bk_hex+=RetornoHexa(pin_bk_hex_sub);

		}
		isomsg8583complete = msg_type+pin_bk_hex+isomsg8583complete;
	}

	if (type == "base24")
	{
		for( i = 0; i < 16; i++)
		{
										
			pin_bk_hex_sub=pin_wk_ascii((i*2),2);
								
		
			pin_bk_hex+=pin_bk_hex_sub;

		}
		isomsg8583complete = msg_type+pin_bk_hex+isomsg8583complete;
	}

	return isomsg8583complete;
}

RWCString  MQUtility::RetornoHexadecimalComplete( RWCString ascii_input, int input)
{
	RWCString pin_wk_ascii = ascii_input;
	RWCString pin_bk_hex = "";
	RWCString pin_bk_hex_sub = "";
	int i;
	for( i = 0; i < input; i++)
	{
										
		pin_bk_hex_sub=pin_wk_ascii((i*2),2);
								
		
		pin_bk_hex+=RetornoHexa(pin_bk_hex_sub);
	

	}

	retornohexadecimalcomplete = pin_bk_hex;
	return retornohexadecimalcomplete;
}


RWCString  MQUtility::RetornoAsciiComplete( RWCString ascii_input, int input)
{
	RWCString pin_wk_ascii = ascii_input;

	RWCString pin_bk_hex = "";
	char buffer[32] = {""};
	unsigned char ch2;
	memcpy( buffer, ascii_input ,input);

	int i;
	for( i = 0; i < input; i++)
	{
										
		ch2=buffer[i];
		pin_bk_hex+=RetornoASCII(ch2);

	}

	retornoasciicomplete= pin_bk_hex;
	return retornoasciicomplete;
}


RWCString  MQUtility::RetornoASCII(char  hex_input)
{
	

	if (hex_input  == '\x00') 
		return "00";
	if (hex_input  == '\x01') 
		return "01";
	if (hex_input  == '\x02') 
		return "02";
	if (hex_input  == '\x03') 
		return "03";
	if (hex_input  == '\x04') 
		return "04";
	if (hex_input  == '\x05') 
		return "05";
	if (hex_input  == '\x06') 
		return "06";
	if (hex_input  == '\x07') 
		return "07";
	if (hex_input  == '\x08') 
		return "08";
	if (hex_input  == '\x09') 
		return "09";
	if (hex_input  == '\x0A') 
		return "0A";
	if (hex_input  == '\x0B') 
		return "0B";
	if (hex_input  == '\x0C') 
		return "0C";
	if (hex_input  == '\x0D') 
		return "0D";
	if (hex_input  == '\x0E') 
		return "0E";
	if (hex_input  == '\x0F') 
		return "0F";

	if (hex_input  == '\x10') 
		return "10";
	if (hex_input  == '\x11') 
		return "11";
	if (hex_input  == '\x12') 
		return "12";
	if (hex_input  == '\x13') 
		return "13";
	if (hex_input  == '\x14') 
		return "14";
	if (hex_input  == '\x15') 
		return "15";
	if (hex_input  == '\x16') 
		return "16";
	if (hex_input  == '\x17') 
		return "17";
	if (hex_input  == '\x18') 
		return "18";
	if (hex_input  == '\x19') 
		return "19";
	if (hex_input  == '\x1A') 
		return "1A";
	if (hex_input  == '\x1B') 
		return "1B";
	if (hex_input  == '\x1C') 
		return "1C";
	if (hex_input  == '\x1D') 
		return "1D";
	if (hex_input  == '\x1E') 
		return "1E";
	if (hex_input  == '\x1F') 
		return "1F";

	if (hex_input  == '\x20') 
		return "20";
	if (hex_input  == '\x21') 
		return "21";
	if (hex_input  == '\x22') 
		return "22";
	if (hex_input  == '\x23') 
		return "23";
	if (hex_input  == '\x24') 
		return "24";
	if (hex_input  == '\x25') 
		return "25";
	if (hex_input  == '\x26') 
		return "26";
	if (hex_input  == '\x27') 
		return "27";
	if (hex_input  == '\x28') 
		return "28";
	if (hex_input  == '\x29') 
		return "29";
	if (hex_input  == '\x2A') 
		return "2A";
	if (hex_input  == '\x2B') 
		return "2B";
	if (hex_input  == '\x2C') 
		return "2C";
	if (hex_input  == '\x2D') 
		return "2D";
	if (hex_input  == '\x2E') 
		return "2E";
	if (hex_input  == '\x2F') 
		return "2F";

	
	if (hex_input  == '\x30') 
		return "30";
	if (hex_input  == '\x31') 
		return "31";
	if (hex_input  == '\x32') 
		return "32";
	if (hex_input  == '\x33') 
		return "33";
	if (hex_input  == '\x34') 
		return "34";
	if (hex_input  == '\x35') 
		return "35";
	if (hex_input  == '\x36') 
		return "36";
	if (hex_input  == '\x37') 
		return "37";
	if (hex_input  == '\x38') 
		return "38";
	if (hex_input  == '\x39') 
		return "39";
	if (hex_input  == '\x3A') 
		return "3A";
	if (hex_input  == '\x3B') 
		return "3B";
	if (hex_input  == '\x3C') 
		return "3C";
	if (hex_input  == '\x3D') 
		return "3D";
	if (hex_input  == '\x3E') 
		return "3E";
	if (hex_input  == '\x3F') 
		return "3F";

	if (hex_input  == '\x40') 
		return "40";
	if (hex_input  == '\x41') 
		return "41";
	if (hex_input  == '\x42') 
		return "42";
	if (hex_input  == '\x43') 
		return "43";
	if (hex_input  == '\x44') 
		return "44";
	if (hex_input  == '\x45') 
		return "45";
	if (hex_input  == '\x46') 
		return "46";
	if (hex_input  == '\x47') 
		return "47";
	if (hex_input  == '\x48') 
		return "48";
	if (hex_input  == '\x49') 
		return "49";
	if (hex_input  == '\x4A') 
		return "4A";
	if (hex_input  == '\x4B') 
		return "4B";
	if (hex_input  == '\x4C') 
		return "4C";
	if (hex_input  == '\x4D') 
		return "4D";
	if (hex_input  == '\x4E') 
		return "4E";
	if (hex_input  == '\x4F') 
		return "4F";
	
	if (hex_input  == '\x50') 
		return "50";
	if (hex_input  == '\x51') 
		return "51";
	if (hex_input  == '\x52') 
		return "52";
	if (hex_input  == '\x53') 
		return "53";
	if (hex_input  == '\x54') 
		return "54";
	if (hex_input  == '\x55') 
		return "55";
	if (hex_input  == '\x56') 
		return "56";
	if (hex_input  == '\x57') 
		return "57";
	if (hex_input  == '\x58') 
		return "58";
	if (hex_input  == '\x59') 
		return "59";
	if (hex_input  == '\x5A') 
		return "5A";
	if (hex_input  == '\x5B') 
		return "5B";
	if (hex_input  == '\x5C') 
		return "5C";
	if (hex_input  == '\x5D') 
		return "5D";
	if (hex_input  == '\x5E') 
		return "5E";
	if (hex_input  == '\x5F') 
		return "5F";
	
	if (hex_input  == '\x60') 
		return "60";
	if (hex_input  == '\x61') 
		return "61";
	if (hex_input  == '\x62') 
		return "62";
	if (hex_input  == '\x63') 
		return "63";
	if (hex_input  == '\x64') 
		return "64";
	if (hex_input  == '\x65') 
		return "65";
	if (hex_input  == '\x66') 
		return "66";
	if (hex_input  == '\x67') 
		return "67";
	if (hex_input  == '\x68') 
		return "68";
	if (hex_input  == '\x69') 
		return "69";
	if (hex_input  == '\x6A') 
		return "6A";
	if (hex_input  == '\x6B') 
		return "6B";
	if (hex_input  == '\x6C') 
		return "6C";
	if (hex_input  == '\x6D') 
		return "6D";
	if (hex_input  == '\x6E') 
		return "6E";
	if (hex_input  == '\x6F') 
		return "6F";

	if (hex_input  == '\x70') 
		return "70";
	if (hex_input  == '\x71') 
		return "71";
	if (hex_input  == '\x72') 
		return "72";
	if (hex_input  == '\x73') 
		return "73";
	if (hex_input  == '\x74') 
		return "74";
	if (hex_input  == '\x75') 
		return "75";
	if (hex_input  == '\x76') 
		return "76";
	if (hex_input  == '\x77') 
		return "77";
	if (hex_input  == '\x78') 
		return "78";
	if (hex_input  == '\x79') 
		return "79";
	if (hex_input  == '\x7A') 
		return "7A";
	if (hex_input  == '\x7B') 
		return "7B";
	if (hex_input  == '\x7C') 
		return "7C";
	if (hex_input  == '\x7D') 
		return "7D";
	if (hex_input  == '\x7E') 
		return "7E";
	if (hex_input  == '\x7F') 
		return "7F";

	if (hex_input  == '\x80') 
		return "80";
	if (hex_input  == '\x81') 
		return "81";
	if (hex_input  == '\x82') 
		return "82";
	if (hex_input  == '\x83') 
		return "83";
	if (hex_input  == '\x84') 
		return "84";
	if (hex_input  == '\x85') 
		return "85";
	if (hex_input  == '\x86') 
		return "86";
	if (hex_input  == '\x87') 
		return "87";
	if (hex_input  == '\x88') 
		return "88";
	if (hex_input  == '\x89') 
		return "89";
	if (hex_input  == '\x8A') 
		return "8A";
	if (hex_input  == '\x8B') 
		return "8B";
	if (hex_input  == '\x8C') 
		return "8C";
	if (hex_input  == '\x8D') 
		return "8D";
	if (hex_input  == '\x8E') 
		return "8E";
	if (hex_input  == '\x8F') 
		return "8F";

	if (hex_input  == '\x90') 
		return "90";
	if (hex_input  == '\x91') 
		return "91";
	if (hex_input  == '\x92') 
		return "92";
	if (hex_input  == '\x93') 
		return "93";
	if (hex_input  == '\x94') 
		return "94";
	if (hex_input  == '\x95') 
		return "95";
	if (hex_input  == '\x96') 
		return "96";
	if (hex_input  == '\x97') 
		return "97";
	if (hex_input  == '\x98') 
		return "98";
	if (hex_input  == '\x99') 
		return "99";
	if (hex_input  == '\x9A') 
		return "9A";
	if (hex_input  == '\x9B') 
		return "9B";
	if (hex_input  == '\x9C') 
		return "9C";
	if (hex_input  == '\x9D') 
		return "9D";
	if (hex_input  == '\x9E') 
		return "9E";
	if (hex_input  == '\x9F') 
		return "9F";

	if (hex_input  == '\xA0') 
		return "A0";
	if (hex_input  == '\xA1') 
		return "A1";
	if (hex_input  == '\xA2') 
		return "A2";
	if (hex_input  == '\xA3') 
		return "A3";
	if (hex_input  == '\xA4') 
		return "A4";
	if (hex_input  == '\xA5') 
		return "A5";
	if (hex_input  == '\xA6') 
		return "A6";
	if (hex_input  == '\xA7') 
		return "A7";
	if (hex_input  == '\xA8') 
		return "A8";
	if (hex_input  == '\xA9') 
		return "A9";
	if (hex_input  == '\xAA') 
		return "AA";
	if (hex_input  == '\xAB') 
		return "AB";
	if (hex_input  == '\xAC') 
		return "AC";
	if (hex_input  == '\xAD') 
		return "AD";
	if (hex_input  == '\xAE') 
		return "AE";
	if (hex_input  == '\xAF') 
		return "AF";

	if (hex_input  == '\xB0') 
		return "B0";
	if (hex_input  == '\xB1') 
		return "B1";
	if (hex_input  == '\xB2') 
		return "B2";
	if (hex_input  == '\xB3') 
		return "B3";
	if (hex_input  == '\xB4') 
		return "B4";
	if (hex_input  == '\xB5') 
		return "B5";
	if (hex_input  == '\xB6') 
		return "B6";
	if (hex_input  == '\xB7') 
		return "B7";
	if (hex_input  == '\xB8') 
		return "B8";
	if (hex_input  == '\xB9') 
		return "B9";
	if (hex_input  == '\xBA') 
		return "BA";
	if (hex_input  == '\xBB') 
		return "BB";
	if (hex_input  == '\xBC') 
		return "BC";
	if (hex_input  == '\xBD') 
		return "BD";
	if (hex_input  == '\xBE') 
		return "BE";
	if (hex_input  == '\xBF') 
		return "BF";
	
	if (hex_input  == '\xC0') 
		return "C0";
	if (hex_input  == '\xC1') 
		return "C1";
	if (hex_input  == '\xC2') 
		return "C2";
	if (hex_input  == '\xC3') 
		return "C3";
	if (hex_input  == '\xC4') 
		return "C4";
	if (hex_input  == '\xC5') 
		return "C5";
	if (hex_input  == '\xC6') 
		return "C6";
	if (hex_input  == '\xC7') 
		return "C7";
	if (hex_input  == '\xC8') 
		return "C8";
	if (hex_input  == '\xC9') 
		return "C9";
	if (hex_input  == '\xCA') 
		return "CA";
	if (hex_input  == '\xCB') 
		return "CB";
	if (hex_input  == '\xCC') 
		return "CC";
	if (hex_input  == '\xCD') 
		return "CD";
	if (hex_input  == '\xCE') 
		return "CE";
	if (hex_input  == '\xCF') 
		return "CF";

	if (hex_input  == '\xD0') 
		return "D0";
	if (hex_input  == '\xD1') 
		return "D1";
	if (hex_input  == '\xD2') 
		return "D2";
	if (hex_input  == '\xD3') 
		return "D3";
	if (hex_input  == '\xD4') 
		return "D4";
	if (hex_input  == '\xD5') 
		return "D5";
	if (hex_input  == '\xD6') 
		return "D6";
	if (hex_input  == '\xD7') 
		return "D7";
	if (hex_input  == '\xD8') 
		return "D8";
	if (hex_input  == '\xD9') 
		return "D9";
	if (hex_input  == '\xDA') 
		return "DA";
	if (hex_input  == '\xDB') 
		return "DB";
	if (hex_input  == '\xDC') 
		return "DC";
	if (hex_input  == '\xDD') 
		return "DD";
	if (hex_input  == '\xDE') 
		return "DE";
	if (hex_input  == '\xDF') 
		return "DF";

	if (hex_input  == '\xE0') 
		return "E0";
	if (hex_input  == '\xE1') 
		return "E1";
	if (hex_input  == '\xE2') 
		return "E2";
	if (hex_input  == '\xE3') 
		return "E3";
	if (hex_input  == '\xE4') 
		return "E4";
	if (hex_input  == '\xE5') 
		return "E5";
	if (hex_input  == '\xE6') 
		return "E6";
	if (hex_input  == '\xE7') 
		return "E7";
	if (hex_input  == '\xE8') 
		return "E8";
	if (hex_input  == '\xE9') 
		return "E9";
	if (hex_input  == '\xEA') 
		return "EA";
	if (hex_input  == '\xEB') 
		return "EB";
	if (hex_input  == '\xEC') 
		return "EC";
	if (hex_input  == '\xED') 
		return "ED";
	if (hex_input  == '\xEE') 
		return "EE";
	if (hex_input  == '\xEF') 
		return "EF";

	if (hex_input  == '\xF0') 
		return "F0";
	if (hex_input  == '\xF1') 
		return "F1";
	if (hex_input  == '\xF2') 
		return "F2";
	if (hex_input  == '\xF3') 
		return "F3";
	if (hex_input  == '\xF4') 
		return "F4";
	if (hex_input  == '\xF5') 
		return "F5";
	if (hex_input  == '\xF6') 
		return "F6";
	if (hex_input  == '\xF7') 
		return "F7";
	if (hex_input  == '\xF8') 
		return "F8";
	if (hex_input  == '\xF9') 
		return "F9";
	if (hex_input  == '\xFA') 
		return "FA";
	if (hex_input  == '\xFB') 
		return "FB";
	if (hex_input  == '\xFC') 
		return "FC";
	if (hex_input  == '\xFD') 
		return "FD";
	if (hex_input  == '\xFE') 
		return "FE";
	if (hex_input  == '\xFF') 
		return "FF";
	
	
	
	return "n";

}

char  MQUtility::RetornoHexa( RWCString hex_input)
{
	


	if (hex_input  == "00") 
		return '\x00';
	if (hex_input  == "01") 
		return '\x01';
	if (hex_input  == "02") 
		return '\x02';
	if (hex_input  == "03") 
		return '\x03';
	if (hex_input  == "04") 
		return '\x04';
	if (hex_input  == "05") 
		return '\x05';
	if (hex_input  == "06") 
		return '\x06';
	if (hex_input  == "07") 
		return '\x07';
	if (hex_input  == "08") 
		return '\x08';
	if (hex_input  == "09") 
		return '\x09';
	if (hex_input  == "0A") 
		return '\x0A';
	if (hex_input  == "0B") 
		return '\x0B';
	if (hex_input  == "0C") 
		return '\x0C';
	if (hex_input  == "0D") 
		return '\x0D';
	if (hex_input  == "0E") 
		return '\x0E';
	if (hex_input  == "0F") 
		return '\x0F';

	if (hex_input  == "10") 
		return '\x10';
	if (hex_input  == "11") 
		return '\x11';
	if (hex_input  == "12") 
		return '\x12';
	if (hex_input  == "13") 
		return '\x13';
	if (hex_input  == "14") 
		return '\x14';
	if (hex_input  == "15") 
		return '\x15';
	if (hex_input  == "16") 
		return '\x16';
	if (hex_input  == "17") 
		return '\x17';
	if (hex_input  == "18") 
		return '\x18';
	if (hex_input  == "19") 
		return '\x19';
	if (hex_input  == "1A") 
		return '\x1A';
	if (hex_input  == "1B") 
		return '\x1B';
	if (hex_input  == "1C") 
		return '\x1C';
	if (hex_input  == "1D") 
		return '\x1D';
	if (hex_input  == "1E") 
		return '\x1E';
	if (hex_input  == "1F") 
		return '\x1F';

	if (hex_input  == "20") 
		return '\x20';
	if (hex_input  == "21") 
		return '\x21';
	if (hex_input  == "22") 
		return '\x22';
	if (hex_input  == "23") 
		return '\x23';
	if (hex_input  == "24") 
		return '\x24';
	if (hex_input  == "25") 
		return '\x25';
	if (hex_input  == "26") 
		return '\x26';
	if (hex_input  == "27") 
		return '\x27';
	if (hex_input  == "28") 
		return '\x28';
	if (hex_input  == "29") 
		return '\x29';
	if (hex_input  == "2A") 
		return '\x2A';
	if (hex_input  == "2B") 
		return '\x2B';
	if (hex_input  == "2C") 
		return '\x2C';
	if (hex_input  == "2D") 
		return '\x2D';
	if (hex_input  == "2E") 
		return '\x2E';
	if (hex_input  == "2F") 
		return '\x2F';

	
	if (hex_input  == "30") 
		return '\x30';
	if (hex_input  == "31") 
		return '\x31';
	if (hex_input  == "32") 
		return '\x32';
	if (hex_input  == "33") 
		return '\x33';
	if (hex_input  == "34") 
		return '\x34';
	if (hex_input  == "35") 
		return '\x35';
	if (hex_input  == "36") 
		return '\x36';
	if (hex_input  == "37") 
		return '\x37';
	if (hex_input  == "38") 
		return '\x38';
	if (hex_input  == "39") 
		return '\x39';
	if (hex_input  == "3A") 
		return '\x3A';
	if (hex_input  == "3B") 
		return '\x3B';
	if (hex_input  == "3C") 
		return '\x3C';
	if (hex_input  == "3D") 
		return '\x3D';
	if (hex_input  == "3E") 
		return '\x3E';
	if (hex_input  == "3F") 
		return '\x3F';

	if (hex_input  == "40") 
		return '\x40';
	if (hex_input  == "41") 
		return '\x41';
	if (hex_input  == "42") 
		return '\x42';
	if (hex_input  == "43") 
		return '\x43';
	if (hex_input  == "44") 
		return '\x44';
	if (hex_input  == "45") 
		return '\x45';
	if (hex_input  == "46") 
		return '\x46';
	if (hex_input  == "47") 
		return '\x47';
	if (hex_input  == "48") 
		return '\x48';
	if (hex_input  == "49") 
		return '\x49';
	if (hex_input  == "4A") 
		return '\x4A';
	if (hex_input  == "4B") 
		return '\x4B';
	if (hex_input  == "4C") 
		return '\x4C';
	if (hex_input  == "4D") 
		return '\x4D';
	if (hex_input  == "4E") 
		return '\x4E';
	if (hex_input  == "4F") 
		return '\x4F';
	
	if (hex_input  == "50") 
		return '\x50';
	if (hex_input  == "51") 
		return '\x51';
	if (hex_input  == "52") 
		return '\x52';
	if (hex_input  == "53") 
		return '\x53';
	if (hex_input  == "54") 
		return '\x54';
	if (hex_input  == "55") 
		return '\x55';
	if (hex_input  == "56") 
		return '\x56';
	if (hex_input  == "57") 
		return '\x57';
	if (hex_input  == "58") 
		return '\x58';
	if (hex_input  == "59") 
		return '\x59';
	if (hex_input  == "5A") 
		return '\x5A';
	if (hex_input  == "5B") 
		return '\x5B';
	if (hex_input  == "5C") 
		return '\x5C';
	if (hex_input  == "5D") 
		return '\x5D';
	if (hex_input  == "5E") 
		return '\x5E';
	if (hex_input  == "5F") 
		return '\x5F';
	
	if (hex_input  == "60") 
		return '\x60';
	if (hex_input  == "61") 
		return '\x61';
	if (hex_input  == "62") 
		return '\x62';
	if (hex_input  == "63") 
		return '\x63';
	if (hex_input  == "64") 
		return '\x64';
	if (hex_input  == "65") 
		return '\x65';
	if (hex_input  == "66") 
		return '\x66';
	if (hex_input  == "67") 
		return '\x67';
	if (hex_input  == "68") 
		return '\x68';
	if (hex_input  == "69") 
		return '\x69';
	if (hex_input  == "6A") 
		return '\x6A';
	if (hex_input  == "6B") 
		return '\x6B';
	if (hex_input  == "6C") 
		return '\x6C';
	if (hex_input  == "6D") 
		return '\x6D';
	if (hex_input  == "6E") 
		return '\x6E';
	if (hex_input  == "6F") 
		return '\x6F';

	if (hex_input  == "70") 
		return '\x70';
	if (hex_input  == "71") 
		return '\x71';
	if (hex_input  == "72") 
		return '\x72';
	if (hex_input  == "73") 
		return '\x73';
	if (hex_input  == "74") 
		return '\x74';
	if (hex_input  == "75") 
		return '\x75';
	if (hex_input  == "76") 
		return '\x76';
	if (hex_input  == "77") 
		return '\x77';
	if (hex_input  == "78") 
		return '\x78';
	if (hex_input  == "79") 
		return '\x79';
	if (hex_input  == "7A") 
		return '\x7A';
	if (hex_input  == "7B") 
		return '\x7B';
	if (hex_input  == "7C") 
		return '\x7C';
	if (hex_input  == "7D") 
		return '\x7D';
	if (hex_input  == "7E") 
		return '\x7E';
	if (hex_input  == "7F") 
		return '\x7F';

	if (hex_input  == "80") 
		return '\x80';
	if (hex_input  == "81") 
		return '\x81';
	if (hex_input  == "82") 
		return '\x82';
	if (hex_input  == "83") 
		return '\x83';
	if (hex_input  == "84") 
		return '\x84';
	if (hex_input  == "85") 
		return '\x85';
	if (hex_input  == "86") 
		return '\x86';
	if (hex_input  == "87") 
		return '\x87';
	if (hex_input  == "88") 
		return '\x88';
	if (hex_input  == "89") 
		return '\x89';
	if (hex_input  == "8A") 
		return '\x8A';
	if (hex_input  == "8B") 
		return '\x8B';
	if (hex_input  == "8C") 
		return '\x8C';
	if (hex_input  == "8D") 
		return '\x8D';
	if (hex_input  == "8E") 
		return '\x8E';
	if (hex_input  == "8F") 
		return '\x8F';

	if (hex_input  == "90") 
		return '\x90';
	if (hex_input  == "91") 
		return '\x91';
	if (hex_input  == "92") 
		return '\x92';
	if (hex_input  == "93") 
		return '\x93';
	if (hex_input  == "94") 
		return '\x94';
	if (hex_input  == "95") 
		return '\x95';
	if (hex_input  == "96") 
		return '\x96';
	if (hex_input  == "97") 
		return '\x97';
	if (hex_input  == "98") 
		return '\x98';
	if (hex_input  == "99") 
		return '\x99';
	if (hex_input  == "9A") 
		return '\x9A';
	if (hex_input  == "9B") 
		return '\x9B';
	if (hex_input  == "9C") 
		return '\x9C';
	if (hex_input  == "9D") 
		return '\x9D';
	if (hex_input  == "9E") 
		return '\x9E';
	if (hex_input  == "9F") 
		return '\x9F';

	if (hex_input  == "A0") 
		return '\xA0';
	if (hex_input  == "A1") 
		return '\xA1';
	if (hex_input  == "A2") 
		return '\xA2';
	if (hex_input  == "A3") 
		return '\xA3';
	if (hex_input  == "A4") 
		return '\xA4';
	if (hex_input  == "A5") 
		return '\xA5';
	if (hex_input  == "A6") 
		return '\xA6';
	if (hex_input  == "A7") 
		return '\xA7';
	if (hex_input  == "A8") 
		return '\xA8';
	if (hex_input  == "A9") 
		return '\xA9';
	if (hex_input  == "AA") 
		return '\xAA';
	if (hex_input  == "AB") 
		return '\xAB';
	if (hex_input  == "AC") 
		return '\xAC';
	if (hex_input  == "AD") 
		return '\xAD';
	if (hex_input  == "AE") 
		return '\xAE';
	if (hex_input  == "AF") 
		return '\xAF';

	if (hex_input  == "B0") 
		return '\xB0';
	if (hex_input  == "B1") 
		return '\xB1';
	if (hex_input  == "B2") 
		return '\xB2';
	if (hex_input  == "B3") 
		return '\xB3';
	if (hex_input  == "B4") 
		return '\xB4';
	if (hex_input  == "B5") 
		return '\xB5';
	if (hex_input  == "B6") 
		return '\xB6';
	if (hex_input  == "B7") 
		return '\xB7';
	if (hex_input  == "B8") 
		return '\xB8';
	if (hex_input  == "B9") 
		return '\xB9';
	if (hex_input  == "BA") 
		return '\xBA';
	if (hex_input  == "BB") 
		return '\xBB';
	if (hex_input  == "BC") 
		return '\xBC';
	if (hex_input  == "BD") 
		return '\xBD';
	if (hex_input  == "BE") 
		return '\xBE';
	if (hex_input  == "BF") 
		return '\xBF';
	
	if (hex_input  == "C0") 
		return '\xC0';
	if (hex_input  == "C1") 
		return '\xC1';
	if (hex_input  == "C2") 
		return '\xC2';
	if (hex_input  == "C3") 
		return '\xC3';
	if (hex_input  == "C4") 
		return '\xC4';
	if (hex_input  == "C5") 
		return '\xC5';
	if (hex_input  == "C6") 
		return '\xC6';
	if (hex_input  == "C7") 
		return '\xC7';
	if (hex_input  == "C8") 
		return '\xC8';
	if (hex_input  == "C9") 
		return '\xC9';
	if (hex_input  == "CA") 
		return '\xCA';
	if (hex_input  == "CB") 
		return '\xCB';
	if (hex_input  == "CC") 
		return '\xCC';
	if (hex_input  == "CD") 
		return '\xCD';
	if (hex_input  == "CE") 
		return '\xCE';
	if (hex_input  == "CF") 
		return '\xCF';

	if (hex_input  == "D0") 
		return '\xD0';
	if (hex_input  == "D1") 
		return '\xD1';
	if (hex_input  == "D2") 
		return '\xD2';
	if (hex_input  == "D3") 
		return '\xD3';
	if (hex_input  == "D4") 
		return '\xD4';
	if (hex_input  == "D5") 
		return '\xD5';
	if (hex_input  == "D6") 
		return '\xD6';
	if (hex_input  == "D7") 
		return '\xD7';
	if (hex_input  == "D8") 
		return '\xD8';
	if (hex_input  == "D9") 
		return '\xD9';
	if (hex_input  == "DA") 
		return '\xDA';
	if (hex_input  == "DB") 
		return '\xDB';
	if (hex_input  == "DC") 
		return '\xDC';
	if (hex_input  == "DD") 
		return '\xDD';
	if (hex_input  == "DE") 
		return '\xDE';
	if (hex_input  == "DF") 
		return '\xDF';

	if (hex_input  == "E0") 
		return '\xE0';
	if (hex_input  == "E1") 
		return '\xE1';
	if (hex_input  == "E2") 
		return '\xE2';
	if (hex_input  == "E3") 
		return '\xE3';
	if (hex_input  == "E4") 
		return '\xE4';
	if (hex_input  == "E5") 
		return '\xE5';
	if (hex_input  == "E6") 
		return '\xE6';
	if (hex_input  == "E7") 
		return '\xE7';
	if (hex_input  == "E8") 
		return '\xE8';
	if (hex_input  == "E9") 
		return '\xE9';
	if (hex_input  == "EA") 
		return '\xEA';
	if (hex_input  == "EB") 
		return '\xEB';
	if (hex_input  == "EC") 
		return '\xEC';
	if (hex_input  == "ED") 
		return '\xED';
	if (hex_input  == "EE") 
		return '\xEE';
	if (hex_input  == "EF") 
		return '\xEF';

	if (hex_input  == "F0") 
		return '\xF0';
	if (hex_input  == "F1") 
		return '\xF1';

  if (hex_input  == "F2") 
		return '\xF2';

	if (hex_input  == "F3") 
		return '\xF3';
	if (hex_input  == "F4") 
		return '\xF4';
	if (hex_input  == "F5") 
		return '\xF5';
	if (hex_input  == "F6") 
		return '\xF6';
	if (hex_input  == "F7") 
		return '\xF7';
	if (hex_input  == "F8") 
		return '\xF8';
	if (hex_input  == "F9") 
		return '\xF9';
	if (hex_input  == "FA") 
		return '\xFA';
	if (hex_input  == "FB") 
		return '\xFB';
	if (hex_input  == "FC") 
		return '\xFC';
	if (hex_input  == "FD") 
		return '\xFD';
	if (hex_input  == "FE") 
		return '\xFE';
	if (hex_input  == "FF") 
		return '\xFF';
	

	
	return '\x09';

}



RWCString MQUtility::SetMsgField8583( int input_field ) 
{

	char buffer[20];
 	RWCString msg_reponse_with_tcp_header = "";
	
		if (input_field == 7)
		{
		
			RWDate d;

			RWTime t;   // Current time
			transmition_date_time = "";
			char buffer[20];
		 	int month_of_year  = d.month();
			int day_of_month   = d.dayOfMonth();
			int hour_of_day    = t.hourGMT(); 
			int minute_of_hour = t.minuteGMT();
			int second_of_hour = t.second(); 

			_itoa( month_of_year, buffer, 10 );
			if(month_of_year < 10)
			transmition_date_time+="0";
			transmition_date_time+=buffer;

			_itoa( day_of_month, buffer, 10 );
			if(day_of_month < 10)
			transmition_date_time+="0";
			transmition_date_time+=buffer;

			_itoa( hour_of_day, buffer, 10 );
			if(hour_of_day < 10)
			transmition_date_time+="0"; 
			transmition_date_time+=buffer;
  
			_itoa( minute_of_hour, buffer, 10 );
			if( minute_of_hour < 10)
			transmition_date_time+="0"; 
			transmition_date_time+=buffer;
  
			_itoa( second_of_hour, buffer, 10 );
			if( second_of_hour < 10)
			transmition_date_time+="0"; 
			transmition_date_time+=buffer;
			msg_reponse_with_tcp_header=transmition_date_time;
//			cout << transmition_date_time << endl;


		}		

		if (input_field == 10)
		{
		
			convertion_rate = "214";


		}		

	
		
		
		
		if (input_field == 12)
		{
		
			RWTime t;   // Current time
			time_local_transaction = "";
			char buffer[20];
			int hour_of_day    = t.hourGMT(); 
			int minute_of_hour = t.minuteGMT();
			int second_of_hour = t.second(); 

			_itoa( hour_of_day, buffer, 10 );
			if(hour_of_day < 10)
			time_local_transaction+="0"; 
			time_local_transaction+=buffer;
  
			_itoa( minute_of_hour, buffer, 10 );
			if( minute_of_hour < 10)
			time_local_transaction+="0"; 
			time_local_transaction+=buffer;
  
			_itoa( second_of_hour, buffer, 10 );
			if( second_of_hour < 10)
			time_local_transaction+="0"; 
			time_local_transaction+=buffer;
			msg_reponse_with_tcp_header=time_local_transaction;

		}		

		if (input_field == 13)
		{
		
			RWDate d;
			date_local_transaction = "";
			char buffer[20];
		 	int month_of_year  = d.month();
			int day_of_month   = d.dayOfMonth();

			_itoa( month_of_year, buffer, 10 );
			if(month_of_year < 10)
			date_local_transaction+="0";
			date_local_transaction+=buffer;

			_itoa( day_of_month, buffer, 10 );
			if(day_of_month < 10)
			date_local_transaction+="0";
			date_local_transaction+=buffer;
			msg_reponse_with_tcp_header=date_local_transaction;

		}		
		if (input_field == 24)
		{
		
			for_athd = "ATHD";


		}		


		if (input_field == 32)
		{
			//Este campo es el no debe ser mayor de 11 y para B24 debe ser minimo 09
			int input_field_length = acquiring_institution_id_code.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			acquiring_institution_id_code = cero_field + acquiring_institution_id_code;
							
		}		
		
		if (input_field == 35)
		{
			//Este campo no debe ser mayor de 37
			int input_field_length = track_2.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = RWCString(buffer) ;
			track_2 = cero_field + track_2;
		
		}	

		if (input_field == 37)
		{
		    
			//struct  tstruct;

		//	_ftime( &tstruct );
		//	printf( "Plus milliseconds:\t\t\t%u\n", tstruct.millitm );
    
			srand( (unsigned)time( NULL ));
			char buffer1[20];
			char buffer2[20];
			char buffer3[20];
			char buffer4[20];

			int valor1 = unsigned(rand());
			int valor2 = unsigned(rand());
			int valor3 = unsigned(rand());
			int valor4 = unsigned(rand());
			
			_itoa( valor1, buffer1, 10 );
			_itoa( valor2, buffer2, 10 );
			_itoa( valor3, buffer3, 10 );
			_itoa( valor4, buffer4, 10 );

			RWCString primero = RWCString(buffer1);
			RWCString segundo = RWCString(buffer2);
			RWCString tercero = RWCString(buffer3);
			RWCString cuarto  = RWCString(buffer4);


			//cout << endl;
			//cout << "<<<<<<<<<<Valor de primero>>>>>>>>>>> " << primero << endl;
			//cout << "<<<<<<<<<<Valor de segundo>>>>>>>>>>>" << segundo << endl;
			//cout << "<<<<<<<<<<Valor de tercero>>>>>>>>>>> " << tercero << endl;
			//cout << "<<<<<<<<<<Valor de cuarto >>>>>>>>>>>" << cuarto<< endl;
			//cout << endl;

			retrieval_reference_number = ((primero+segundo+tercero)(((primero+segundo+tercero).length()-12),12));
			//((primero+segundo+tercero).length()-12)
			pos_invoice_data=retrieval_reference_number(2,10)+retrieval_reference_number(2,10);

		}


	

		if (input_field == 48)
		{
			//Este campo no debe ser mayor de 30 y para B24 debe ser 27
			int input_field_length = pos_retailer_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_retailer_data = cero_field + pos_retailer_data;
	
		}			
		
		if (input_field == 60)
		{
			//Este campo no debe ser mayor de 19
			int input_field_length = pos_terminal_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_terminal_data = cero_field + pos_terminal_data;
		
		}			
			
		if (input_field == 61)
		{
			//Este campo no debe ser mayor de 22
			int input_field_length = pos_issuer_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_issuer_data = cero_field + pos_issuer_data;
	
		}			
	/*
		if (input_field == 70)
		{
			//Este campo no debe ser mayor de 22
			int input_field_length = network_managment_info_code.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			network_managment_info_code = cero_field + network_managment_info_code;
	
		}			
	*/
		if (input_field == 120)
		{
			//Este campo no debe ser mayor de 32
			int input_field_length = pos_terminal_address_branch.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_terminal_address_branch = cero_field + pos_terminal_address_branch;
	
		
		}			

		if (input_field == 123)
		{
	
			//Este campo no debe ser mayor de 23
			int input_field_length = pos_invoice_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_invoice_data = cero_field + pos_invoice_data;
	
		}			

		if (input_field == 125)
		{
	
			//Este campo no debe ser mayor de 15
			int input_field_length = pos_settlement_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_settlement_data = cero_field + pos_settlement_data;
	
			
		}			
	


	return msg_reponse_with_tcp_header;

}


RWCString MQUtility::setBitMap( RWCString input_four_bit)
{

   	if (input_four_bit == "0000")
		bit_map_ascii = "0";

  	if (input_four_bit == "0001")
		bit_map_ascii = "1";

	if (input_four_bit == "0010")
		bit_map_ascii = "2";

	if (input_four_bit == "0011")
		bit_map_ascii = "3";

  	if (input_four_bit == "0100")
		bit_map_ascii = "4";

	if (input_four_bit == "0101")
		bit_map_ascii = "5";

	if (input_four_bit == "0101")
		bit_map_ascii = "5";

	if (input_four_bit == "0110")
		bit_map_ascii = "6";

	if (input_four_bit == "0111")
		bit_map_ascii = "7";

	if (input_four_bit == "1000")
		bit_map_ascii = "8";

	if (input_four_bit == "1001")
		bit_map_ascii = "9";

	if (input_four_bit == "1010")
		bit_map_ascii = "A";

	if (input_four_bit == "1011")
		bit_map_ascii = "B";

	if (input_four_bit == "1100")
		bit_map_ascii = "C";

	if (input_four_bit == "1101")
		bit_map_ascii = "D";

	if (input_four_bit == "1110")
		bit_map_ascii = "E";

	if (input_four_bit == "1111")
		bit_map_ascii = "F";


	return bit_map_ascii;
}

RWCString MQUtility::setBitMapFromChar( RWCString input_four_bit)
{

   	int i = 0;
	int j = 0;
	RWCString retorno_bit_map;
	RWCString bit_map_field;
	

	for(j = 0; j < 32 ; j++)
	{
		bit_map_field=input_four_bit(j,1);
	
		i = 0;
		for( i = 0; i < 1 ; i++)
		{
			if (bit_map_field == "0")
				retorno_bit_map += "0000";

			if (bit_map_field == "1")
				retorno_bit_map += "0001";

			if (bit_map_field == "2")
				retorno_bit_map += "0010";

			if (bit_map_field == "3")
				retorno_bit_map += "0011";

  			if (bit_map_field == "4")
				retorno_bit_map += "0100";

			if (bit_map_field == "5")
				retorno_bit_map += "0101";

			if (bit_map_field == "6")
				retorno_bit_map += "0110";

			if (bit_map_field == "7")
				retorno_bit_map += "0111";

			if (bit_map_field == "8")
				retorno_bit_map += "1000";

			if (bit_map_field == "9")
				retorno_bit_map += "1001";

			if (bit_map_field == "A")
				retorno_bit_map += "1010";

			if (bit_map_field == "B")
				retorno_bit_map += "1011";

			if (bit_map_field == "C")
				retorno_bit_map += "1100";

			if (bit_map_field == "D")
				retorno_bit_map += "1101";

			if (bit_map_field == "E")
				retorno_bit_map += "1110";

			if (bit_map_field == "F")
				retorno_bit_map +="1111";

		}

	}
	return retorno_bit_map;
}


RWCString MQUtility::SetB24Header0200Pos( RWCString incoming_header ) 
{
	RWCString header_base24_0200= incoming_header;
	header_base24_0200+=complete_iso8583_msg;
	return complete_iso8583_msg = header_base24_0200;				
}

void MQUtility::MessageErrorLength(RWCString incoming_name, int wrong_field_length, 
						int correct_field_length) 
{

	cout << "El largo de " <<  incoming_name << " es incorrecto > " 
	     << " es de " << wrong_field_length <<" y debe ser "
		 << correct_field_length << endl;
		 cout << "***********Transaccion abortada1********** > " << endl;

}

int MQUtility::VerifyNumericField(char *incoming_field, const int length_field, 
					   RWCString validated_field)
{
	int i = 0;
	int flag = 1;
	char *test_isdigit = {""};
	for (i = 0 ; i < length_field;i++)
	{
		if(!isdigit(incoming_field[i]))
		{
			cout << "<********Este campo >" << validated_field << "< no es numerico*******>" << endl;
			flag =0;
		}
	
	}
	
	  return flag;

}

int MQUtility::VerifyHexField(char *incoming, const int length_field,RWCString validated_field)
{

	int i = 0;
	int flag = 1;
	char *test_isdigit = {""};
	for (i = 0 ; i < length_field;i++)
	{
		if(!isxdigit(incoming[i]))
		{
			cout << "<********Este campo >" << validated_field << "< no es Hexadecimal*******> " << endl;
			flag =0;
		}
	}
 
	  return flag;

}


RWCString MQUtility::SetField( int input_field ,RWCString field_value) 
{
	char incoming_field[256] = {""};
	
	RWCString msg_reponse_with_tcp_header = "";
	

	while(1)
	{
	
		if (input_field == 0)
		{
			message_type = field_value; 
			int message_type_length = message_type.length();
			if( message_type_length != 4)
			{
					
				MessageErrorLength(RWCString("message_type"),
					message_type_length,4);
				break;
			}
			
			strcpy(incoming_field,message_type);
		
			if ( (VerifyNumericField(incoming_field, 4,
				RWCString("message_type"))) == 0)
			{
				break;
			}
	
		}
		if (input_field == 3)
		{
			processing_code = field_value; 
			int processing_code_length_length = processing_code.length();
			if( processing_code_length_length != 6)
			{
			
				MessageErrorLength(RWCString("processing_code"),
				processing_code_length_length,6);
				break;
			}
		
			strcpy(incoming_field,processing_code);
		
			if ( (VerifyNumericField(incoming_field,6 ,
				RWCString("processing_code"))) == 0)
			{
				break;
			}
		
		}
		
		if (input_field == 4)
		{
			transaction_amount = field_value; 
			int transaction_amount_length = transaction_amount.length();
			if( transaction_amount_length != 12)
			{
				MessageErrorLength(RWCString("transaction_amount"),
					transaction_amount_length,12);
				break;
			}
	
			strcpy(incoming_field,transaction_amount);
	
			if ( (VerifyNumericField(incoming_field,12 ,
					RWCString("transaction_amount"))) == 0)
			{
				break;
			}
		
		}

	
		break;
	}

	return field_value;
}



RWCString MQUtility::SetMsgField( int input_field ) 
{

	char buffer[20];
 	RWCString msg_reponse_with_tcp_header = "";
	while(1)
	{
	
		if (input_field == 7)
		{
		
			RWDate d;

			RWTime t;   // Current time
			transmition_date_time = "";
			char buffer[20];
		 	int month_of_year  = d.month();
			int day_of_month   = d.dayOfMonth();
			int hour_of_day    = t.hourGMT(); 
			int minute_of_hour = t.minuteGMT();
			int second_of_hour = t.second(); 

			_itoa( month_of_year, buffer, 10 );
			if(month_of_year < 10)
			transmition_date_time+="0";
			transmition_date_time+=buffer;

			_itoa( day_of_month, buffer, 10 );
			if(day_of_month < 10)
			transmition_date_time+="0";
			transmition_date_time+=buffer;

			_itoa( hour_of_day, buffer, 10 );
			if(hour_of_day < 10)
			transmition_date_time+="0"; 
			transmition_date_time+=buffer;
  
			_itoa( minute_of_hour, buffer, 10 );
			if( minute_of_hour < 10)
			transmition_date_time+="0"; 
			transmition_date_time+=buffer;
  
			_itoa( second_of_hour, buffer, 10 );
			if( second_of_hour < 10)
			transmition_date_time+="0"; 
			transmition_date_time+=buffer;

//			cout << transmition_date_time << endl;
			msg_reponse_with_tcp_header=transmition_date_time;

		}		

		if (input_field == 10)
		{
		
			convertion_rate = "214";


		}		

	
		if (input_field == 11)
		{
    
			srand( (unsigned)time( NULL ));
			char buffer1[20];
			char buffer2[20];
			char buffer3[20];
			char buffer4[20];

			int valor1 = unsigned(rand());
			int valor2 = unsigned(rand());
			int valor3 = unsigned(rand());
			int valor4 = unsigned(rand());
			
			_itoa( valor1, buffer1, 10 );
			_itoa( valor2, buffer2, 10 );
			_itoa( valor3, buffer3, 10 );
			_itoa( valor4, buffer4, 10 );

			RWCString primero = RWCString(buffer1);
			RWCString segundo = RWCString(buffer2);
			RWCString tercero = RWCString(buffer3);
			RWCString cuarto  = RWCString(buffer4);


			retrieval_reference_number = ((primero+segundo+tercero)(((primero+segundo+tercero).length()-12),12));
			pos_invoice_data=retrieval_reference_number(2,10)+retrieval_reference_number(2,10);

			msg_reponse_with_tcp_header = retrieval_reference_number(0,6);
		}
		
		
		
		if (input_field == 12)
		{
		
			RWTime t;   // Current time
			time_local_transaction = "";
			char buffer[20];
			int hour_of_day    = t.hourGMT(); 
			int minute_of_hour = t.minuteGMT();
			int second_of_hour = t.second(); 

			_itoa( hour_of_day, buffer, 10 );
			if(hour_of_day < 10)
			time_local_transaction+="0"; 
			time_local_transaction+=buffer;
  
			_itoa( minute_of_hour, buffer, 10 );
			if( minute_of_hour < 10)
			time_local_transaction+="0"; 
			time_local_transaction+=buffer;
  
			_itoa( second_of_hour, buffer, 10 );
			if( second_of_hour < 10)
			time_local_transaction+="0"; 
			time_local_transaction+=buffer;


		}		

		if (input_field == 13)
		{
		
			RWDate d;
			date_local_transaction = "";
			char buffer[20];
		 	int month_of_year  = d.month();
			int day_of_month   = d.dayOfMonth();

			_itoa( month_of_year, buffer, 10 );
			if(month_of_year < 10)
			date_local_transaction+="0";
			date_local_transaction+=buffer;

			_itoa( day_of_month, buffer, 10 );
			if(day_of_month < 10)
			date_local_transaction+="0";
			date_local_transaction+=buffer;


		}		
		if (input_field == 24)
		{
		
			for_athd = "ATHD";


		}		


		if (input_field == 32)
		{
			//Este campo es el no debe ser mayor de 11 y para B24 debe ser minimo 09
			int input_field_length = acquiring_institution_id_code.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			acquiring_institution_id_code = cero_field + acquiring_institution_id_code;
							
		}		
		
		if (input_field == 35)
		{
			//Este campo no debe ser mayor de 37
			int input_field_length = track_2.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = RWCString(buffer) ;
			track_2 = cero_field + track_2;
		
		}	

		if (input_field == 37)
		{
		    
			//struct  tstruct;

		//	_ftime( &tstruct );
		//	printf( "Plus milliseconds:\t\t\t%u\n", tstruct.millitm );
    
			srand( (unsigned)time( NULL ));
			char buffer1[20];
			char buffer2[20];
			char buffer3[20];
			char buffer4[20];

			int valor1 = unsigned(rand());
			int valor2 = unsigned(rand());
			int valor3 = unsigned(rand());
			int valor4 = unsigned(rand());
			
			_itoa( valor1, buffer1, 10 );
			_itoa( valor2, buffer2, 10 );
			_itoa( valor3, buffer3, 10 );
			_itoa( valor4, buffer4, 10 );

			RWCString primero = RWCString(buffer1);
			RWCString segundo = RWCString(buffer2);
			RWCString tercero = RWCString(buffer3);
			RWCString cuarto  = RWCString(buffer4);


			//cout << endl;
			//cout << "<<<<<<<<<<Valor de primero>>>>>>>>>>> " << primero << endl;
			//cout << "<<<<<<<<<<Valor de segundo>>>>>>>>>>>" << segundo << endl;
			//cout << "<<<<<<<<<<Valor de tercero>>>>>>>>>>> " << tercero << endl;
			//cout << "<<<<<<<<<<Valor de cuarto >>>>>>>>>>>" << cuarto<< endl;
			//cout << endl;

			retrieval_reference_number = ((primero+segundo+tercero)(((primero+segundo+tercero).length()-12),12));
			//((primero+segundo+tercero).length()-12)
			pos_invoice_data=retrieval_reference_number(2,10)+retrieval_reference_number(2,10);

		}


	

		if (input_field == 48)
		{
			//Este campo no debe ser mayor de 30 y para B24 debe ser 27
			int input_field_length = pos_retailer_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_retailer_data = cero_field + pos_retailer_data;
	
		}			
		
		if (input_field == 60)
		{
			//Este campo no debe ser mayor de 19
			int input_field_length = pos_terminal_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_terminal_data = cero_field + pos_terminal_data;
		
		}			
			
		if (input_field == 61)
		{
			//Este campo no debe ser mayor de 22
			int input_field_length = pos_issuer_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_issuer_data = cero_field + pos_issuer_data;
	
		}			
	/*
		if (input_field == 70)
		{
			//Este campo no debe ser mayor de 22
			int input_field_length = network_managment_info_code.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			network_managment_info_code = cero_field + network_managment_info_code;
	
		}			
	*/
		if (input_field == 120)
		{
			//Este campo no debe ser mayor de 32
			int input_field_length = pos_terminal_address_branch.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_terminal_address_branch = cero_field + pos_terminal_address_branch;
	
		
		}			

		if (input_field == 123)
		{
	
			//Este campo no debe ser mayor de 23
			int input_field_length = pos_invoice_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_invoice_data = cero_field + pos_invoice_data;
	
		}			

		if (input_field == 125)
		{
	
			//Este campo no debe ser mayor de 15
			int input_field_length = pos_settlement_data.length();
			_itoa( input_field_length, buffer, 10 );
			RWCString cero_field = "0" + RWCString(buffer) ;
			pos_settlement_data = cero_field + pos_settlement_data;
	
			
		}			
	
		break;
	}

	return msg_reponse_with_tcp_header;

}



RWCString MQUtility::SetMsgField( int input_field ,RWCString field_value, RWCString pre_field) 
{
	char incoming_field[256] = {""};
	
	RWCString msg_reponse_with_tcp_header = "";
	RWCString msg_field_to_iso = "";
	while(1)
	{
	
		if (input_field == 32)
		{
			//Este campo debe ser no mayor de 11 numerico y para B24 debe
			//ser 09
			acquiring_institution_id_code = pre_field + field_value;
						
		}		
		
		if (input_field == 48)
		{
			
			//Este campo es variable y debe ser de 37 y delante del campo debe ir un 37
			
			pos_retailer_data = pre_field + field_value;
		
		}	
		
	
		if (input_field == 60)
		{
			pos_terminal_data = pre_field + field_value;
			
		}			
	
		if (input_field == 61)
		{
			pos_issuer_data = pre_field + field_value;
		
		}			
		
		if (input_field == 120)
		{
			pos_terminal_address_branch = pre_field + field_value;
		
		}			

		
		if (input_field == 123)
		{
			pos_invoice_data = pre_field + field_value;
		}			

		if (input_field == 125)
		{
			pos_settlement_data = pre_field + field_value;
		
		}			
		
		break;
	}

	return msg_reponse_with_tcp_header;

}
/*
void MQUtility::ReturnDumpIsoGeneric( char *msg_type, int debugSB, RWCString peerAddress, int server_port) 
{
	
	RWTime t;   // Current time
	RWTime d(RWTime::beginDST(1990, RWZone::local()));
	cout << endl;
	cout << "["  << t <<   "] -" << " <" << msg_type << ">" << " Message from b-source " 
		<<  "[" << peerAddress << ":" << server_port << "]"   << endl; 

	if( (debugSB == 1) && ( (strncmp(msg_type, "0200", 4) == 0) || ((strncmp(msg_type, "0210", 4) == 0)  ) || ((strncmp(msg_type, "0100", 4) == 0)  )))

	{
	
		cout << endl;
		cout << msg_type << ":" << endl;
		cout << "    <field id=*3* value=<"   << processing_code				<< ">" << endl;  
		cout << "    <field id=*4* value=<"   << transaction_amount				<< ">" << endl; 
		cout << "    <field id=*7* value=<"   << transmition_date_time			<< ">" << endl;
		cout << "    <field id=*11* value=<"  << system_trace					<< ">" << endl; 
		cout << "    <field id=*12* value=<"  << time_local_transaction			<< ">" << endl; 
		cout << "    <field id=*13* value=<"  << date_local_transaction			<< ">" << endl;
		cout << "    <field id=*14* value=<"  << expiration_date				<< ">" << endl;
		//cout << "    <field id=*15* value=<"  << date_settlement_015			<< ">" << endl;
		cout << "    <field id=*17* value=<"  << capture_date					<< ">" << endl; 
		cout << "    <field id=*18* value=<"  << merchant_type					<< ">" << endl; 
		cout << "    <field id=*22* value=<"  << pos_entry_mode					<< ">" << endl; 
		cout << "    <field id=*25* value=<"  << pos_condition_code				<< ">" << endl; 
		cout << "    <field id=*32* value=<"   << acquiring_institution_id_code	<< ">" << endl;  
		cout << "    <field id=*35* value=<"   << track_2 						<< ">" << endl;  
		cout << "    <field id=*37* value=<"   << retrieval_reference_number 	<< ">" << endl;  
		//cout << "    <field id=*38* value=<"   << responde_id_response_038 	<< ">" << endl;  
       // cout << "    <field id=*39* value=<"   << responde_code_039 	<< ">" << endl;  
		cout << "    <field id=*41* value=<"   << card_acceptor_terminal_id 	<< ">" << endl;  
		cout << "    <field id=*42* value=<"   << card_acceptor_id_code 	<< ">" << endl;  
		cout << "    <field id=*43* value=<"   << card_acceptor_name_location 	<< ">" << endl;  
		cout << "    <field id=*48* value=<"   << pos_retailer_data 			<< ">" << endl;  
		cout << "    <field id=*49* value=<"   << currency_code_transaction 	<< ">" << endl;  
		cout << "    <field id=*52* value=<"   << pin_data 	<< ">" << endl;  
		cout << "    <field id=*60* value=<"   << pos_terminal_data 		<< ">" << endl;  
        cout << "    <field id=*61* value=<"   << pos_issuer_data 			<< ">" << endl;  
		
		cout << "    <field id=*120* value=<"   << pos_terminal_address_branch 			<< ">" << endl;  
		cout << "    <field id=*123* value=<"   << pos_invoice_data 			<< ">" << endl;  
		
		cout << "    <field id=*125* value=<"  << pos_settlement_data 	<< ">" << endl;  
		cout << "    <field id=*127.2* value=<"  << switch_key 	<< ">" << endl;  
		
		cout << endl;
	}
	
	
	

}
*/


RWCString MQUtility::SendMessageToQueue(RWCString incoming, char *send_queue1,char *queue_mgr1)
{
	
   //FILE * fp ;                      // Console

	//cout << "Valor de incoming > " << incoming << endl;
	RWCString recv_queue_rw;
	MQUtility retorno_field_125;
	//**Se toma el campo 125 y se copia al recv_queue**//		
	recv_queue_rw = retorno_field_125.Retorno_Msg_Iso8583_Field125(incoming, "0200", 0 , "base24");

//	cout << "Despues >>> " << endl;

  ImqQueueManager mgr;             // Queue manager
  ImqQueue queueA;                  // Queue
  ImqQueue queueB;                  // Queue
  ImqMessage msg;                  // Data message
  ImqMessage msg2;                  // Data message
  
  int      buflen;                 // Buffer length
  char     buffer[ 1024 ] = {""};          // Message buffer
  ImqDistributionList dlist;	   // Distribution List
  ImqChannel * pchannel = 0 ;      // Channel definition

  strcpy(buffer, incoming);
 	
  char test_input[] = "SYSTEM.DEF.SVRCONN/TCP/127.0.0.1(1414)";
  ImqString strParse( test_input );
 	  
  ImqString strToken ;

  pchannel = new ImqChannel ;
  pchannel -> setHeartBeatInterval( 1L );

    // Break down the channel definition,
    // which is of the form "channel-name/transport-type/connection-name".
    if ( strParse.cutOut( strToken, '/' ) ) {
      pchannel -> setChannelName( strToken );
      if ( strParse.cutOut( strToken, '/' ) ) {

        // Interpret the transport type.
        if ( strToken.upperCase( ) == (ImqString)"LU62" ) {
          pchannel -> setTransportType( MQXPT_LU62 );
        }
        if ( strToken.upperCase( ) == (ImqString)"NETBIOS" ) {
          pchannel -> setTransportType( MQXPT_NETBIOS );
        }
        if ( strToken.upperCase( ) == (ImqString)"SPX" ) {
          pchannel -> setTransportType( MQXPT_SPX );
        }
        if ( strToken.upperCase( ) == (ImqString)"TCP" ) {
          pchannel -> setTransportType( MQXPT_TCP );
        }

        // Establish the connection name.
        if ( strParse.cutOut( strToken ) ) {
          pchannel -> setConnectionName( strToken );
       
		
		
		}
      }
	
	mgr.setChannelReference( pchannel );
	 
  }
 
  mgr.setName( queue_mgr1 );
  // Connect to queue manager

  if ( ! mgr.connect( ) ) {

    /* stop if it failed */
    printf( "ImqQueueManager::connect ended with reason code %d\n",
            (int)mgr.reasonCode( ) );
    exit( (int)mgr.reasonCode( ) );
  }

  ImqString strManagerName( mgr.name( ) );
  queueA.setConnectionReference( mgr );
 
  queueA.setName( send_queue1 );
  queueA.setQueueManagerName( (char *)strManagerName );

  queueA.setOpenOptions( MQOO_OUTPUT /* open queue for output        */
    + MQOO_FAIL_IF_QUIESCING );     /* but not if MQM stopping      */
  queueA.open( );

  /* report reason, if any; stop if failed      */
  if ( queueA.reasonCode( ) ) {
    printf( "ImqQueue::open ended with reason code %d\n",
            (int)queueA.reasonCode( ) );
  }

  if ( queueA.completionCode( ) == MQCC_FAILED ) {
    printf( "unable to open queue for output\n" );
  }

  msg.setExpiry( 150 );  
  msg.useEmptyBuffer( buffer, sizeof( buffer ) );
  msg.setFormat( MQFMT_STRING );      /* character string format    */

     buflen = (int)strlen( buffer ); /* determine string length    */

     buffer[ buflen ] = '\0' ;            /* add line-end          */
 

   if ( buflen > 0 ) {
      msg.setMessageLength( buflen );
	   msg2.setMessageLength( buflen );
	 
      if ( ! queueA.put( msg ) ) {

        /* report reason, if any */
        printf( "ImqQueueA::put ended with reason code %d\n",
                (int)queueA.reasonCode( ) );
      }


    } else {
      /* quit loop when empty line is read */
     // break ;
    }

	// Close the target queue (if it was opened)
  if ( ! queueA.close( ) ) {

    /* report reason, if any     */
    printf( "ImqQueue::close ended with reason code %d\n",
            (int)queueA.reasonCode( ) );
  }

  // Disconnect from MQM if not already connected (the
  // ImqQueueManager object handles this situation automatically)
  if ( ! mgr.disconnect( ) ) {

    /* report reason, if any     */
    printf( "ImqQueueManager::disconnect ended with reason code %ld\n",
            (long)mgr.reasonCode( ) );
  }

  // Tidy up the channel object if allocated.
  if ( pchannel ) {
    mgr.setChannelReference( );
    delete pchannel ;
  }

	MQUtility input_to_queue;

	input_to_queue.GetTheIniFileInformation() ;

	int count = 0;
	char send_queue_string[20]	 = {""};
	char send_queue_stringeps[20]  = {""};
	char send_queue_stringamex[20] = {""};
	char recv_queue_string[20]	 = {""};
	char sql_queue_string[20]	 = {""};
	char queue_mgr_string[20]	 = {""};
	char header_string[20]		 = {""};
	char application_string[20]  = {""};


	RWCTokenizer next(input_to_queue.GetTheIniFileInformation());
	RWCString token;
	RWCString send_queue,send_queue_eps,send_queue_amex,recv_queue,sql_queue,queue_mgr,header,application;
	while(!(token=next(",")).isNull())
	{
		if (count == 0)
		{
			send_queue = token;
		}
		if (count == 1)
		{
			send_queue_eps= token;
		}
		if (count == 2)
		{
			send_queue_amex = token;
		}
		if (count == 3)
		{
		
			recv_queue = token; 
		}
		if (count == 4)
		{
		
			sql_queue = token; 
		}

		if (count == 5)
		{
		
			queue_mgr = token; 
		}
		if (count == 6)
		{
		
			header = token; 
		}
		if (count == 7)
		{
		
			application = token; 
		}
		count++;
	}
	


	
	recv_queue = recv_queue_rw;

	strcpy(send_queue_string,send_queue);
	strcpy(send_queue_stringeps,send_queue_eps);
	strcpy(send_queue_stringamex,send_queue);
	strcpy(recv_queue_string,recv_queue);
	strcpy(sql_queue_string,sql_queue);
	strcpy(queue_mgr_string,queue_mgr);
	strcpy(header_string,header);
	strcpy(application_string,application);
	
 	MQUtility msg_return;
	MQUtility set_tcp_header1;
	char recv_0210[1024] = {""};


	SendMessageToQueueSql(incoming,sql_queue_string,queue_mgr_string);

	RWCString retorno_0210 = set_tcp_header1.Get_Msg_From_Queue(recv_queue_string,queue_mgr_string);
	
	strcpy(recv_0210, retorno_0210);

	SendMessageToQueueSql(recv_0210,sql_queue_string,queue_mgr_string);
	
	retorno_0210 = "00"+retorno_0210;

	return msg_return.Retorno_210_B24(retorno_0210,"0210",1);


}

int MQUtility::SendMessageToQueueNoTimeout(RWCString incoming, char *recv_queue,char *queue_mgr)
{
	
  

  ImqQueueManager mgr;             // Queue manager
  ImqQueue queueA;                  // Queue
  ImqQueue queueB;                  // Queue
  ImqMessage msg;                  // Data message
  ImqMessage msg2;                  // Data message
  
  int      buflen;                 // Buffer length
  char     buffer[ 1024 ] = {""};          // Message buffer
  ImqDistributionList dlist;	   // Distribution List
  ImqChannel * pchannel = 0 ;      // Channel definition

  strcpy(buffer, incoming);

 	
  char test_input[] = "SYSTEM.DEF.SVRCONN/TCP/127.0.0.1(1414)";
  ImqString strParse( test_input );
	  
  ImqString strToken ;

  pchannel = new ImqChannel ;
  pchannel -> setHeartBeatInterval( 1L );

    // Break down the channel definition,
    // which is of the form "channel-name/transport-type/connection-name".
    if ( strParse.cutOut( strToken, '/' ) ) {
      pchannel -> setChannelName( strToken );
      if ( strParse.cutOut( strToken, '/' ) ) {

        // Interpret the transport type.
        if ( strToken.upperCase( ) == (ImqString)"LU62" ) {
          pchannel -> setTransportType( MQXPT_LU62 );
        }
        if ( strToken.upperCase( ) == (ImqString)"NETBIOS" ) {
          pchannel -> setTransportType( MQXPT_NETBIOS );
        }
        if ( strToken.upperCase( ) == (ImqString)"SPX" ) {
          pchannel -> setTransportType( MQXPT_SPX );
        }
        if ( strToken.upperCase( ) == (ImqString)"TCP" ) {
          pchannel -> setTransportType( MQXPT_TCP );
        }

        // Establish the connection name.
        if ( strParse.cutOut( strToken ) ) {
          pchannel -> setConnectionName( strToken );
       
		
		
		}
      }

    
	
	mgr.setChannelReference( pchannel );
	
	 
  }


  
  mgr.setName( queue_mgr );
  //mgr.setName( "QM_victort8100" );
  
  // Connect to queue manager

  if ( ! mgr.connect( ) ) {

    /* stop if it failed */
    printf( "ImqQueueManager::connect ended with reason code %d\n",
            (int)mgr.reasonCode( ) );
    exit( (int)mgr.reasonCode( ) );
  }

  ImqString strManagerName( mgr.name( ) );
 // printf("Successful connection to queue manager %s\n",
   //                                     (char *)strManagerName );

  // Associate distribution list with queue manager
//  dlist.setConnectionReference( mgr);
  // Associate queue with queue manager.
 // queue.setConnectionReference( mgr );

  queueA.setConnectionReference( mgr );
  //queueB.setConnectionReference( mgr );

  queueA.setName( recv_queue );
//  queueB.setName( sql_queue );
  
  // Use parameter as the name of the target queue

 // printf( "First target queue is %s\n", (char *)queueA.name( ) );
 // printf( "Second target queue is %s\n", (char *)queueB.name( ) );

  queueA.setQueueManagerName( (char *)strManagerName );
//  queueB.setQueueManagerName( (char *)strManagerName );

 queueA.setOpenOptions( MQOO_OUTPUT /* open queue for output        */
    + MQOO_FAIL_IF_QUIESCING );     /* but not if MQM stopping      */
  queueA.open( );

// queueB.setOpenOptions( MQOO_OUTPUT /* open queue for output        */
//    + MQOO_FAIL_IF_QUIESCING );     /* but not if MQM stopping      */
 // queueB.open( );

  
  
  /* report reason, if any; stop if failed      */
  if ( queueA.reasonCode( ) ) {
    printf( "ImqQueue::open ended with reason code %d\n",
            (int)queueA.reasonCode( ) );
  }

  if ( queueA.completionCode( ) == MQCC_FAILED ) {
    printf( "unable to open queue for output\n" );
  }


//  if ( queueB.reasonCode( ) ) {
 //   printf( "ImqQueue::open ended with reason code %d\n",
 //           (int)queueB.reasonCode( ) );
//  }

//  if ( queueB.completionCode( ) == MQCC_FAILED ) {
//    printf( "unable to open queue for output\n" );
//  }

 // msg.setExpiry( 150 );  
  msg.useEmptyBuffer( buffer, sizeof( buffer ) );
  msg.setFormat( MQFMT_STRING );      /* character string format    */
//  msg2.useEmptyBuffer( buffer, sizeof( buffer ) );
//  msg2.setFormat( MQFMT_STRING );      /* character string format    */


     buflen = (int)strlen( buffer ); /* determine string length    */

     buffer[ buflen ] = '\0' ;            /* add line-end          */
 

   if ( buflen > 0 ) {
      msg.setMessageLength( buflen );
	   msg2.setMessageLength( buflen );
	 
      if ( ! queueA.put( msg ) ) {

        /* report reason, if any */
        printf( "ImqQueueA::put ended with reason code %d\n",
                (int)queueA.reasonCode( ) );
      }
//	   if ( ! queueB.put( msg2 ) ) {

        /* report reason, if any */
//        printf( "ImqQueueB::put ended with reason code %d\n",
//                (int)queueB.reasonCode( ) );
//      }


    } else {
      /* quit loop when empty line is read */
     // break ;
    }

	// Close the target queue (if it was opened)
  if ( ! queueA.close( ) ) {

    /* report reason, if any     */
    printf( "ImqQueue::close ended with reason code %d\n",
            (int)queueA.reasonCode( ) );
  }

 //if ( ! queueB.close( ) ) {

    /* report reason, if any     */
 //   printf( "ImqQueue::close ended with reason code %d\n",
//            (int)queueB.reasonCode( ) );
//  }



  // Disconnect from MQM if not already connected (the
  // ImqQueueManager object handles this situation automatically)
  if ( ! mgr.disconnect( ) ) {

    /* report reason, if any     */
    printf( "ImqQueueManager::disconnect ended with reason code %ld\n",
            (long)mgr.reasonCode( ) );
  }

  // Tidy up the channel object if allocated.
  if ( pchannel ) {
    mgr.setChannelReference( );
    delete pchannel ;
  }

 // printf( "Sample IMQSPUT end\n" );
  //return( 0 );
	
 	
	
	return 1;
}
int MQUtility::SendMessageToQueueWithTimeout(RWCString incoming, char *recv_queue,char *queue_mgr)
{
	
  

  ImqQueueManager mgr;             // Queue manager
  ImqQueue queueA;                  // Queue
  ImqQueue queueB;                  // Queue
  ImqMessage msg;                  // Data message
  ImqMessage msg2;                  // Data message
  
  int      buflen;                 // Buffer length
  char     buffer[ 1024 ] = {""};          // Message buffer
  ImqDistributionList dlist;	   // Distribution List
  ImqChannel * pchannel = 0 ;      // Channel definition

  strcpy(buffer, incoming);

 	
  char test_input[] = "SYSTEM.DEF.SVRCONN/TCP/127.0.0.1(1414)";
  ImqString strParse( test_input );
	  
  ImqString strToken ;

  pchannel = new ImqChannel ;
  pchannel -> setHeartBeatInterval( 1L );

    // Break down the channel definition,
    // which is of the form "channel-name/transport-type/connection-name".
    if ( strParse.cutOut( strToken, '/' ) ) {
      pchannel -> setChannelName( strToken );
      if ( strParse.cutOut( strToken, '/' ) ) {

        // Interpret the transport type.
        if ( strToken.upperCase( ) == (ImqString)"LU62" ) {
          pchannel -> setTransportType( MQXPT_LU62 );
        }
        if ( strToken.upperCase( ) == (ImqString)"NETBIOS" ) {
          pchannel -> setTransportType( MQXPT_NETBIOS );
        }
        if ( strToken.upperCase( ) == (ImqString)"SPX" ) {
          pchannel -> setTransportType( MQXPT_SPX );
        }
        if ( strToken.upperCase( ) == (ImqString)"TCP" ) {
          pchannel -> setTransportType( MQXPT_TCP );
        }

        // Establish the connection name.
        if ( strParse.cutOut( strToken ) ) {
          pchannel -> setConnectionName( strToken );
       
		
		
		}
      }

    
	
	mgr.setChannelReference( pchannel );
	
	 
  }


  
  mgr.setName( queue_mgr );
  //mgr.setName( "QM_victort8100" );
  
  // Connect to queue manager

  if ( ! mgr.connect( ) ) {

    /* stop if it failed */
    printf( "ImqQueueManager::connect ended with reason code %d\n",
            (int)mgr.reasonCode( ) );
    exit( (int)mgr.reasonCode( ) );
  }

  ImqString strManagerName( mgr.name( ) );
 // printf("Successful connection to queue manager %s\n",
   //                                     (char *)strManagerName );

  // Associate distribution list with queue manager
//  dlist.setConnectionReference( mgr);
  // Associate queue with queue manager.
 // queue.setConnectionReference( mgr );

  queueA.setConnectionReference( mgr );
  //queueB.setConnectionReference( mgr );

  queueA.setName( recv_queue );
//  queueB.setName( sql_queue );
  
  // Use parameter as the name of the target queue

 // printf( "First target queue is %s\n", (char *)queueA.name( ) );
 // printf( "Second target queue is %s\n", (char *)queueB.name( ) );

  queueA.setQueueManagerName( (char *)strManagerName );
//  queueB.setQueueManagerName( (char *)strManagerName );

 queueA.setOpenOptions( MQOO_OUTPUT /* open queue for output        */
    + MQOO_FAIL_IF_QUIESCING );     /* but not if MQM stopping      */
  queueA.open( );

// queueB.setOpenOptions( MQOO_OUTPUT /* open queue for output        */
//    + MQOO_FAIL_IF_QUIESCING );     /* but not if MQM stopping      */
 // queueB.open( );

  
  
  /* report reason, if any; stop if failed      */
  if ( queueA.reasonCode( ) ) {
    printf( "ImqQueue::open ended with reason code %d\n",
            (int)queueA.reasonCode( ) );
  }

  if ( queueA.completionCode( ) == MQCC_FAILED ) {
    printf( "unable to open queue for output\n" );
  }


//  if ( queueB.reasonCode( ) ) {
 //   printf( "ImqQueue::open ended with reason code %d\n",
 //           (int)queueB.reasonCode( ) );
//  }

//  if ( queueB.completionCode( ) == MQCC_FAILED ) {
//    printf( "unable to open queue for output\n" );
//  }

  msg.setExpiry( 150 );  
  msg.useEmptyBuffer( buffer, sizeof( buffer ) );
  msg.setFormat( MQFMT_STRING );      /* character string format    */
//  msg2.useEmptyBuffer( buffer, sizeof( buffer ) );
//  msg2.setFormat( MQFMT_STRING );      /* character string format    */


     buflen = (int)strlen( buffer ); /* determine string length    */

     buffer[ buflen ] = '\0' ;            /* add line-end          */
 

   if ( buflen > 0 ) {
      msg.setMessageLength( buflen );
	   msg2.setMessageLength( buflen );
	 
      if ( ! queueA.put( msg ) ) {

        /* report reason, if any */
        printf( "ImqQueueA::put ended with reason code %d\n",
                (int)queueA.reasonCode( ) );
      }
//	   if ( ! queueB.put( msg2 ) ) {

        /* report reason, if any */
//        printf( "ImqQueueB::put ended with reason code %d\n",
//                (int)queueB.reasonCode( ) );
//      }


    } else {
      /* quit loop when empty line is read */
     // break ;
    }

	// Close the target queue (if it was opened)
  if ( ! queueA.close( ) ) {

    /* report reason, if any     */
    printf( "ImqQueue::close ended with reason code %d\n",
            (int)queueA.reasonCode( ) );
  }

 //if ( ! queueB.close( ) ) {

    /* report reason, if any     */
 //   printf( "ImqQueue::close ended with reason code %d\n",
//            (int)queueB.reasonCode( ) );
//  }



  // Disconnect from MQM if not already connected (the
  // ImqQueueManager object handles this situation automatically)
  if ( ! mgr.disconnect( ) ) {

    /* report reason, if any     */
    printf( "ImqQueueManager::disconnect ended with reason code %ld\n",
            (long)mgr.reasonCode( ) );
  }

  // Tidy up the channel object if allocated.
  if ( pchannel ) {
    mgr.setChannelReference( );
    delete pchannel ;
  }

 // printf( "Sample IMQSPUT end\n" );
  //return( 0 );
	
 	
	
	return 1;
}


RWCString MQUtility::Get_Msg_From_SendQueue(   char *send_queue,char *queue_mgr)

{
	
   RWCString retorno_msg = "";
   ImqQueueManager mgr;             // Queue manager
   ImqQueue queue ;                 // Queue
   ImqMessage msg;                  // Data message
   ImqGetMessageOptions gmo;        // Get message options
   char buffer[ 1024] = {""};       // Message buffer
   ImqChannel * pchannel = 0 ;      // Channel definition

	
  // Create object descriptor for subject queue
  queue.setName( send_queue );
  //queue.setName( "RECVQUEUE" );
 	
  mgr.setName( queue_mgr);
   //mgr.setName( "QM_victort8100");
  
  char test_input[] = "SYSTEM.DEF.SVRCONN/TCP/127.0.0.1(1414)";

    ImqString strParse( test_input );
    ImqString strToken ;

    pchannel = new ImqChannel ;
    pchannel -> setHeartBeatInterval( 1L );

    // Break down the channel definition,
    // which is of the form "channel-name/transport-type/connection-name".
    if ( strParse.cutOut( strToken, '/' ) ) {
      pchannel -> setChannelName( strToken );

      if ( strParse.cutOut( strToken, '/' ) ) {

        // Interpret the transport type.
        if ( strToken.upperCase( ) == (ImqString)"LU62" ) {
          pchannel -> setTransportType( MQXPT_LU62 );
        }
        if ( strToken.upperCase( ) == (ImqString)"NETBIOS" ) {
          pchannel -> setTransportType( MQXPT_NETBIOS );
        }
        if ( strToken.upperCase( ) == (ImqString)"SPX" ) {
          pchannel -> setTransportType( MQXPT_SPX );
        }
        if ( strToken.upperCase( ) == (ImqString)"TCP" ) {
          pchannel -> setTransportType( MQXPT_TCP );
        }

        // Establish the connection name.
        if ( strParse.cutOut( strToken ) ) {
          pchannel -> setConnectionName( strToken );
        }
      }
    }

    mgr.setChannelReference( pchannel );
 
  // Connect to queue manager
  if ( ! mgr.connect( ) ) {

    /* stop if it failed     */
    printf( "ImqQueueManager::connect failed with reason code %ld\n",
            (long)mgr.reasonCode( ) );
    exit( (int)mgr.reasonCode( ) );
  }

  // Associate queue with queue manager.
  queue.setConnectionReference( mgr );

  // Open the named message queue for input; exclusive or shared
  // use of the queue is controlled by the queue definition here
  queue.setOpenOptions(
                   MQOO_INPUT_AS_Q_DEF /* open queue for input      */
                 + MQOO_FAIL_IF_QUIESCING
                             );        /* but not if MQM stopping   */
  queue.open( );

  /* report reason, if any; stop if failed      */
  if ( queue.reasonCode( ) ) {
    printf( "ImqQueue::open ended with reason code %ld\n",
            (long)queue.reasonCode( ) );
  }

  if ( queue.completionCode( ) == MQCC_FAILED ) {
    printf( "unable to open queue for input\n" );
  }

  // Get messages from the message queue
  // Loop until there is a failure
  msg.useEmptyBuffer( buffer, sizeof( buffer ) - 1 );
                                 /* buffer size available for GET   */
  gmo.setOptions( MQGMO_WAIT |   /* wait for new messages           */
                  MQGMO_FAIL_IF_QUIESCING );
  //gmo.setWaitInterval( 1000 );  /* 15 second limit for waiting     */
  gmo.setWaitInterval( 25000 );  /* 15 second limit for waiting     */
//  gmo.setExpiry(10000 );  /* 15 second limit for waiting     */
  while ( queue.completionCode( ) != MQCC_FAILED ) 
  {

    // In order to read the messages in sequence, MsgId and
    // CorrelID must have the default value.  MQGET sets them
    // to the values in for message it returns, so re-initialise
    // them before every call
    msg.setMessageId( );
    msg.setCorrelationId( );
	RWCString test_1 ;
	RWCString incoming_0210;
	//cout << "dentro de get_message1 > " << endl;
    if ( queue.get( msg, gmo ) ) 
	{
  
      // Display each message received
      if ( msg.formatIs( MQFMT_STRING ) ) 
	  {
    
        buffer[ msg.dataLength( ) ] = 0 ;  /* add terminator          */
        //printf( "message <%s>\n", msg.bufferPointer( ) );
		test_1 = msg.bufferPointer( ) ;
			
		if((test_1(0,4)) == "0800")
		{
			retorno_msg = test_1 ;
		}
		else
		if((test_1(0,4)) == "0200")
		{
			retorno_msg = test_1 ;
		}
		else
		if((test_1(0,4)) == "0100")
		{
				retorno_msg = test_1 ;
		}
		else
		if((test_1(0,4)) == "0420")
		{
			retorno_msg = test_1 ;
		}
		else
		if((test_1(0,4)) == "0520")
		{
			retorno_msg = test_1 ;
		}
		else
		{
			retorno_msg = test_1 ;
		}


		//cout << "Valor de retorno_msg en QUEUE > " << retorno_msg << endl;
		break;

      } 
	  else 
	  
	  {
        printf( "Non-text message\n" );
      }

    } 
//	else 
//	{
		/*
		RWCString output_no_response = "0210,000000,000000000000,000000000000,111111,222222,3333,444444444444,000000,91";
		output_no_response+="\n";
		char output_inoperative[150] = {""};
		strcpy(output_inoperative,output_no_response);
		cout << "dentro de get_message4 > " << endl;
		MQUtility test_send2;
		
		test_send2.Send_Message_0210(output_inoperative);
		break;
		*/
      /* report reason, if any     */
      if ( queue.reasonCode( ) == MQRC_NO_MSG_AVAILABLE ) 
	  {
                                /* special report for normal end    */
        //printf( "no more messages\n" );
      } 
	  else 
	  {
                                /* general report for other reasons */
        printf( "ImqQueue::get ended with reason code %ld\n",
                (long)queue.reasonCode( ) );

        /*   treat truncated message as a failure for this sample   */
        if ( queue.reasonCode( ) == MQRC_TRUNCATED_MSG_FAILED ) 
		{
          break ;
        }
      }
    //}

  }

  // Close the source queue (if it was opened)
  if ( ! queue.close( ) ) {

    /* report reason, if any     */
    printf( "ImqQueue::close failed with reason code %ld\n",
            (long)queue.reasonCode( ) );
  }

  // Disconnect from MQM if not already connected (the
  // ImqQueueManager object handles this situation automatically)
  if ( ! mgr.disconnect( ) ) {

    /* report reason, if any     */
    printf( "ImqQueueManager::disconnect failed with reason code %ld\n",
            (long)mgr.reasonCode( ) );
  }

  // Tidy up the channel object if allocated.
  if ( pchannel ) 
  {
    mgr.setChannelReference( );
    delete pchannel ;
  }
//cout << "Salida >" << endl;
return retorno_msg;

} 

RWCString MQUtility::Get_Msg_From_Queue(   char *send_queue,char *queue_mgr)

{
	
   RWCString retorno_msg = "";
   ImqQueueManager mgr;             // Queue manager
   ImqQueue queue ;                 // Queue
   ImqMessage msg;                  // Data message
   ImqGetMessageOptions gmo;        // Get message options
   char buffer[ 1024] = {""};       // Message buffer
   ImqChannel * pchannel = 0 ;      // Channel definition

	
  // Create object descriptor for subject queue
  queue.setName( send_queue );
  //queue.setName( "RECVQUEUE" );
 	
  mgr.setName( queue_mgr);
   //mgr.setName( "QM_victort8100");
  
  char test_input[] = "SYSTEM.DEF.SVRCONN/TCP/127.0.0.1(1414)";

    ImqString strParse( test_input );
    ImqString strToken ;

    pchannel = new ImqChannel ;
    pchannel -> setHeartBeatInterval( 1L );

    // Break down the channel definition,
    // which is of the form "channel-name/transport-type/connection-name".
    if ( strParse.cutOut( strToken, '/' ) ) {
      pchannel -> setChannelName( strToken );

      if ( strParse.cutOut( strToken, '/' ) ) {

        // Interpret the transport type.
        if ( strToken.upperCase( ) == (ImqString)"LU62" ) {
          pchannel -> setTransportType( MQXPT_LU62 );
        }
        if ( strToken.upperCase( ) == (ImqString)"NETBIOS" ) {
          pchannel -> setTransportType( MQXPT_NETBIOS );
        }
        if ( strToken.upperCase( ) == (ImqString)"SPX" ) {
          pchannel -> setTransportType( MQXPT_SPX );
        }
        if ( strToken.upperCase( ) == (ImqString)"TCP" ) {
          pchannel -> setTransportType( MQXPT_TCP );
        }

        // Establish the connection name.
        if ( strParse.cutOut( strToken ) ) {
          pchannel -> setConnectionName( strToken );
        }
      }
    }

    mgr.setChannelReference( pchannel );
 
  // Connect to queue manager
  if ( ! mgr.connect( ) ) {

    /* stop if it failed     */
    printf( "ImqQueueManager::connect failed with reason code %ld\n",
            (long)mgr.reasonCode( ) );
    exit( (int)mgr.reasonCode( ) );
  }

  // Associate queue with queue manager.
  queue.setConnectionReference( mgr );

  // Open the named message queue for input; exclusive or shared
  // use of the queue is controlled by the queue definition here
  queue.setOpenOptions(
                   MQOO_INPUT_AS_Q_DEF /* open queue for input      */
                 + MQOO_FAIL_IF_QUIESCING
                             );        /* but not if MQM stopping   */
  queue.open( );

  /* report reason, if any; stop if failed      */
  if ( queue.reasonCode( ) ) {
    printf( "ImqQueue::open ended with reason code %ld\n",
            (long)queue.reasonCode( ) );
  }

  if ( queue.completionCode( ) == MQCC_FAILED ) {
    printf( "unable to open queue for input\n" );
  }

  // Get messages from the message queue
  // Loop until there is a failure
  msg.useEmptyBuffer( buffer, sizeof( buffer ) - 1 );
                                 /* buffer size available for GET   */
  gmo.setOptions( MQGMO_WAIT |   /* wait for new messages           */
                  MQGMO_FAIL_IF_QUIESCING );
  //gmo.setWaitInterval( 1000 );  /* 15 second limit for waiting     */
  gmo.setWaitInterval( 13000 );  /* 15 second limit for waiting     */
//  gmo.setExpiry(10000 );  /* 15 second limit for waiting     */
  while ( queue.completionCode( ) != MQCC_FAILED ) 
  {

    // In order to read the messages in sequence, MsgId and
    // CorrelID must have the default value.  MQGET sets them
    // to the values in for message it returns, so re-initialise
    // them before every call
    msg.setMessageId( );
    msg.setCorrelationId( );
	RWCString test_1 ;
	RWCString incoming_0210;
	//cout << "dentro de get_message1 > " << endl;
    if ( queue.get( msg, gmo ) ) 
	{
  
      // Display each message received
      if ( msg.formatIs( MQFMT_STRING ) ) 
	  {
    
        buffer[ msg.dataLength( ) ] = 0 ;  /* add terminator          */
        //printf( "message <%s>\n", msg.bufferPointer( ) );
		test_1 = msg.bufferPointer( ) ;
			
		if((test_1(12,4)) == "0810")
		{
			retorno_msg = test_1 ;
		}
		if((test_1(12,4)) == "0210")
		{
			retorno_msg = test_1 ;
		}

		if((test_1(12,4)) == "0110")
		{
				retorno_msg = test_1 ;
		}
		if((test_1(12,4)) == "0430")
		{
			retorno_msg = test_1 ;
		}

		if((test_1(12,4)) == "0530")
		{
			retorno_msg = test_1 ;
		}

		if((test_1(12,4)) == "0510")
		{
			retorno_msg = test_1 ;
		}

		if((test_1(12,4)) == "0230")
		{
			retorno_msg = test_1 ;
		}

		break;

      } 
	  else 
	  
	  {
        printf( "Non-text message\n" );
      }

    } 
//	else 
//	{
		/*
		RWCString output_no_response = "0210,000000,000000000000,000000000000,111111,222222,3333,444444444444,000000,91";
		output_no_response+="\n";
		char output_inoperative[150] = {""};
		strcpy(output_inoperative,output_no_response);
		cout << "dentro de get_message4 > " << endl;
		MQUtility test_send2;
		
		test_send2.Send_Message_0210(output_inoperative);
		break;
		*/
      /* report reason, if any     */
      if ( queue.reasonCode( ) == MQRC_NO_MSG_AVAILABLE ) 
	  {
                                /* special report for normal end    */
        //printf( "no more messages\n" );
      } 
	  else 
	  {
                                /* general report for other reasons */
        printf( "ImqQueue::get ended with reason code %ld\n",
                (long)queue.reasonCode( ) );

        /*   treat truncated message as a failure for this sample   */
        if ( queue.reasonCode( ) == MQRC_TRUNCATED_MSG_FAILED ) 
		{
          break ;
        }
      }
    //}

  }

  // Close the source queue (if it was opened)
  if ( ! queue.close( ) ) {

    /* report reason, if any     */
    printf( "ImqQueue::close failed with reason code %ld\n",
            (long)queue.reasonCode( ) );
  }

  // Disconnect from MQM if not already connected (the
  // ImqQueueManager object handles this situation automatically)
  if ( ! mgr.disconnect( ) ) {

    /* report reason, if any     */
    printf( "ImqQueueManager::disconnect failed with reason code %ld\n",
            (long)mgr.reasonCode( ) );
  }

  // Tidy up the channel object if allocated.
  if ( pchannel ) 
  {
    mgr.setChannelReference( );
    delete pchannel ;
  }
//cout << "Salida >" << endl;
return retorno_msg;

} 


/*
RWCString MQUtility::Get_Msg_From_Sock( RWSocketPortal p,  char *send_queue,char *queue_mgr)

{
	
   RWCString retorno_msg = "";
 

 
	RWCString test_1 ;
	RWCString incoming_0210;
	//test_1 = msg.bufferPointer( ) ;
			
	if((test_1(11,4)) == "0800")
	{
		MQUtility test_send_0800;
		retorno_msg = test_send_0800.setIsoGeneric0800(test_1) ;
	}
	if((test_1(11,4)) == "0200")
	{
		MQUtility test_send_0200;
		retorno_msg = test_send_0200.setIsoPostermFromGeneric0200(test_1) ;
		//cout << "Valor de retorno_msg > :" << retorno_msg << endl;
	}

					

return retorno_msg;

} 


RWCString MQUtility::Send_Msg_To_Sock( RWSocketPortal p,  char *send_queue,char *queue_mgr)

{
	
   RWCString retorno_msg = "";
 

 
	RWCString test_1 ;
	RWCString incoming_0210;
	//test_1 = msg.bufferPointer( ) ;
			
	if((test_1(11,4)) == "0800")
	{
		MQUtility test_send_0800;
		retorno_msg = test_send_0800.setIsoGeneric0800(test_1) ;
	}
	if((test_1(11,4)) == "0200")
	{
		MQUtility test_send_0200;
		retorno_msg = test_send_0200.setIsoPostermFromGeneric0200(test_1) ;
		//cout << "Valor de retorno_msg > :" << retorno_msg << endl;
	}

					

return retorno_msg;

} 


*/

int MQUtility::Send_Message_0210(char *input_msg )
{
	
   //LogTrans(input_msg);
	RWCString iso_converted = input_msg;
	
	char output_0200[1024] = {""};
	RWCString outgoing_0210 = "";
	RWCString delimitador_coma = ",";
	RWCString outgoing_tcp_0200_tcp_header = "";
	

	
	if(iso_converted(0,4) != "0210")
	{
		
		
		cout << "Valor de outgoing_tcp_0200_tcp_header > " << outgoing_tcp_0200_tcp_header << endl;
		cout << "Longitud de outgoing_tcp_0200_tcp_header > " << outgoing_tcp_0200_tcp_header.length() << endl;
		



	}

	else
	{
		outgoing_0210 = iso_converted;
	}
	
		return 0;

} 

RWCString MQUtility::SetTcpHeader( RWCString incoming_tcp_header ) 

{
	

	RWCString msg_reponse_with_tcp_header = "";
	char buffer[20] = {""};
    int  i = incoming_tcp_header.length();
   
	  _itoa( i, buffer, 16 );
 
	if(incoming_tcp_header.length() > 255)
	{
		RWCString hex_input_uno = RWCString(buffer)(0,1) ;
		RWCString hex_input_dos = RWCString(buffer)(1,2) ;


		char primer_valor = RetornoHexadecimal(hex_input_uno);
		char segundo_valor = RetornoHexadecimal(hex_input_dos);
	
		msg_reponse_with_tcp_header = RWCString(primer_valor)+RWCString(segundo_valor)+incoming_tcp_header;

	}
	else
	{
		
		RWCString hex_input_uno = "00";
		RWCString hex_input_dos = RWCString(buffer)(0,2) ;
		char segundo_valor = RetornoHexadecimal(hex_input_dos);
		char primer_valor  = RetornoHexadecimal(hex_input_uno);

		
		msg_reponse_with_tcp_header = RWCString(primer_valor)+RWCString(segundo_valor)+incoming_tcp_header ;
	

	}


return msg_reponse_with_tcp_header;				

}

char MQUtility::RetornoHexadecimal(RWCString hex_input)
{
	

	if ((hex_input == "0") || (hex_input == "00"))
		return '\x0';
	if ((hex_input == "1") || (hex_input == "01"))
		return '\x01';
	if ((hex_input == "2") || (hex_input == "02"))
		return '\x02';
	if ((hex_input == "3") || (hex_input == "03"))
		return '\x03';
	if ((hex_input == "4") || (hex_input == "04"))
		return '\x04';
	if ((hex_input == "5") || (hex_input == "05"))
		return '\x05';
	if ((hex_input == "6") || (hex_input == "06"))
		return '\x06';
	if ((hex_input == "7") || (hex_input == "07"))
		return '\x07';
	if ((hex_input == "8") || (hex_input == "08"))
		return '\x08';
	if ((hex_input == "9") || (hex_input == "09"))
		return '\x09';
	if ((hex_input == "0a") || (hex_input == "a"))
		return '\x0a';
	if ((hex_input == "0b") || (hex_input == "b"))
		return '\x0b';
	if ((hex_input == "0c") || (hex_input == "c"))
		return '\x0c';
	if ((hex_input == "0d") || (hex_input == "d"))
		return '\x0d';
	if ((hex_input == "0e") || (hex_input == "e"))
		return '\x0e';
	if ((hex_input == "0f") || (hex_input == "f"))
		return '\x0f';

	if (hex_input == "10")
		return '\x10';
	if (hex_input == "11")
		return '\x11';
	if (hex_input == "12")
		return '\x12';
	if (hex_input == "13")
		return '\x13';
	if (hex_input == "14")
		return '\x14';
	if (hex_input == "15")
		return '\x15';
	if (hex_input == "16")
		return '\x16';
	if (hex_input == "17")
		return '\x17';
	if (hex_input == "18")
		return '\x18';
	if (hex_input == "19")
		return '\x19';
	if (hex_input == "1a")
		return '\x1a';
	if (hex_input == "1b")
		return '\x1b';
	if (hex_input == "1c")
		return '\x1c';
	if (hex_input == "1d")
		return '\x1d';
	if (hex_input == "1e")
		return '\x1e';
	if (hex_input == "1f")
		return '\x1f';

	if (hex_input == "20")
		return '\x20';
	if (hex_input == "21")
		return '\x21';
	if (hex_input == "22")
		return '\x22';
	if (hex_input == "23")
		return '\x23';
	if (hex_input == "24")
		return '\x24';
	if (hex_input == "25")
		return '\x25';
	if (hex_input == "26")
		return '\x26';
	if (hex_input == "27")
		return '\x27';
	if (hex_input == "28")
		return '\x28';
	if (hex_input == "29")
		return '\x29';
	if (hex_input == "2a")
		return '\x2a';
	if (hex_input == "2b")
		return '\x2b';
	if (hex_input == "2c")
		return '\x2c';
	if (hex_input == "2d")
		return '\x2d';
	if (hex_input == "2e")
		return '\x2e';
	if (hex_input == "2f")
		return '\x2f';


	if (hex_input == "30")
		return '\x30';
	if (hex_input == "31")
		return '\x31';
	if (hex_input == "32")
		return '\x32';
	if (hex_input == "33")
		return '\x33';
	if (hex_input == "34")
		return '\x34';
	if (hex_input == "35")
		return '\x35';
	if (hex_input == "36")
		return '\x36';
	if (hex_input == "37")
		return '\x37';
	if (hex_input == "38")
		return '\x38';
	if (hex_input == "39")
		return '\x39';
	if (hex_input == "3a")
		return '\x3a';
	if (hex_input == "3b")
		return '\x3b';
	if (hex_input == "3c")
		return '\x3c';
	if (hex_input == "3d")
		return '\x3d';
	if (hex_input == "3e")
		return '\x3e';
	if (hex_input == "3f")
		return '\x3f';

	if (hex_input == "40")
		return '\x40';
	if (hex_input == "41")
		return '\x41';
	if (hex_input == "42")
		return '\x42';
	if (hex_input == "43")
		return '\x43';
	if (hex_input == "44")
		return '\x44';
	if (hex_input == "45")
		return '\x45';
	if (hex_input == "46")
		return '\x46';
	if (hex_input == "47")
		return '\x47';
	if (hex_input == "48")
		return '\x48';
	if (hex_input == "49")
		return '\x49';
	if (hex_input == "4a")
		return '\x4a';
	if (hex_input == "4b")
		return '\x4b';
	if (hex_input == "4c")
		return '\x4c';
	if (hex_input == "4d")
		return '\x4d';
	if (hex_input == "4e")
		return '\x4e';
	if (hex_input == "4f")
		return '\x4f';


	if (hex_input == "50")
		return '\x50';
	if (hex_input == "51")
		return '\x51';
	if (hex_input == "52")
		return '\x52';
	if (hex_input == "53")
		return '\x53';
	if (hex_input == "54")
		return '\x54';
	if (hex_input == "55")
		return '\x55';
	if (hex_input == "56")
		return '\x56';
	if (hex_input == "57")
		return '\x57';
	if (hex_input == "58")
		return '\x58';
	if (hex_input == "59")
		return '\x59';
	if (hex_input == "5a")
		return '\x5a';
	if (hex_input == "5b")
		return '\x5b';
	if (hex_input == "5c")
		return '\x5c';
	if (hex_input == "5d")
		return '\x5d';
	if (hex_input == "5e")
		return '\x5e';
	if (hex_input == "5f")
		return '\x5f';

	if (hex_input == "60")
		return '\x60';
	if (hex_input == "61")
		return '\x61';
	if (hex_input == "62")
		return '\x62';
	if (hex_input == "63")
		return '\x63';
	if (hex_input == "64")
		return '\x64';
	if (hex_input == "65")
		return '\x65';
	if (hex_input == "66")
		return '\x66';
	if (hex_input == "67")
		return '\x67';
	if (hex_input == "68")
		return '\x68';
	if (hex_input == "69")
		return '\x69';
	if (hex_input == "6a")
		return '\x6a';
	if (hex_input == "6b")
		return '\x6b';
	if (hex_input == "6c")
		return '\x6c';
	if (hex_input == "6d")
		return '\x6d';
	if (hex_input == "6e")
		return '\x6e';
	if (hex_input == "6f")
		return '\x6f';

	if (hex_input == "70")
		return '\x70';
	if (hex_input == "71")
		return '\x71';
	if (hex_input == "72")
		return '\x72';
	if (hex_input == "73")
		return '\x73';
	if (hex_input == "74")
		return '\x74';
	if (hex_input == "75")
		return '\x75';
	if (hex_input == "76")
		return '\x76';
	if (hex_input == "77")
		return '\x77';
	if (hex_input == "78")
		return '\x78';
	if (hex_input == "79")
		return '\x79';
	if (hex_input == "7a")
		return '\x7a';
	if (hex_input == "7b")
		return '\x7b';
	if (hex_input == "7c")
		return '\x7c';
	if (hex_input == "7d")
		return '\x7d';
	if (hex_input == "7e")
		return '\x7e';
	if (hex_input == "7f")
		return '\x7f';

	
	if (hex_input == "80")
		return '\x80';
	if (hex_input == "81")
		return '\x81';
	if (hex_input == "82")
		return '\x82';
	if (hex_input == "83")
		return '\x83';
	if (hex_input == "84")
		return '\x84';
	if (hex_input == "85")
		return '\x85';
	if (hex_input == "86")
		return '\x86';
	if (hex_input == "87")
		return '\x87';
	if (hex_input == "88")
		return '\x88';
	if (hex_input == "89")
		return '\x89';
	if (hex_input == "8a")
		return '\x8a';
	if (hex_input == "8b")
		return '\x8b';
	if (hex_input == "8c")
		return '\x8c';
	if (hex_input == "8d")
		return '\x8d';
	if (hex_input == "8e")
		return '\x8e';
	if (hex_input == "8f")
		return '\x8f';

	if (hex_input == "90")
		return '\x90';
	if (hex_input == "91")
		return '\x91';
	if (hex_input == "92")
		return '\x92';
	if (hex_input == "93")
		return '\x93';
	if (hex_input == "94")
		return '\x94';
	if (hex_input == "95")
		return '\x95';
	if (hex_input == "96")
		return '\x96';
	if (hex_input == "97")
		return '\x97';
	if (hex_input == "98")
		return '\x98';
	if (hex_input == "99")
		return '\x99';
	if (hex_input == "9a")
		return '\x9a';
	if (hex_input == "9b")
		return '\x9b';
	if (hex_input == "9c")
		return '\x9c';
	if (hex_input == "9d")
		return '\x9d';
	if (hex_input == "9e")
		return '\x9e';
	if (hex_input == "9f")
		return '\x9f';

	if (hex_input == "a0")
		return '\xa0';
	if (hex_input == "a1")
		return '\xa1';
	if (hex_input == "a2")
		return '\xa2';
	if (hex_input == "a3")
		return '\xa3';
	if (hex_input == "a4")
		return '\xa4';
	if (hex_input == "a5")
		return '\xa5';
	if (hex_input == "a6")
		return '\xa6';
	if (hex_input == "a7")
		return '\xa7';
	if (hex_input == "a8")
		return '\xa8';
	if (hex_input == "a9")
		return '\xa9';
	if (hex_input == "aa")
		return '\xaa';
	if (hex_input == "ab")
		return '\xab';
	if (hex_input == "ac")
		return '\xac';
	if (hex_input == "ad")
		return '\xad';
	if (hex_input == "ae")
		return '\xae';
	if (hex_input == "af")
		return '\xaf';

	if (hex_input == "b0")
		return '\xb0';
	if (hex_input == "b1")
		return '\xb1';
	if (hex_input == "b2")
		return '\xb2';
	if (hex_input == "b3")
		return '\xb3';
	if (hex_input == "b4")
		return '\xb4';
	if (hex_input == "b5")
		return '\xb5';
	if (hex_input == "b6")
		return '\xb6';
	if (hex_input == "b7")
		return '\xb7';
	if (hex_input == "b8")
		return '\xb8';
	if (hex_input == "b9")
		return '\xb9';
	if (hex_input == "ba")
		return '\xba';
	if (hex_input == "bb")
        return '\xbb';
	if (hex_input == "bc")
		return '\xbc';
	if (hex_input == "bd")
		return '\xbd';
	if (hex_input == "be")
		return '\xbe';
	if (hex_input == "bf")
		return '\xbf';


	if (hex_input == "c0")
		return '\xc0';
	if (hex_input == "c1")
		return '\xc1';
	if (hex_input == "c2")
		return '\xc2';
	if (hex_input == "c3")
		return '\xc3';
	if (hex_input == "c4")
		return '\xc4';
	if (hex_input == "c5")
		return '\xc5';
	if (hex_input == "c6")
		return '\xc6';
	if (hex_input == "c7")
		return '\xc7';
	if (hex_input == "c8")
		return '\xc8';
	if (hex_input == "c9")
		return '\xc9';
	if (hex_input == "ca")
		return '\xca';
	if (hex_input == "cb")
		return '\xcb';
	if (hex_input == "cc")
		return '\xcc';
	if (hex_input == "cd")
		return '\xcd';
	if (hex_input == "ce")
		return '\xce';
	if (hex_input == "cf")
		return '\xcf';

	if (hex_input == "d0")
		return '\xd0';
	if (hex_input == "d1")
		return '\xd1';
	if (hex_input == "d2")
		return '\xd2';
	if (hex_input == "d3")
		return '\xd3';
	if (hex_input == "d4")
		return '\xd4';
	if (hex_input == "d5")
		return '\xd5';
	if (hex_input == "d6")
		return '\xd6';
	if (hex_input == "d7")
		return '\xd7';
	if (hex_input == "d8")
		return '\xd8';
	if (hex_input == "d9")
		return '\xd9';
	if (hex_input == "da")
		return '\xda';
	if (hex_input == "db")
		return '\xdb';
	if (hex_input == "dc")
		return '\xdc';
	if (hex_input == "dd")
		return '\xdd';
	if (hex_input == "de")
		return '\xde';
	if (hex_input == "df")
		return '\xdf';


	if (hex_input == "e0")
		return '\xe0';
	if (hex_input == "e1")
		return '\xe1';
	if (hex_input == "e2")
		return '\xe2';
	if (hex_input == "e3")
		return '\xe3';
	if (hex_input == "e4")
		return '\xe4';
	if (hex_input == "e5")
		return '\xe5';
	if (hex_input == "e6")
		return '\xe6';
	if (hex_input == "e7")
		return '\xe7';
	if (hex_input == "e8")
		return '\xe8';
	if (hex_input == "e9")
		return '\xe9';
	if (hex_input == "ea")
		return '\xea';
	if (hex_input == "eb")
		return '\xeb';
	if (hex_input == "ec")
		return '\xec';
	if (hex_input == "ed")
		return '\xed';
	if (hex_input == "ee")
		return '\xee';
	if (hex_input == "ef")
		return '\xef';

	if (hex_input == "f0")
		return '\xf0';
	if (hex_input == "f1")
		return '\xf1';
	if (hex_input == "f2")
		return '\xf2';
	if (hex_input == "f3")
		return '\xf3';
	if (hex_input == "f4")
		return '\xf4';
	if (hex_input == "f5")
		return '\xf5';
	if (hex_input == "f6")
		return '\xf6';
	if (hex_input == "f7")
		return '\xf7';
	if (hex_input == "f8")
		return '\xf8';
	if (hex_input == "f9")
		return '\xf9';
	if (hex_input == "fa")
		return '\xfa';
	if (hex_input == "fb")
		return '\xfb';
	if (hex_input == "fc")
		return '\xfc';
	if (hex_input == "fd")
		return '\xfd';
	if (hex_input == "fe")
		return '\xfe';
	if (hex_input == "ff")
		return '\xff';

	return 'n';
}


RWCString MQUtility::Retorno_Msg_Generic_PostermB24(RWCString incoming , char *msg_type, 
											          int debug, RWCString application)
{


	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing(next_field,var_field);
				response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					
					
					if(j+1 == 53)
					{
						msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						if(debug == 1)

							ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
						response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
						response_0210_generic_from_iso +=delimiter;
					}
					else
					{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						response_0210_generic_from_iso +=field_length.RetornoPreZeroes(j+1)+msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						response_0210_generic_from_iso +=delimiter;
					}
				}
			
			}
		}
		
	}


	return response_0210_generic_from_iso;

}

RWCString MQUtility::Retorno_210_B24(RWCString incoming , char *msg_type,int debug)
{
	int next_field_last = 0;		
	RWCString hex_bit = incoming(18,32);
	bit_map_first_part = incoming(18,16);
	bit_map_second_part = incoming(34,16);
	RWCString delimiter = ",";
	RWCString msg_type_0200 = "0200";
	response_0210_generic_from_iso +="0210";
	response_0210_generic_from_iso +=delimiter;
	RWCString test_bit_map = "";
	RWCString test_bit_map_2 = "";
	test_bit_map = incoming(18,16);
	test_bit_map_2 = incoming(34,16);
		
	if((strncmp(msg_type, "0210", 4) == 0))
	{
		if(hex_bit(0,1) == "B")// bit 1,2,3,4
		{
			processing_code_03					= incoming(50,6);   //03   
			next_field_last					= 56;
			transaction_amount_04				= incoming(next_field_last,12);	//04
			next_field_last					= next_field_last+12;
			response_0210_generic_from_iso +="00003"+processing_code_03;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00004"+transaction_amount_04;
			response_0210_generic_from_iso +=delimiter;

		}
	
		if(hex_bit(1,1) == "2")// bit 5,6,7,8
		{
			transmition_date_time_07			= incoming(next_field_last,10);	//07     		
			next_field_last					= next_field_last+10;
			response_0210_generic_from_iso +="00007"+transmition_date_time_07;
			response_0210_generic_from_iso +=delimiter;
			
		}

		if(hex_bit(2,1) == "3")// bit 9,10,11,12
		{
			system_trace_011					= incoming(next_field_last,6);	//011     		
			time_local_transaction_012			= incoming((next_field_last+6),6);	//012     		
			next_field_last						= next_field_last+6+6;
			response_0210_generic_from_iso +="00011"+system_trace_011;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00012"+time_local_transaction_012;
			response_0210_generic_from_iso +=delimiter;
		}
	
		if(hex_bit(2,1) == "7")// bit 9,10,11,12
		{
			convertion_rate_010					= incoming(next_field_last,8);		//010
			system_trace_011					= incoming((next_field_last,8),6);	//011     		
			time_local_transaction_012			= incoming((next_field_last+8+6),6);//012     		
			next_field_last						= next_field_last+8+6+6;
			response_0210_generic_from_iso +="00011"+system_trace_011;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00012"+time_local_transaction_012;
			response_0210_generic_from_iso +=delimiter;

		}
	

		if(hex_bit(3,1) == "E")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			expiration_date_014					= incoming((next_field_last+4),4);	//014 
			date_settlement_015					= incoming((next_field_last+4+4),4);	//015 
			next_field_last						= next_field_last+4+4+4;
			
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;
		
		}
		

		if(hex_bit(3,1) == "8")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			next_field_last						= next_field_last+4;
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;

		}
	
		if(hex_bit(3,1) == "C")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			expiration_date_014					= incoming((next_field_last+4),4);	//014 
			next_field_last						= next_field_last+4+4;	
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;


		
		}

		if(hex_bit(4,1) == "8")// bit 17,18,19,20
		{
			capture_date_017					= incoming(next_field_last,4);	//017 
			next_field_last						= next_field_last+4;

		
		}

		if(hex_bit(4,1) == "C")// bit 17,18,19,20
		{
			capture_date_017					= incoming(next_field_last,4);	//017 
			merchant_type_018					= incoming((next_field_last+4),4);
			next_field_last						= next_field_last+4+4;


		}


		if(hex_bit(5,1) == "4")// bit 21,22,23,24
		{
			pos_entry_mode_022					= incoming(next_field_last,3);	//022 
			next_field_last						= next_field_last+3;

		}
	
		if(hex_bit(5,1) == "5")// bit 21,22,23,24
		{
			pos_entry_mode_022					= incoming(next_field_last,3);	//022 
			for_athd_024						= incoming((next_field_last+3),3);	//024 
			next_field_last						= next_field_last+3+3;

		}
	

		if(hex_bit(6,1) == "8")// bit 25,26,27,28
		{
			pos_condition_code_025				= incoming(next_field_last,2);	//025 
			next_field_last					= next_field_last+2;
				
		}
	

		int field32 = 0;
		if(hex_bit(7,1) == "1")// bit 29,30,31,32
		{
			llvar		= incoming(next_field_last,2);	//032 
			field32 = atoi(llvar);
			acquiring_institution_id_code_032		 = incoming((next_field_last+2),field32);	//032 
			next_field_last							 = next_field_last+2+field32;

		}
	
		int field35 = 0;
		if(hex_bit(8,1) == "2")// bit 33,34,35,36
		{
			llvar								= incoming(next_field_last,2);	//035 
			field35 = atoi(llvar);
			track_2_035 = incoming((next_field_last+2),field35);
			next_field_last = next_field_last+2+field35;

		}

		
		if(hex_bit(9,1) == "A")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			responde_code_039			   = incoming((next_field_last+12),2);
			next_field_last				   = next_field_last+12+2;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00039"+responde_code_039;
			response_0210_generic_from_iso +=delimiter;
	
		
	
		}


		if(hex_bit(9,1) == "8")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			next_field_last				   = next_field_last+12;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
		
	
		}
		if(hex_bit(9,1) == "E")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			responde_id_response_038       = incoming((next_field_last+12),6);
			responde_code_039			   = incoming((next_field_last+12+6),2);
			next_field_last				   = next_field_last+12+6+2;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00038"+responde_id_response_038;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00039"+responde_code_039;
			response_0210_generic_from_iso +=delimiter;

		}
	
		int next_field_043 = 0;
		if(hex_bit(10,1) == "E")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			card_acceptor_id_code_042		= incoming((next_field_last+16),15);
			card_acceptor_name_location_043	= incoming((next_field_last+16+15),40);
			next_field_last					= next_field_last+16+15+40;
		
		}
			

		if(hex_bit(10,1) == "C")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			card_acceptor_id_code_042		= incoming((next_field_last+16),15);
			next_field_last					= next_field_last+16+15;
			
		}

		if(hex_bit(10,1) == "8")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			next_field_last					= next_field_last+16;
		}


		int field45= 0;
		int field48 = 0;
		
		int next_field_048 = 0;
		
		if(hex_bit(11,1) == "1")// bit 45,46,47,48
		{
		
			lllvar							= incoming(next_field_last,3);
			field48							= atoi(lllvar);
			addditional_data_048			= incoming((next_field_last+3),field48);
			next_field_last					= next_field_last+3+field48;
			

		}
	
		if(hex_bit(11,1) == "9")// bit 45,46,47,48
		{
		
			llvar							= incoming(next_field_last,2);
			field45							= atoi(llvar);
			track_1_045						= incoming((next_field_last+2),field45);
			next_field_last					= next_field_last+2+field45;
			
			lllvar							= incoming(next_field_last,3);
			field48							= atoi(lllvar);
			addditional_data_048			= incoming((next_field_last+3),field48);
			next_field_last					= next_field_last+3+field48;
			

		}
	
		int next_field_052 = 0;
	
		if(hex_bit(12,1) == "8")// bit 49,50,51,52
		{
		
			currency_code_transaction_049	= incoming(next_field_last,3);
			next_field_last					= next_field_last+3;
	
		}
		if(hex_bit(12,1) == "9")// bit 49,50,51,52
		{
		
			currency_code_transaction_049	= incoming(next_field_last,3);
			pin_data_052					= incoming((next_field_last+3),16);
			next_field_last					= next_field_last+3+16;
	
		}
	
		if(hex_bit(13,1) == "0")// bit 53,54,55,56
		{
		
	
		}
		if(hex_bit(13,1) == "4")// bit 53,54,55,56
		{

		}
	
		int field60 = 0;
		int next_field_060 = 0;
		if(hex_bit(14,1) == "1")// bit 57,58,59,60
		{
		
			lllvar							= incoming(next_field_last,3);
			field60							= atoi(lllvar);
			pos_terminal_data_060				= incoming((next_field_last+3),field60);
			next_field_last					= next_field_last+3+field60;
		}
		
		int field61 = 0;
		int field63 = 0;
		if(hex_bit(15,1) == "A")// bit 61,62,63,64
		{
		
			lllvar							= incoming(next_field_last,3);
			field61							= atoi(lllvar);
			card_issuer_response_data_061	= incoming((next_field_last+3),field61);
		
			lllvar							= incoming((next_field_last+3+field61),3);
			field63							= atoi(lllvar);
			additional_data_063				= incoming((next_field_last+3+field61+3),field63);

			response_0210_generic_from_iso +="00063"+additional_data_063;
			response_0210_generic_from_iso +=delimiter;


			next_field_last					= next_field_last+3+field61+3+field63;
	
		}
		
		
		if(hex_bit(15,1) == "8")// bit 61,62,63,64
		{
		
			lllvar							= incoming(next_field_last,3);
			field61							= atoi(lllvar);
			card_issuer_response_data_061	= incoming((next_field_last+3),field61);
			next_field_last					= next_field_last+3+field61;	

			
		}		
	
		if(hex_bit(16,1) == "0")// bit 65,66,67,68
		{
		
			
	
		}
		if(hex_bit(17,1) == "0")// bit 69,70,71,72
		{
		
			
	
		}
		if(hex_bit(18,1) == "0")// bit 73,74,75,76
		{
		
			
	
		}
		
		if(hex_bit(19,1) == "0")// bit 77,78,79,80
		{
		
			

		}
		
		if(hex_bit(20,1) == "0")// bit 81,82,83,84
		{
		
			
	
		}
		
		if(hex_bit(21,1) == "0")// bit 85,86,87,88
		{
		
			
	
		}
		
		if(hex_bit(22,1) == "0")// bit 89,90,91,92
		{
		
			
	
		}
		
		if(hex_bit(23,1) == "0")// bit 93,94,95,96
		{
		
			

		}
		int field100 = 0;
		if(hex_bit(24,1) == "1")// bit 97,98,99,100
		{
		
			llvar = incoming(next_field_last,2);
			field100 = atoi(llvar);
			receiving_institution_id_code_0100 = incoming((next_field_last+2),field100);
			
			next_field_last = next_field_last+2+field100;
	
		}

		if(hex_bit(25,1) == "0")// bit 101,102,103,104
		{
		
	
		}

		if(hex_bit(26,1) == "0")// bit 105,106,107,108
		{
		
			
	
		}
		
		if(hex_bit(27,1) == "0")// bit 109,110,111,112
		{
		
			
	
		}
		
		if(hex_bit(28,1) == "0")// bit 113,114,115,116
		{
		
	
		}
		
		if(hex_bit(29,1) == "0")// bit 117,118,119,120
		{
		
			
	
		
		}
		int field120 = 0;
		if(hex_bit(29,1) == "1")// bit 117,118,119,120
		{
		
			lllvar = incoming(next_field_last,3);
			field120 = atoi(lllvar);
			pos_terminal_address_branch_120	= incoming((next_field_last+3),field120);
			next_field_last					= next_field_last+3+field120;
				
		}
		
		int field121 = 0;
		int field123 = 0;
		int field124 = 0;
		if(hex_bit(30,1) == "9")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field121						= atoi(lllvar);
			authorization_indicators_0121	= incoming((next_field_last+3),field121);
			
			lllvar							= incoming((next_field_last+3+field121),3);
			field124						= atoi(lllvar);
			batch_record2_0124				= incoming((next_field_last+3+field121+3),field124);
			next_field_last					= next_field_last+3+field121+3+field124;
	
		
		}
		if(hex_bit(30,1) == "1")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field124						= atoi(lllvar);
			batch_record2_0124				= incoming((next_field_last+3),field124);
			next_field_last					= next_field_last+3+field124;
			
	
		
		}

		if(hex_bit(30,1) == "2")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field123						= atoi(lllvar);
			pos_invoice_data_0123			= incoming((next_field_last+3),field123);
			next_field_last					= next_field_last+3+field123;
			
			
		
		
		}
		int field125 = 0;
		int field126 = 0;
		
		if(hex_bit(31,1) == "C")// bit 125,126,127,128
		{
			
			lllvar							= incoming(next_field_last,3);
			field125						= atoi(lllvar);
			pos_settlement_data_125			= incoming((next_field_last+3),field125);
			
			lllvar							= incoming((next_field_last+3+field125),3);
			field126						= atoi(lllvar);
			preauthorization_data_0126		= incoming((next_field_last+3+field125+3),field126);
			next_field_last					= next_field_last+3+field125+3+field126;
			
	
		
		}
		if(hex_bit(31,1) == "4")// bit 125,126,127,128
		{
			
			
			lllvar							= incoming(next_field_last,3);
			field126						= atoi(lllvar);
			preauthorization_data_0126		= incoming((next_field_last+3),field126);
			next_field_last					= next_field_last+3+field126;
			
	
		
		}
		if(hex_bit(31,1) == "0")// bit 125,126,127,128
		{
			
			
	
		
		}
		if(hex_bit(31,1) == "8")// bit 125,126,127,128
		{
			
			lllvar							= incoming(next_field_last,3);
			field125						= atoi(lllvar);
			pos_settlement_data_125		    = incoming((next_field_last+3),field125);
			next_field_last					= next_field_last+3+field125;
	
		}


	}
	

	return response_0210_generic_from_iso;

}

RWCString MQUtility::Retorno_210_B24_1C(RWCString incoming , char *msg_type,int debug)
{
	int next_field_last = 0;		
	RWCString hex_bit = incoming(18,32);
	bit_map_first_part = incoming(18,16);
	bit_map_second_part = incoming(34,16);
	RWCString delimiter = '\x1C';
	RWCString msg_type_0200 = "0200";
	response_0210_generic_from_iso +="0210";
	response_0210_generic_from_iso +=delimiter;
	RWCString test_bit_map = "";
	RWCString test_bit_map_2 = "";
	test_bit_map = incoming(18,16);
	test_bit_map_2 = incoming(34,16);
		
	if((strncmp(msg_type, "0210", 4) == 0))
	{
		if(hex_bit(0,1) == "B")// bit 1,2,3,4
		{
			processing_code_03					= incoming(50,6);   //03   
			next_field_last					= 56;
			transaction_amount_04				= incoming(next_field_last,12);	//04
			next_field_last					= next_field_last+12;
			response_0210_generic_from_iso +="00003"+processing_code_03;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00004"+transaction_amount_04;
			response_0210_generic_from_iso +=delimiter;

		}
	
		if(hex_bit(1,1) == "2")// bit 5,6,7,8
		{
			transmition_date_time_07			= incoming(next_field_last,10);	//07     		
			next_field_last					= next_field_last+10;
			response_0210_generic_from_iso +="00007"+transmition_date_time_07;
			response_0210_generic_from_iso +=delimiter;
			
		}

		if(hex_bit(2,1) == "3")// bit 9,10,11,12
		{
			system_trace_011					= incoming(next_field_last,6);	//011     		
			time_local_transaction_012			= incoming((next_field_last+6),6);	//012     		
			next_field_last						= next_field_last+6+6;
			response_0210_generic_from_iso +="00011"+system_trace_011;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00012"+time_local_transaction_012;
			response_0210_generic_from_iso +=delimiter;
		}
	
		if(hex_bit(2,1) == "7")// bit 9,10,11,12
		{
			convertion_rate_010					= incoming(next_field_last,8);		//010
			system_trace_011					= incoming((next_field_last,8),6);	//011     		
			time_local_transaction_012			= incoming((next_field_last+8+6),6);//012     		
			next_field_last						= next_field_last+8+6+6;
			response_0210_generic_from_iso +="00011"+system_trace_011;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00012"+time_local_transaction_012;
			response_0210_generic_from_iso +=delimiter;

		}
	

		if(hex_bit(3,1) == "E")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			expiration_date_014					= incoming((next_field_last+4),4);	//014 
			date_settlement_015					= incoming((next_field_last+4+4),4);	//015 
			next_field_last						= next_field_last+4+4+4;
			
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;
		
		}
		

		if(hex_bit(3,1) == "8")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			next_field_last						= next_field_last+4;
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;

		}
	
		if(hex_bit(3,1) == "C")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			expiration_date_014					= incoming((next_field_last+4),4);	//014 
			next_field_last						= next_field_last+4+4;	
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;


		
		}

		if(hex_bit(4,1) == "8")// bit 17,18,19,20
		{
			capture_date_017					= incoming(next_field_last,4);	//017 
			next_field_last						= next_field_last+4;

		
		}

		if(hex_bit(4,1) == "C")// bit 17,18,19,20
		{
			capture_date_017					= incoming(next_field_last,4);	//017 
			merchant_type_018					= incoming((next_field_last+4),4);
			next_field_last						= next_field_last+4+4;


		}


		if(hex_bit(5,1) == "4")// bit 21,22,23,24
		{
			pos_entry_mode_022					= incoming(next_field_last,3);	//022 
			next_field_last						= next_field_last+3;

		}
	
		if(hex_bit(5,1) == "5")// bit 21,22,23,24
		{
			pos_entry_mode_022					= incoming(next_field_last,3);	//022 
			for_athd_024						= incoming((next_field_last+3),3);	//024 
			next_field_last						= next_field_last+3+3;

		}
	

		if(hex_bit(6,1) == "8")// bit 25,26,27,28
		{
			pos_condition_code_025				= incoming(next_field_last,2);	//025 
			next_field_last					= next_field_last+2;
				
		}
	

		int field32 = 0;
		if(hex_bit(7,1) == "1")// bit 29,30,31,32
		{
			llvar		= incoming(next_field_last,2);	//032 
			field32 = atoi(llvar);
			acquiring_institution_id_code_032		 = incoming((next_field_last+2),field32);	//032 
			next_field_last							 = next_field_last+2+field32;

		}
	
		int field35 = 0;
		if(hex_bit(8,1) == "2")// bit 33,34,35,36
		{
			llvar								= incoming(next_field_last,2);	//035 
			field35 = atoi(llvar);
			track_2_035 = incoming((next_field_last+2),field35);
			next_field_last = next_field_last+2+field35;

		}

		
		if(hex_bit(9,1) == "A")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			responde_code_039			   = incoming((next_field_last+12),2);
			next_field_last				   = next_field_last+12+2;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00039"+responde_code_039;
			response_0210_generic_from_iso +=delimiter;
	
		
	
		}


		if(hex_bit(9,1) == "8")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			next_field_last				   = next_field_last+12;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
		
	
		}
		if(hex_bit(9,1) == "E")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			responde_id_response_038       = incoming((next_field_last+12),6);
			responde_code_039			   = incoming((next_field_last+12+6),2);
			next_field_last				   = next_field_last+12+6+2;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00038"+responde_id_response_038;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00039"+responde_code_039;
			response_0210_generic_from_iso +=delimiter;

		}
	
		int next_field_043 = 0;
		if(hex_bit(10,1) == "E")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			card_acceptor_id_code_042		= incoming((next_field_last+16),15);
			card_acceptor_name_location_043	= incoming((next_field_last+16+15),40);
			next_field_last					= next_field_last+16+15+40;
		
		}
			

		if(hex_bit(10,1) == "C")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			card_acceptor_id_code_042		= incoming((next_field_last+16),15);
			next_field_last					= next_field_last+16+15;
			
		}

		if(hex_bit(10,1) == "8")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			next_field_last					= next_field_last+16;
		}


		int field45= 0;
		int field48 = 0;
		
		int next_field_048 = 0;
		
		if(hex_bit(11,1) == "1")// bit 45,46,47,48
		{
		
			lllvar							= incoming(next_field_last,3);
			field48							= atoi(lllvar);
			addditional_data_048			= incoming((next_field_last+3),field48);
			next_field_last					= next_field_last+3+field48;
			

		}
	
		if(hex_bit(11,1) == "9")// bit 45,46,47,48
		{
		
			llvar							= incoming(next_field_last,2);
			field45							= atoi(llvar);
			track_1_045						= incoming((next_field_last+2),field45);
			next_field_last					= next_field_last+2+field45;
			
			lllvar							= incoming(next_field_last,3);
			field48							= atoi(lllvar);
			addditional_data_048			= incoming((next_field_last+3),field48);
			next_field_last					= next_field_last+3+field48;
			

		}
	
		int next_field_052 = 0;
	
		if(hex_bit(12,1) == "8")// bit 49,50,51,52
		{
		
			currency_code_transaction_049	= incoming(next_field_last,3);
			next_field_last					= next_field_last+3;
	
		}
		if(hex_bit(12,1) == "9")// bit 49,50,51,52
		{
		
			currency_code_transaction_049	= incoming(next_field_last,3);
			pin_data_052					= incoming((next_field_last+3),16);
			next_field_last					= next_field_last+3+16;
	
		}
	
		if(hex_bit(13,1) == "0")// bit 53,54,55,56
		{
		
	
		}
		if(hex_bit(13,1) == "4")// bit 53,54,55,56
		{

		}
	
		int field60 = 0;
		int next_field_060 = 0;
		if(hex_bit(14,1) == "1")// bit 57,58,59,60
		{
		
			lllvar							= incoming(next_field_last,3);
			field60							= atoi(lllvar);
			pos_terminal_data_060				= incoming((next_field_last+3),field60);
			next_field_last					= next_field_last+3+field60;
		}
		
		int field61 = 0;
		int field63 = 0;
		if(hex_bit(15,1) == "A")// bit 61,62,63,64
		{
		
			lllvar							= incoming(next_field_last,3);
			field61							= atoi(lllvar);
			card_issuer_response_data_061	= incoming((next_field_last+3),field61);
		
			lllvar							= incoming((next_field_last+3+field61),3);
			field63							= atoi(lllvar);
			additional_data_063				= incoming((next_field_last+3+field61+3),field63);

			response_0210_generic_from_iso +="00063"+additional_data_063;
			response_0210_generic_from_iso +=delimiter;


			next_field_last					= next_field_last+3+field61+3+field63;
	
		}
		
		
		if(hex_bit(15,1) == "8")// bit 61,62,63,64
		{
		
			lllvar							= incoming(next_field_last,3);
			field61							= atoi(lllvar);
			card_issuer_response_data_061	= incoming((next_field_last+3),field61);
			next_field_last					= next_field_last+3+field61;	

			
		}		
	
		if(hex_bit(16,1) == "0")// bit 65,66,67,68
		{
		
			
	
		}
		if(hex_bit(17,1) == "0")// bit 69,70,71,72
		{
		
			
	
		}
		if(hex_bit(18,1) == "0")// bit 73,74,75,76
		{
		
			
	
		}
		
		if(hex_bit(19,1) == "0")// bit 77,78,79,80
		{
		
			

		}
		
		if(hex_bit(20,1) == "0")// bit 81,82,83,84
		{
		
			
	
		}
		
		if(hex_bit(21,1) == "0")// bit 85,86,87,88
		{
		
			
	
		}
		
		if(hex_bit(22,1) == "0")// bit 89,90,91,92
		{
		
			
	
		}
		
		if(hex_bit(23,1) == "0")// bit 93,94,95,96
		{
		
			

		}
		int field100 = 0;
		if(hex_bit(24,1) == "1")// bit 97,98,99,100
		{
		
			llvar = incoming(next_field_last,2);
			field100 = atoi(llvar);
			receiving_institution_id_code_0100 = incoming((next_field_last+2),field100);
			
			next_field_last = next_field_last+2+field100;
	
		}

		if(hex_bit(25,1) == "0")// bit 101,102,103,104
		{
		
	
		}

		if(hex_bit(26,1) == "0")// bit 105,106,107,108
		{
		
			
	
		}
		
		if(hex_bit(27,1) == "0")// bit 109,110,111,112
		{
		
			
	
		}
		
		if(hex_bit(28,1) == "0")// bit 113,114,115,116
		{
		
	
		}
		
		if(hex_bit(29,1) == "0")// bit 117,118,119,120
		{
		
			
	
		
		}
		int field120 = 0;
		if(hex_bit(29,1) == "1")// bit 117,118,119,120
		{
		
			lllvar = incoming(next_field_last,3);
			field120 = atoi(lllvar);
			pos_terminal_address_branch_120	= incoming((next_field_last+3),field120);
			next_field_last					= next_field_last+3+field120;
				
		}
		
		int field121 = 0;
		int field123 = 0;
		int field124 = 0;
		if(hex_bit(30,1) == "9")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field121						= atoi(lllvar);
			authorization_indicators_0121	= incoming((next_field_last+3),field121);
			
			lllvar							= incoming((next_field_last+3+field121),3);
			field124						= atoi(lllvar);
			batch_record2_0124				= incoming((next_field_last+3+field121+3),field124);
			next_field_last					= next_field_last+3+field121+3+field124;
	
		
		}
		if(hex_bit(30,1) == "1")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field124						= atoi(lllvar);
			batch_record2_0124				= incoming((next_field_last+3),field124);
			next_field_last					= next_field_last+3+field124;
			
	
		
		}

		if(hex_bit(30,1) == "2")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field123						= atoi(lllvar);
			pos_invoice_data_0123			= incoming((next_field_last+3),field123);
			next_field_last					= next_field_last+3+field123;
			
			
		
		
		}
		int field125 = 0;
		int field126 = 0;
		
		if(hex_bit(31,1) == "C")// bit 125,126,127,128
		{
			
			lllvar							= incoming(next_field_last,3);
			field125						= atoi(lllvar);
			pos_settlement_data_125			= incoming((next_field_last+3),field125);
			
			lllvar							= incoming((next_field_last+3+field125),3);
			field126						= atoi(lllvar);
			preauthorization_data_0126		= incoming((next_field_last+3+field125+3),field126);
			next_field_last					= next_field_last+3+field125+3+field126;
			
	
		
		}
		if(hex_bit(31,1) == "4")// bit 125,126,127,128
		{
			
			
			lllvar							= incoming(next_field_last,3);
			field126						= atoi(lllvar);
			preauthorization_data_0126		= incoming((next_field_last+3),field126);
			next_field_last					= next_field_last+3+field126;
			
	
		
		}
		if(hex_bit(31,1) == "0")// bit 125,126,127,128
		{
			
			
	
		
		}
		if(hex_bit(31,1) == "8")// bit 125,126,127,128
		{
			
			lllvar							= incoming(next_field_last,3);
			field125						= atoi(lllvar);
			pos_settlement_data_125		    = incoming((next_field_last+3),field125);
			next_field_last					= next_field_last+3+field125;
	
		}


	}
	

	return response_0210_generic_from_iso;

}

RWCString MQUtility::Retorno_210_B24_ATH(RWCString incoming , char *msg_type,int debug)
{
	int next_field_last = 0;		
	RWCString hex_bit = incoming(18,32);
	bit_map_first_part = incoming(18,16);
	bit_map_second_part = incoming(34,16);
	RWCString delimiter = ",";
	RWCString msg_type_0200 = "0200";
	response_0210_generic_from_iso +="0210";
	response_0210_generic_from_iso +=delimiter;
	RWCString test_bit_map = "";
	RWCString test_bit_map_2 = "";
	test_bit_map = incoming(18,16);
	test_bit_map_2 = incoming(34,16);
		
	if((strncmp(msg_type, "0210", 4) == 0))
	{
		if(hex_bit(0,1) == "B")// bit 1,2,3,4
		{
			processing_code_03					= incoming(50,6);   //03   
			next_field_last					= 56;
			transaction_amount_04				= incoming(next_field_last,12);	//04
			next_field_last					= next_field_last+12;
			response_0210_generic_from_iso +="00003"+processing_code_03;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00004"+transaction_amount_04;
			response_0210_generic_from_iso +=delimiter;

		}
	
		if(hex_bit(1,1) == "2")// bit 5,6,7,8
		{
			transmition_date_time_07			= incoming(next_field_last,10);	//07     		
			next_field_last					= next_field_last+10;
			response_0210_generic_from_iso +="00007"+transmition_date_time_07;
			response_0210_generic_from_iso +=delimiter;
			
		}

		if(hex_bit(2,1) == "3")// bit 9,10,11,12
		{
			system_trace_011					= incoming(next_field_last,6);	//011     		
			time_local_transaction_012			= incoming((next_field_last+6),6);	//012     		
			next_field_last						= next_field_last+6+6;
			response_0210_generic_from_iso +="00011"+system_trace_011;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00012"+time_local_transaction_012;
			response_0210_generic_from_iso +=delimiter;
		}
	
		if(hex_bit(2,1) == "7")// bit 9,10,11,12
		{
			convertion_rate_010					= incoming(next_field_last,8);		//010
			system_trace_011					= incoming((next_field_last,8),6);	//011     		
			time_local_transaction_012			= incoming((next_field_last+8+6),6);//012     		
			next_field_last						= next_field_last+8+6+6;
			response_0210_generic_from_iso +="00011"+system_trace_011;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00012"+time_local_transaction_012;
			response_0210_generic_from_iso +=delimiter;

		}
	

		if(hex_bit(3,1) == "E")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;
		
			
			expiration_date_014					= incoming((next_field_last+4),4);	//014 
			response_0210_generic_from_iso +="00014"+expiration_date_014;
			response_0210_generic_from_iso +=delimiter;
		
			date_settlement_015					= incoming((next_field_last+4+4),4);	//015 
		
			response_0210_generic_from_iso +="00015"+date_settlement_015;
			response_0210_generic_from_iso +=delimiter;
		
			
			next_field_last						= next_field_last+4+4+4;
			
		
		}
		

		if(hex_bit(3,1) == "8")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			next_field_last						= next_field_last+4;
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;
		
		}
	
		if(hex_bit(3,1) == "C")// bit 13,14,15,16
		{
			date_local_transaction_013			= incoming(next_field_last,4);	//013 
			expiration_date_014					= incoming((next_field_last+4),4);	//014 
			next_field_last						= next_field_last+4+4;	
			response_0210_generic_from_iso +="00013"+date_local_transaction_013;
			response_0210_generic_from_iso +=delimiter;

			response_0210_generic_from_iso +="00014"+expiration_date_014;
			response_0210_generic_from_iso +=delimiter;
		
		
		}

		if(hex_bit(4,1) == "8")// bit 17,18,19,20
		{
			capture_date_017					= incoming(next_field_last,4);	//017 
			next_field_last						= next_field_last+4;

			response_0210_generic_from_iso +="00017"+capture_date_017;
			response_0210_generic_from_iso +=delimiter;
		
		}

		if(hex_bit(4,1) == "C")// bit 17,18,19,20
		{
			capture_date_017					= incoming(next_field_last,4);	//017 
			merchant_type_018					= incoming((next_field_last+4),4);
			next_field_last						= next_field_last+4+4;
			response_0210_generic_from_iso +="00017"+capture_date_017;
			response_0210_generic_from_iso +=delimiter;


		}


		if(hex_bit(5,1) == "4")// bit 21,22,23,24
		{
			pos_entry_mode_022					= incoming(next_field_last,3);	//022 
			next_field_last						= next_field_last+3;
			response_0210_generic_from_iso +="00022"+pos_entry_mode_022;
			response_0210_generic_from_iso +=delimiter;


		}
	
		if(hex_bit(5,1) == "5")// bit 21,22,23,24
		{
			pos_entry_mode_022					= incoming(next_field_last,3);	//022 
			for_athd_024						= incoming((next_field_last+3),3);	//024 
			next_field_last						= next_field_last+3+3;
			response_0210_generic_from_iso +="00022"+pos_entry_mode_022;
			response_0210_generic_from_iso +=delimiter;

		}
	

		if(hex_bit(6,1) == "8")// bit 25,26,27,28
		{
			pos_condition_code_025				= incoming(next_field_last,2);	//025 
			next_field_last					= next_field_last+2;
			response_0210_generic_from_iso +="00025"+pos_condition_code_025;
			response_0210_generic_from_iso +=delimiter;
				
		}
	

		int field32 = 0;
		if(hex_bit(7,1) == "1")// bit 29,30,31,32
		{
			llvar		= incoming(next_field_last,2);	//032 
			field32 = atoi(llvar);
			acquiring_institution_id_code_032		 = incoming((next_field_last+2),field32);	//032 
			next_field_last							 = next_field_last+2+field32;
			response_0210_generic_from_iso +="00032"+acquiring_institution_id_code_032;
			response_0210_generic_from_iso +=delimiter;


		}
	
		int field35 = 0;
		if(hex_bit(8,1) == "2")// bit 33,34,35,36
		{
			llvar								= incoming(next_field_last,2);	//035 
			field35 = atoi(llvar);
			track_2_035 = incoming((next_field_last+2),field35);
			next_field_last = next_field_last+2+field35;
			response_0210_generic_from_iso +="00035"+track_2_035;
			response_0210_generic_from_iso +=delimiter;

		}

		
		if(hex_bit(9,1) == "A")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			responde_code_039			   = incoming((next_field_last+12),2);
			next_field_last				   = next_field_last+12+2;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00039"+responde_code_039;
			response_0210_generic_from_iso +=delimiter;
	
		
	
		}


		if(hex_bit(9,1) == "8")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			next_field_last				   = next_field_last+12;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
		
	
		}
		if(hex_bit(9,1) == "E")// bit 37,38,39,40
		{
			
			retrieval_reference_number_037 = incoming(next_field_last,12);
			responde_id_response_038       = incoming((next_field_last+12),6);
			responde_code_039			   = incoming((next_field_last+12+6),2);
			next_field_last				   = next_field_last+12+6+2;
			response_0210_generic_from_iso +="00037"+retrieval_reference_number_037;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00038"+responde_id_response_038;
			response_0210_generic_from_iso +=delimiter;
			response_0210_generic_from_iso +="00039"+responde_code_039;
			response_0210_generic_from_iso +=delimiter;
		}
	
		int next_field_043 = 0;
		if(hex_bit(10,1) == "E")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			card_acceptor_id_code_042		= incoming((next_field_last+16),15);
			card_acceptor_name_location_043	= incoming((next_field_last+16+15),40);
			next_field_last					= next_field_last+16+15+40;
			response_0210_generic_from_iso +="00041"+card_acceptor_terminal_id_041;
			response_0210_generic_from_iso +=delimiter;

			
		}
			

		if(hex_bit(10,1) == "C")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			card_acceptor_id_code_042		= incoming((next_field_last+16),15);
			next_field_last					= next_field_last+16+15;
			
		}

		if(hex_bit(10,1) == "8")// bit 41,42,43,44
		{
			
			card_acceptor_terminal_id_041	= incoming(next_field_last,16);
			next_field_last					= next_field_last+16;
		}


		int field45= 0;
		int field48 = 0;
		
		int next_field_048 = 0;
		
		if(hex_bit(11,1) == "1")// bit 45,46,47,48
		{
		
			lllvar							= incoming(next_field_last,3);
			field48							= atoi(lllvar);
			addditional_data_048			= incoming((next_field_last+3),field48);
			next_field_last					= next_field_last+3+field48;
			response_0210_generic_from_iso +="00048"+addditional_data_048;
			response_0210_generic_from_iso +=delimiter;
			

		}
	
		if(hex_bit(11,1) == "9")// bit 45,46,47,48
		{
		
			llvar							= incoming(next_field_last,2);
			field45							= atoi(llvar);
			track_1_045						= incoming((next_field_last+2),field45);
			next_field_last					= next_field_last+2+field45;
			
			lllvar							= incoming(next_field_last,3);
			field48							= atoi(lllvar);
			addditional_data_048			= incoming((next_field_last+3),field48);
			next_field_last					= next_field_last+3+field48;
			response_0210_generic_from_iso +="00048"+addditional_data_048;
			response_0210_generic_from_iso +=delimiter;
			

		}
	
		int next_field_052 = 0;
	
		if(hex_bit(12,1) == "8")// bit 49,50,51,52
		{
		
			currency_code_transaction_049	= incoming(next_field_last,3);
			next_field_last					= next_field_last+3;
			response_0210_generic_from_iso +="00049"+currency_code_transaction_049;
			response_0210_generic_from_iso +=delimiter;

			
		}
		if(hex_bit(12,1) == "9")// bit 49,50,51,52
		{
		
			currency_code_transaction_049	= incoming(next_field_last,3);
			pin_data_052					= incoming((next_field_last+3),16);
			next_field_last					= next_field_last+3+16;
			response_0210_generic_from_iso +="00049"+currency_code_transaction_049;
			response_0210_generic_from_iso +=delimiter;

			
		}
	
		if(hex_bit(13,1) == "0")// bit 53,54,55,56
		{
		
	
		}
		if(hex_bit(13,1) == "4")// bit 53,54,55,56
		{

		}
	
		int field60 = 0;
		int next_field_060 = 0;
		if(hex_bit(14,1) == "1")// bit 57,58,59,60
		{
		
			lllvar							= incoming(next_field_last,3);
			field60							= atoi(lllvar);
			pos_terminal_data_060				= incoming((next_field_last+3),field60);
			next_field_last					= next_field_last+3+field60;
			response_0210_generic_from_iso +="00060"+pos_terminal_data_060;
			response_0210_generic_from_iso +=delimiter;

		}
		
		int field61 = 0;
		int field63 = 0;
		if(hex_bit(15,1) == "A")// bit 61,62,63,64
		{
		
			lllvar							= incoming(next_field_last,3);
			field61							= atoi(lllvar);
			card_issuer_response_data_061	= incoming((next_field_last+3),field61);
		
			lllvar							= incoming((next_field_last+3+field61),3);
			field63							= atoi(lllvar);
			additional_data_063				= incoming((next_field_last+3+field61+3),field63);
			
			next_field_last					= next_field_last+3+field61+3+field63;
			response_0210_generic_from_iso +="00061"+card_issuer_response_data_061;
			response_0210_generic_from_iso +=delimiter;
	
		}
		
		
		if(hex_bit(15,1) == "8")// bit 61,62,63,64
		{
		
			lllvar							= incoming(next_field_last,3);
			field61							= atoi(lllvar);
			card_issuer_response_data_061	= incoming((next_field_last+3),field61);
			next_field_last					= next_field_last+3+field61;	
			response_0210_generic_from_iso +="00061"+card_issuer_response_data_061;
			response_0210_generic_from_iso +=delimiter;

			
		}		
	
		if(hex_bit(16,1) == "0")// bit 65,66,67,68
		{
		
			
	
		}
		if(hex_bit(17,1) == "0")// bit 69,70,71,72
		{
		
			
	
		}
		if(hex_bit(18,1) == "0")// bit 73,74,75,76
		{
		
			
	
		}
		
		if(hex_bit(19,1) == "0")// bit 77,78,79,80
		{
		
			

		}
		
		if(hex_bit(20,1) == "0")// bit 81,82,83,84
		{
		
			
	
		}
		
		if(hex_bit(21,1) == "0")// bit 85,86,87,88
		{
		
			
	
		}
		
		if(hex_bit(22,1) == "0")// bit 89,90,91,92
		{
		
			
	
		}
		
		if(hex_bit(23,1) == "0")// bit 93,94,95,96
		{
		
			

		}
		int field100 = 0;
		if(hex_bit(24,1) == "1")// bit 97,98,99,100
		{
		
			llvar = incoming(next_field_last,2);
			field100 = atoi(llvar);
			receiving_institution_id_code_0100 = incoming((next_field_last+2),field100);
			
			next_field_last = next_field_last+2+field100;
	
		}

		if(hex_bit(25,1) == "0")// bit 101,102,103,104
		{
		
	
		}

		if(hex_bit(26,1) == "0")// bit 105,106,107,108
		{
		
			
	
		}
		
		if(hex_bit(27,1) == "0")// bit 109,110,111,112
		{
		
			
	
		}
		
		if(hex_bit(28,1) == "0")// bit 113,114,115,116
		{
		
	
		}
		
		if(hex_bit(29,1) == "0")// bit 117,118,119,120
		{
		
			
	
		
		}
		int field120 = 0;
		if(hex_bit(29,1) == "1")// bit 117,118,119,120
		{
		
			lllvar = incoming(next_field_last,3);
			field120 = atoi(lllvar);
			pos_terminal_address_branch_120	= incoming((next_field_last+3),field120);
			next_field_last					= next_field_last+3+field120;
				
		}
		
		int field121 = 0;
		int field123 = 0;
		int field124 = 0;
		if(hex_bit(30,1) == "9")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field121						= atoi(lllvar);
			authorization_indicators_0121	= incoming((next_field_last+3),field121);
			
			lllvar							= incoming((next_field_last+3+field121),3);
			field124						= atoi(lllvar);
			batch_record2_0124				= incoming((next_field_last+3+field121+3),field124);
			next_field_last					= next_field_last+3+field121+3+field124;
	
		
		}
		if(hex_bit(30,1) == "1")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field124						= atoi(lllvar);
			batch_record2_0124				= incoming((next_field_last+3),field124);
			next_field_last					= next_field_last+3+field124;
			
	
		
		}

		if(hex_bit(30,1) == "2")// bit 121,122,123,124
		{
			
			lllvar							= incoming(next_field_last,3);
			field123						= atoi(lllvar);
			pos_invoice_data_0123			= incoming((next_field_last+3),field123);
			next_field_last					= next_field_last+3+field123;
			
			
		
		
		}
		int field125 = 0;
		int field126 = 0;
		
		if(hex_bit(31,1) == "C")// bit 125,126,127,128
		{
			
			lllvar							= incoming(next_field_last,3);
			field125						= atoi(lllvar);
			pos_settlement_data_125			= incoming((next_field_last+3),field125);
			
			lllvar							= incoming((next_field_last+3+field125),3);
			field126						= atoi(lllvar);
			preauthorization_data_0126		= incoming((next_field_last+3+field125+3),field126);
			next_field_last					= next_field_last+3+field125+3+field126;
			
			response_0210_generic_from_iso +="00125"+pos_settlement_data_125;
			response_0210_generic_from_iso +=delimiter;
	
		
		}
		if(hex_bit(31,1) == "4")// bit 125,126,127,128
		{
			
			
			lllvar							= incoming(next_field_last,3);
			field126						= atoi(lllvar);
			preauthorization_data_0126		= incoming((next_field_last+3),field126);
			next_field_last					= next_field_last+3+field126;
			
	
		
		}
		if(hex_bit(31,1) == "0")// bit 125,126,127,128
		{
			
			
	
		
		}
		if(hex_bit(31,1) == "8")// bit 125,126,127,128
		{
			
			lllvar							= incoming(next_field_last,3);
			field125						= atoi(lllvar);
			pos_settlement_data_125		    = incoming((next_field_last+3),field125);
			next_field_last					= next_field_last+3+field125;
			response_0210_generic_from_iso +="00125"+pos_settlement_data_125;
			response_0210_generic_from_iso +=delimiter;
	
		}


	}
	

	return response_0210_generic_from_iso;

}

RWCString MQUtility::Retorno_Msg_Iso8583_Field125(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

	//cout << "Valor de incoming#2 > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				//response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				//if((j+1) == 61)
				//{
				//	cout << "Valor de lllvar    > :" << lllvar << endl;
				//	cout << "Valor de var_field > :" << var_field << endl;
				//}
			//	if((j+1) == 63)
			//	{
				//	cout << "Valor de lllvar    > :" << lllvar << endl;
				//	cout << "Valor de var_field > :" << var_field << endl;
				//}
				if((j+1) == 125)
				{
					//cout << "Valor de 125 dentro > :" << msg_for_processing(next_field,var_field)  << ":" << endl;
					
					retorno_125 += msg_for_processing(next_field,var_field);
					retorno_125 +=delimiter;
				
				}
				//response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				//response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				if((j+1) == 35)
				{
				//	cout << "Valor de llvar     > :" << llvar << endl;
				//	cout << "Valor de var_field > :" << var_field << endl;
					retorno_125 += msg_for_processing(next_field,var_field);
					retorno_125 +=delimiter;
				
				}
				
				//response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
					if((j+1) == 11)
					{
						retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						retorno_125 +=delimiter;
					}
					else
					if((j+1) == 37)
					{
						retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						retorno_125 +=delimiter;
					}
					/*
					if(j+1 == 53)
					{
						msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						if(debug == 1)

							ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
					//	response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
					//	response_0210_generic_from_iso +=delimiter;
					}
					*/
					//else
					//{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
					//	response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
					//	response_0210_generic_from_iso +=delimiter;
					//}

					//	next_field = next_field+var_field;
				}
			
			}
		}
		
	}

  	return retorno_125;

}

RWCString MQUtility::Retorno_Msg_Iso8583_Field39(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

//	cout << "Valor de incoming#2 > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				//response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				

				/*
				if((j+1) == 125)
				{
					//retorno_125 += msg_for_processing(next_field,var_field);
					//retorno_125 +=delimiter;
				
				}
				*/
				//response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				/*
				if((j+1) == 35)
				{
					//retorno_125 += msg_for_processing(next_field,var_field);
					//retorno_125 +=delimiter;
				
				}
				*/
				//response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
				/*
					if((j+1) == 11)
					{
						//retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//retorno_125 +=delimiter;
					}
					if((j+1) == 37)
					{
						//retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//retorno_125 +=delimiter;
					}
					*/
					if((j+1) == 39)
					{
						retorno_125 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//retorno_125 +=delimiter;
					}
					/*
					if(j+1 == 53)
					{
						msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						if(debug == 1)

							ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
					//response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
					//	response_0210_generic_from_iso +=delimiter;
					}
					*/
					else
					{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						//response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//response_0210_generic_from_iso +=delimiter;
					}
				}
			
			}
		}
		
	}

  	return retorno_125;

}
RWCString MQUtility::Retorno_Msg_Iso8583_Field42(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

//	cout << "Valor de incoming#2 > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(14,4);
		bit_map_from_msg   = incoming(18,32);
		msg_for_processing = incoming(50,incoming.length()-50);
		response_0210_generic_from_iso += incoming(14,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(14,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				//response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				

				/*
				if((j+1) == 125)
				{
					//retorno_125 += msg_for_processing(next_field,var_field);
					//retorno_125 +=delimiter;
				
				}
				*/
				//response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				/*
				if((j+1) == 35)
				{
					//retorno_125 += msg_for_processing(next_field,var_field);
					//retorno_125 +=delimiter;
				
				}
				*/
				//response_0210_generic_from_iso +=delimiter;
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
				/*
					if((j+1) == 11)
					{
						//retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//retorno_125 +=delimiter;
					}
					if((j+1) == 37)
					{
						//retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//retorno_125 +=delimiter;
					}
					*/
					if((j+1) == 42)
					{
						retorno_125 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//retorno_125 +=delimiter;
					}
					/*
					if(j+1 == 53)
					{
						msg_processing_053 = msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						if(debug == 1)

							ReturnIso8583FieldValue(msg_input, j+1  ,test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8));	
						
					//response_0210_generic_from_iso +=test_iso_new.RetornoAsciiComplete(msg_processing_053(0,8),8) ;
					//	response_0210_generic_from_iso +=delimiter;
					}
					*/
					else
					{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
						//response_0210_generic_from_iso +=msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						//response_0210_generic_from_iso +=delimiter;
					}
				}
			
			}
		}
		
	}

  	return retorno_125;

}


RWCString MQUtility::Retorno_Msg_Iso8583_Field11_38_39_41_Amex(RWCString incoming , char *msg_type, 
										          int debug, RWCString application)
{

//	cout << "Valor de incoming#2 > " << incoming << endl;
	RWCString  hex_bit = "";
	RWCString  field45	;
	RWCString  bit_map_from_msg   ;
	RWCString  msg_for_processing ;
	RWCString  msg_processing_053 ;
	RWCString  bit_set_fiedl;
	RWCString  ascii_bit;
	RWCString  delimiter = ",";
	RWCString  retorno_125 = "";
	RWCString  msg_type_from_incming ;
	int next_field_last = 0;
	int next_field = 0;
	int var_field = 0;
	char msg_input[5] = {""};

	//Se crea los fields con valores fijos
    RWTValVector<int> iso_field_length(129,0);
	      
	iso_field_length[3]  = 6; 	iso_field_length[4]  = 12; 	iso_field_length[5]  = 12;
	iso_field_length[7]  = 10;	iso_field_length[11] = 6; 	iso_field_length[12] = 6; 	
	iso_field_length[13] = 4;	iso_field_length[14] = 4;  	iso_field_length[15] = 4; 
	iso_field_length[16] = 4;   iso_field_length[17] = 4;   iso_field_length[18] = 4;	
	iso_field_length[22] = 3;	iso_field_length[25] = 2;   iso_field_length[26] = 2;
	iso_field_length[28] = 9;   iso_field_length[30] = 9; 	iso_field_length[37] = 12; 
	iso_field_length[38] = 6;   iso_field_length[39] = 2; 	iso_field_length[42] = 15;  
	iso_field_length[43] = 40;  iso_field_length[49] = 3; 	iso_field_length[52] = 16;
	iso_field_length[53] = 48;	iso_field_length[54] = 120; iso_field_length[70] = 3;
	iso_field_length[95] = 42;  iso_field_length[66] = 1;   iso_field_length[74] = 10;
	iso_field_length[75] = 10;  iso_field_length[76] = 10;  iso_field_length[77] = 10;
	iso_field_length[78] = 10;  iso_field_length[79] = 10;  iso_field_length[80] = 10;
	iso_field_length[81] = 10;  iso_field_length[82] = 12;  iso_field_length[83] = 12;
	iso_field_length[84] = 12;  iso_field_length[85] = 12;  iso_field_length[86] = 16;
	iso_field_length[87] = 16;  iso_field_length[88] = 16;  iso_field_length[89] = 16;
	iso_field_length[97] = 17;  iso_field_length[90] = 42;

	
	if(application == "base24")
	{
		iso_field_length[41] = 16;
	}

	if(application == "posterm")
	{
		iso_field_length[41] = 8;
	}

	MQUtility test_iso_new;
	MQUtility get_bit_map_ascii;
	MQUtility field_length;

	if(application == "posterm")
	{

		msg_type_from_incming = incoming(7,4);

		response_0210_generic_from_iso += incoming(7,4);
		
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(7,4));
		response_0210_generic_from_iso +=delimiter;

		ascii_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,1),1);

		if (ascii_bit(0,1) == "7")
		{
			 hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,8),8);
			 hex_bit += "0000000000000000";
			 if(debug == 1)
				cout << "Valor de BitMap #1 > :" << hex_bit << endl;
			 bit_map_from_msg   = hex_bit;
			 msg_for_processing = incoming(19,incoming.length()-19);
			 

		}

		else
		{
			hex_bit = get_bit_map_ascii.RetornoAsciiComplete(incoming(11,16),16);
		 
			if(debug == 1)
		 
				 cout << "Valor de BitMap  #2 > :" << hex_bit << endl;
			bit_map_from_msg   = hex_bit;
			msg_for_processing = incoming(27,incoming.length()-27);

		}
	}

	if(application == "base24")
	{

	    msg_type_from_incming = incoming(16,4);
		bit_map_from_msg   = incoming(20,32);
		msg_for_processing = incoming(52,incoming.length()-52);
		response_0210_generic_from_iso += incoming(16,4);
		if(debug == 1)
		ReturnIso8583FieldValue(strcpy(msg_input,msg_type_from_incming), 0  , incoming(16,4));
		response_0210_generic_from_iso +=delimiter;

	}




	bit_set_fiedl = test_iso_new.setBitMapFromChar(bit_map_from_msg);

	//Se saca el message type de retorno para enviarse
	int j = 0;

	for(j = 0; j < 128; j++)
	{
		if(bit_set_fiedl(j,1) == "1")
		{
	
			switch (field_length.RetornoFieldNumber(j+1))
			{
			case LLLVAR:
			
				lllvar	= msg_for_processing(next_field,LLLVAR);
				var_field = atoi(lllvar);
				next_field = next_field+LLLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
			
				/*
				if((j+1) == 125)
				{
					retorno_125 += msg_for_processing(next_field,var_field);
					retorno_125 +=delimiter;
				
				}
				*/
			
				next_field = next_field+var_field;
				

				break;
		
			case LLVAR:
				
				llvar	= msg_for_processing(next_field,LLVAR);
				var_field = atoi(llvar);
				next_field = next_field+LLVAR;
				if(debug == 1)
					ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing(next_field,var_field));
				response_0210_generic_from_iso +=msg_for_processing(next_field,var_field);
				
				next_field = next_field+var_field;
				break;
			
			case FIXED:
				
				
				next_field = next_field+iso_field_length[j+1];
				if((j+1 != 0) && (j+1 != 1))
				{
				
					if((j+1) == 11)
					{
						retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						retorno_125 +=delimiter;
					}
					if((j+1) == 13)
					{
						retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						retorno_125 +=delimiter;
					}
					if((j+1) == 38)
					{
						retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						retorno_125 +=delimiter;
					}
				
					if((j+1) == 39)
					{
						retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						retorno_125 +=delimiter;
					}
					
					if((j+1) == 41)
					{
						retorno_125 += msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]);
						retorno_125 +=delimiter;
					}
				
					else
					{
						if(debug == 1)
							ReturnIso8583FieldValue(msg_input, j+1  , msg_for_processing((next_field-iso_field_length[j+1]),iso_field_length[j+1]));
					
				
					}
				}
			
			}
		}
		
	}

  	return retorno_125;

}



RWCString MQUtility::getIsoGenericTerminalIdITBIS( RWCString incoming) 
{

    char incoming_field[256] = {""};
	RWCString msg_reponse_with_tcp_header = "";
	int count = 0;
	BOOL flag_salida = TRUE;
	RWCTokenizer next(incoming);
	RWCString token;
	while(!(token=next(",")).isNull())
	{	
		if (count == 0)
		{
			message_type = token; 
			int message_type_length = message_type.length();
			if( message_type_length != 4)
			{
				
				MessageErrorLength(RWCString("message_type"),
					message_type_length,4);
				flag_salida = FALSE;
				break;
			}
			
			strcpy(incoming_field,message_type);
		
			if ( (VerifyNumericField(incoming_field, 4,
					RWCString("message_type"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}
		if (count == 1)
		{
			processing_code= token; 
			int processing_code_length = processing_code.length();
			if( processing_code_length != 6)
			{
				
				MessageErrorLength(RWCString("processing_code"),
					processing_code_length,6);
				flag_salida = FALSE;
				break;
			}
			
			strcpy(incoming_field,processing_code);
		
			if ( (VerifyNumericField(incoming_field, 6,
					RWCString("processing_code"))) == 0)
			{
			//	flag_salida = FALSE;
				break;
			}

		}
		
		if (count == 2)
		{
			transaction_amount = token; 

		}
		if (count == 3)
		{
			transaction_amount_itbis = token; 

		}

		if (count == 4)
		{
			transmition_date_time = token; 
			int transmition_date_time_length = transmition_date_time.length();
			if( transmition_date_time_length != 10)
			{
				MessageErrorLength(RWCString("transmition_date_time"),
					transmition_date_time_length,10);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,transmition_date_time);
		
			if ( (VerifyNumericField(incoming_field,10 ,
					RWCString("transmition_date_time"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			
		}

		if (count == 5)
		{
		
			system_trace = token; 
			int system_trace_length = system_trace.length();
			if( system_trace_length != 6)
			{
				MessageErrorLength(RWCString("system_trace"),
					system_trace_length,6);
				flag_salida = FALSE;
				break;
			}
		
			strcpy(incoming_field,system_trace);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("system_trace"))) == 0)
			{
				break;
			}
	
		}				 
					
		if (count == 6) 
		{				
					
			time_local_transaction = token;
			int time_local_transaction_length = time_local_transaction.length();
			if( time_local_transaction_length != 6)
			{
				MessageErrorLength(RWCString("time_local_transaction"),
					time_local_transaction_length,6);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,time_local_transaction);
			if ( (VerifyNumericField(incoming_field,6 ,
					RWCString("time_local_transaction"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
		
		}
	
		if (count == 7)
		{
				
			date_local_transaction = token; 
			int date_local_transaction_length = date_local_transaction.length();
			if( date_local_transaction_length != 4)
			{
				MessageErrorLength(RWCString("date_local_transaction"),
				date_local_transaction_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,date_local_transaction);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("date_local_transaction"))) == 0)
			{
				break;
			}
			

		}				 

		
		if (count == 8)
		{
				
			expiration_date = token; 
			int expiration_date_length = expiration_date.length();
			if( expiration_date_length != 4)
			{
				MessageErrorLength(RWCString("expiration_date"),
				expiration_date_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,expiration_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("expiration_date"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}
			

		}				 
		if (count == 9)
		{
				
			capture_date = token; 
			int capture_date_length = capture_date.length();
			if( capture_date_length != 4)
			{
				MessageErrorLength(RWCString("capture_date"),
				capture_date_length,4);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,capture_date);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("capture_date"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}				 
	
		if (count == 10)
		{
				
			merchant_type = token; 
			int merchant_type_length = merchant_type.length();
			if( merchant_type_length != 4)
			{
				MessageErrorLength(RWCString("merchant_type"),
				merchant_type_length,4);
				flag_salida = FALSE;
				break;
			}

			strcpy(incoming_field,merchant_type);
			if ( (VerifyNumericField(incoming_field,4 ,
					RWCString("merchant_type"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (count == 11)
		{
				
			pos_entry_mode = token; 
			int pos_entry_mode_length = pos_entry_mode.length();
			if( pos_entry_mode_length != 3)
			{
				MessageErrorLength(RWCString("pos_entry_mode"),
				pos_entry_mode_length,3);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_entry_mode);
			if ( (VerifyNumericField(incoming_field,3 ,
					RWCString("pos_entry_mode"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}

		}		

		if (count == 12)
		{
			pos_condition_code = token; 
			int pos_condition_code_length = pos_condition_code.length();
			if( pos_condition_code_length != 2)
			{
				MessageErrorLength(RWCString("pos_condition_code"),
				pos_condition_code_length,2);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pos_condition_code);
			if ( (VerifyNumericField(incoming_field,2 ,
					RWCString("pos_condition_code"))) == 0)
			{
				flag_salida = FALSE;
				break;
			}


		}		

		if (count == 13)
		{
			
			//Este campo es variable y debe ser de 9 y delante del campo debe ir un 09
			//RWCString length_fiel_032 = "09"
			acquiring_institution_id_code = token; 
			
			int acquiring_institution_id_code_length = acquiring_institution_id_code.length();
			if( acquiring_institution_id_code_length != 9)
			{
				MessageErrorLength(RWCString("acquiring_institution_id_code"),
				acquiring_institution_id_code_length,9);
				flag_salida = FALSE;
				break;
			}

		}		
		
		if (count == 14)
		{
			
			//Este campo es variable y debe ser de 37 y delante del campo debe ir un 37
			track_2 = token; 
			int track_2_length = track_2.length();
			if( track_2_length > 37)
			{
				MessageErrorLength(RWCString("track_2"),
				track_2_length,37);
				flag_salida = FALSE;
				break;
			}
		}	

		if (count == 15)
		{
			retrieval_reference_number = token; 
			int retrieval_reference_number_length = retrieval_reference_number.length();
			if( retrieval_reference_number_length != 12)
			{
				MessageErrorLength(RWCString("retrieval_reference_number"),
				retrieval_reference_number_length,12);
				flag_salida = FALSE;
				break;
			}
		}	

		if (count == 16)
		{
			card_acceptor_terminal_id = token; 
			int card_acceptor_terminal_id_length = card_acceptor_terminal_id.length();
			if( card_acceptor_terminal_id_length != 16)
			{
				MessageErrorLength(RWCString("card_acceptor_terminal_id"),
				card_acceptor_terminal_id_length,16);
				flag_salida = FALSE;
				break;
			}
		}			

	
		if (count == 17)
		{
			card_acceptor_id_code = token; 
			int card_acceptor_id_code_length = card_acceptor_id_code.length();
			if( card_acceptor_id_code_length != 15)
			{
				MessageErrorLength(RWCString("card_acceptor_id_code"),
				card_acceptor_id_code_length,15);
				flag_salida = FALSE;
				break;
			}
		}
	
		if (count == 18)
		{
			card_acceptor_name_location = token; 
			int card_acceptor_name_location_length = card_acceptor_name_location.length();
			if( card_acceptor_name_location_length != 40)
			{
				MessageErrorLength(RWCString("card_acceptor_name_location"),
				card_acceptor_name_location_length,40);
				flag_salida = FALSE;
				break;
			}
		}			

		if (count == 19)
		{
			pos_retailer_data = token; 
			/*
			int pos_retailer_data_length = pos_retailer_data.length();
			if( pos_retailer_data_length != 27)
			{
				MessageErrorLength(RWCString("pos_retailer_data"),
				pos_retailer_data_length,27);
				flag_salida = FALSE;
				break;
			}
			*/
		}				
		if (count == 20)
		{
			currency_code_transaction = token; 
			int currency_code_transaction_length = currency_code_transaction.length();
			if( currency_code_transaction_length != 3)
			{
				MessageErrorLength(RWCString("currency_code_transaction"),
				currency_code_transaction_length,3);
				flag_salida = FALSE;
				break;
			}
		}			

		if (count == 21)
		{
			pin_data = token; 
			int pin_data_length = pin_data.length();
			if( pin_data_length != 16)
			{
				MessageErrorLength(RWCString("pin_data"),
				pin_data_length,16);
				flag_salida = FALSE;
				break;
			}
			strcpy(incoming_field,pin_data);
			if ( (VerifyHexField(incoming_field,16 ,
					RWCString("pin_data"))) == 0)
			{
				break;
			}
	
		}			
	
		if (count == 22)
		{
			pos_terminal_data = token; 
			int pos_terminal_data_length = pos_terminal_data.length();
			if( pos_terminal_data_length != 16)
			{
				MessageErrorLength(RWCString("pos_terminal_data"),
				pos_terminal_data_length,16);
				flag_salida = FALSE;
				break;
			}
		
		}			
	
		if (count == 23)
		{
			pos_issuer_data = token; 
			int pos_issuer_data_length = pos_issuer_data.length();
			if( pos_issuer_data_length != 19)
			{
				MessageErrorLength(RWCString("pos_issuer_data"),
				pos_issuer_data_length,19);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (count == 24)
		{
			CVV2 = token; 
			/*
			int CVV2_length = CVV2.length();
			if( CVV2_length != 45)
			{
				MessageErrorLength(RWCString("CVV2"),
				CVV2_length,15);
				flag_salida = FALSE;
				break;
			}
			*/
		}
		
		
		if (count == 25)
		{
			pos_terminal_address_branch = token; 
			int pos_terminal_address_branch_length = pos_terminal_address_branch.length();
			if( pos_terminal_address_branch_length != 29)
			{
				MessageErrorLength(RWCString("pos_terminal_address_branch"),
				pos_terminal_address_branch_length,29);
				flag_salida = FALSE;
				break;
			}
		
		}			


		if (count == 26)
		{
			pos_invoice_data = token; 
			int pos_invoice_data_length = pos_invoice_data.length();
			if( pos_invoice_data_length != 20)
			{
				MessageErrorLength(RWCString("pos_invoice_data"),
				pos_invoice_data_length,20);
				flag_salida = FALSE;
				break;
			}
		
		}			

		if (count == 27)
		{
			pos_settlement_data = token; 
			int pos_settlement_data_length = pos_settlement_data.length();
			if( pos_settlement_data_length != 12)
			{
				MessageErrorLength(RWCString("pos_settlement_data"),
				pos_settlement_data_length,12);
				break;
			}
		
		}			

		count++;
	}

	  return	pos_settlement_data+","+transaction_amount+","+card_acceptor_id_code+","+card_acceptor_terminal_id;
		
}



RWCString MQUtility::RetornoPreZeroes(int incoming_field )
{

	 
	RWCString test_pre;	

	char pre_test = '\x30';
	char buffer[3] = {""};
	_itoa( incoming_field, buffer, 10 );
	test_pre = buffer ;
	size_t test = 5-test_pre.length();
	test_pre.prepend(pre_test , test);

	return test_pre;
	
}


MQUtility::~MQUtility()
{

}
